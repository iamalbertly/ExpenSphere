<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://apis.google.com https://accounts.google.com https://sheets.googleapis.com https://*.googleapis.com https://raw.githubusercontent.com; connect-src 'self' ws://127.0.0.1:* wss://127.0.0.1:* ws://localhost:* wss://localhost:* http://127.0.0.1:* http://localhost:* https://sheets.googleapis.com https://accounts.google.com https://apis.googleapis.com https://*.googleapis.com https://raw.githubusercontent.com https://*.githubusercontent.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; frame-src https://accounts.google.com"><title>Expense Tracker v0.0.23</title><style>:root{ --primary-color: #f5a623; --bg-dark: #1e1e2e; --bg-card: #28293d; --bg-input: #33344b; --text-light: #f5f5f5; --text-muted: #8e8ea0; --spacing-unit: clamp(8px, 2vw, 20px);} body{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: var(--bg-dark); color: var(--text-light); margin: 0; padding: 0; min-height: 100vh; display: flex; flex-direction: column;} .container{ margin: var(--spacing-unit) auto; width: min(95%, 600px); background-color: var(--bg-card); padding: var(--spacing-unit); border-radius: 10px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); flex: 1; display: flex; flex-direction: column; gap: var(--spacing-unit);} h1{ font-size: clamp(1.5rem, 4vw, 2rem); text-align: center; margin: 0; color: var(--primary-color); display: flex; align-items: center; justify-content: center; gap: 8px;} .version{ font-size: 0.6em; opacity: 0.8;} .results-section{ order: -1; display: flex; flex-direction: column; gap: var(--spacing-unit); min-height: 200px; max-height: 60vh; overflow-y: auto;} .transaction-navigation{ display: grid; grid-template-columns: auto 1fr auto; gap: 10px; align-items: center; justify-content: center; margin-bottom: 5px;} .nav-button{ background: var(--bg-input); border: none; color: var(--text-light); padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 14px; width: auto; margin: 0;} .transaction-indicator{ text-align: center; color: var(--primary-color); font-size: 14px;} .editable-container{ display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; padding: 12px; background: var(--bg-input); border-radius: 8px; margin-bottom: 8px; max-height: calc(100vh - 250px); overflow-y: auto;} .editable-field{ background: var(--bg-card); padding: 12px; border-radius: 6px; cursor: pointer; transition: transform 0.2s ease, background-color 0.2s ease;} .editable-field.full-width{ grid-column: 1 / -1;} .editable-label{ font-size: 12px; color: var(--text-muted); margin-bottom: 4px; font-weight: 500;} .editable-value{ font-size: 14px; line-height: 1.4; word-break: break-word; color: var(--text-light);} .input-section{ position: sticky; bottom: 0; background: var(--bg-card); padding: var(--spacing-unit); z-index: 10; display: grid; grid-template-columns: 1fr auto auto; gap: 8px; box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);} .action-buttons{ display: flex; gap: 8px; align-items: flex-end;} .submit-button, .save-button{ height: 40px; padding: 0 16px; border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; transition: transform 0.2s, background-color 0.2s; white-space: nowrap; display: flex; align-items: center; gap: 4px;} .submit-button{ background: var(--primary-color); color: var(--bg-dark);} .save-button{ background: var(--bg-input); color: var(--text-light);} .submit-button:hover, .save-button:hover{ transform: translateY(-1px);} .submit-button:hover{ background: #d48821;} .save-button:hover{ background: #444561;} @media screen and (max-width: 768px){ .input-section{ grid-template-columns: 1fr; gap: 12px; padding: 12px;} .action-buttons{ display: grid; grid-template-columns: 1fr 1fr; gap: 8px;} .submit-button, .save-button{ width: 100%; justify-content: center;}} .pending-badge{ position: absolute; top: -8px; right: -8px; background: var(--primary-color); color: var(--bg-dark); border-radius: 12px; padding: 2px 6px; font-size: 12px; font-weight: bold;} .loading-overlay{ position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(30, 30, 46, 0.9); backdrop-filter: blur(4px); display: none; justify-content: center; align-items: center; z-index: 2000;} .loading-spinner{ width: 40px; height: 40px; border: 3px solid var(--bg-input); border-top: 3px solid var(--primary-color); border-radius: 50%; animation: spin 0.8s cubic-bezier(0.4, 0, 0.2, 1) infinite;} @keyframes spin{ 0%{ transform: rotate(0deg);} 100%{ transform: rotate(360deg);}} .error-notification{ display: none; position: fixed; top: 0; left: 0; right: 0; background: linear-gradient(to right, #ff4444, #ff6b6b); color: white; padding: 15px; z-index: 1001; animation: slideDown 0.5s ease-out; box-shadow: 0 4px 15px rgba(255, 68, 68, 0.3); transform: translateY(-100%); transition: transform 0.3s ease;} .error-notification.show{ display: flex; justify-content: space-between; align-items: flex-start; transform: translateY(0);} .error-content{ flex-grow: 1; margin-right: 20px;} .error-title{ font-weight: bold; margin-bottom: 5px; font-size: 16px;} .error-message{ font-size: 14px; line-height: 1.4;} .error-close{ background: none; border: none; color: white; font-size: 24px; cursor: pointer; padding: 0 5px; opacity: 0.8; transition: opacity 0.2s;} .error-close:hover{ opacity: 1;} @media screen and (max-width: 768px){ .container{ padding: var(--spacing-unit); gap: var(--spacing-unit); height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));} .input-section{ position: sticky; bottom: env(safe-area-inset-bottom); margin-bottom: -var(--spacing-unit); padding: var(--spacing-unit); background: var(--bg-card); border-top: 1px solid rgba(255, 255, 255, 0.1); box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);} .results-section{ flex: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; margin: 0 -var(--spacing-unit); padding: 0 var(--spacing-unit);} .error-notification{ padding-top: calc(env(safe-area-inset-top) + 15px);}} .success-notification{ background: linear-gradient(to right, #4CAF50, #45a049); box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3); border-radius: 8px;} .edit-overlay{ position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(4px); z-index: 1002; display: none; opacity: 0; transition: opacity 0.3s ease;} .edit-overlay.show{ display: flex; justify-content: center; align-items: center; opacity: 1;} .edit-modal{ background: var(--bg-card); border-radius: 12px; padding: 20px; width: 90%; max-width: 400px; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4); transform: translateY(-20px); opacity: 0; transition: transform 0.3s ease, opacity 0.3s ease; display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1003;} .edit-modal.show{ display: block; transform: translate(-50%, -50%); opacity: 1;} .edit-modal h3{ margin: 0 0 15px 0; color: var(--text-light);} .edit-modal-content{ margin-bottom: 20px;} .edit-modal-content input, .edit-modal-content select{ width: 100%; padding: 10px; border: 1px solid var(--bg-input); border-radius: 6px; background: var(--bg-input); color: var(--text-light); font-size: 16px;} .edit-modal-buttons{ display: flex; gap: 10px;} .edit-modal-buttons button{ flex: 1; padding: 10px; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; transition: background-color 0.2s;} .edit-modal-buttons button:not(.cancel){ background: var(--primary-color); color: var(--bg-dark);} .edit-modal-buttons button.cancel{ background: var(--bg-input); color: var(--text-light);} .compact-field{ cursor: pointer; position: relative;} .compact-field:hover::after{ content: '✎'; position: absolute; right: 5px; top: 50%; transform: translateY(-50%); color: #f5a623; font-size: 14px;} .compact-field.edited::before{ content: '✓'; position: absolute; left: -15px; top: 50%; transform: translateY(-50%); color: #4CAF50; font-size: 12px;} .edited-indicator{ position: absolute; right: -25px; top: 50%; transform: translateY(-50%); color: #4CAF50; font-size: 12px; font-weight: bold; opacity: 0; transition: opacity 0.3s;} .edited .edited-indicator{ opacity: 1;} .compact-field{ position: relative; padding: 8px; border-radius: 6px; transition: background-color 0.2s;} .compact-field:hover{ background-color: #3f4060;} .compact-field.edited{ padding-left: 25px;} .compact-field.edited::before{ left: 5px;} @media screen and (max-width: 768px){ .edit-modal{ width: 95%; max-width: none; margin: 10px;} .edit-modal .editable-input, .edit-modal .editable-select{ font-size: 16px; padding: 12px;} .edit-modal-buttons button{ padding: 12px; font-size: 16px;}} @media (hover: none){ .transaction-navigation::after{ content: 'Swipe to navigate'; position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); font-size: 12px; color: #8e8ea0; opacity: 0.7;}} .title-section{ position: sticky; top: 0; background: var(--bg-card); padding: var(--spacing-unit) 0; margin: calc(var(--spacing-unit) * -1) calc(var(--spacing-unit) * -1) 0; border-bottom: 1px solid rgba(255, 255, 255, 0.1); z-index: 10;} .collapsible-trigger{ background: none; border: none; color: var(--primary-color); cursor: pointer; padding: 8px; width: 100%; text-align: left; font-size: 14px; display: flex; align-items: center; gap: 8px; margin-top: 8px;} .collapsible-trigger::before{ content: '+'; font-size: 18px; font-weight: bold;} .collapsible-trigger.expanded::before{ content: '-';} .collapsible-content{ display: none; padding-top: 8px;} .collapsible-content.show{ display: block;} .confidence-display{ color: var(--text-muted); font-size: 12px; text-align: right; padding: 4px 8px; background: var(--bg-input); border-radius: 4px; margin-top: 4px;} .feedback-section{ display: flex; align-items: center; gap: 10px; padding: 10px; background: var(--bg-input); border-radius: 8px; margin-bottom: 12px;} .feedback-button{ background: none; border: none; font-size: 20px; cursor: pointer; opacity: 0.7; transition: opacity 0.2s;} .feedback-button:hover{ opacity: 1;} .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} .submit-options{ display: flex; flex-direction: column; gap: 12px; margin: 15px 0;} .submit-option{ display: flex; flex-direction: column; align-items: flex-start; padding: 12px; background: var(--bg-input); border: none; border-radius: 8px; color: var(--text-light); cursor: pointer; transition: background 0.2s, transform 0.2s; width: 100%; text-align: left;} .submit-option:hover{ background: var(--primary-color); color: var(--bg-dark); transform: translateY(-1px);} .submit-option small{ color: var(--text-muted); font-size: 0.8em; margin-top: 4px;} .submit-option:hover small{ color: var(--bg-dark);} .pending-transactions{ margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--bg-input);} .pending-transactions h4{ color: var(--text-muted); font-size: 0.9em; margin: 0 0 8px 0;} .view-pending{ width: 100%; padding: 10px; background: var(--bg-input); border: none; border-radius: 8px; color: var(--text-light); cursor: pointer; transition: background 0.2s;} .view-pending:hover{ background: var(--primary-color); color: var(--bg-dark);} .pending-list{ display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px; max-height: 60vh; overflow-y: auto; padding: 4px; margin: 15px 0;} .pending-item{ background: var(--bg-input); border-radius: 8px; padding: 12px; display: flex; flex-direction: column; gap: 8px;} .pending-info{ margin-bottom: 8px;} .pending-details{ display: flex; flex-wrap: wrap; gap: 8px; margin-top: 4px; font-size: 0.9em; color: var(--text-muted);} .pending-actions{ display: flex; gap: 8px;} .pending-actions button{ padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em; transition: transform 0.2s, opacity 0.2s;} .pending-actions button:hover{ transform: translateY(-1px); opacity: 0.9;} .submit-one{ background: var(--primary-color); color: var(--bg-dark);} .remove-one{ background: var(--bg-card); color: var(--text-light);} .submit-all{ background: var(--primary-color); color: var(--bg-dark); padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; transition: transform 0.2s, opacity 0.2s;} .submit-all:hover{ transform: translateY(-1px); opacity: 0.9;} @media screen and (max-width: 768px){ .pending-list{ max-height: 70vh;} .pending-actions{ flex-direction: column;} .pending-actions button{ width: 100%; padding: 8px;}} </style></head><body><div class="loading-overlay"><div class="loading-spinner"></div></div><div class="error-notification"><div class="error-content"><div class="error-title"></div><div class="error-message"></div></div><button class="error-close" onclick="closeError()">×</button></div><div class="container"><div class="title-section"><h1>ExpenSphere <span class="version">v0.0.25</span></h1></div><div class="results-section"><div class="transaction-navigation"><button class="nav-button" id="prevTransaction" disabled onclick="navigateTransaction(-1)">← Previous</button><span class="transaction-indicator">1 of 1</span><button class="nav-button" id="nextTransaction" disabled onclick="navigateTransaction(1)">Next →</button></div><div class="editable-container" id="editableContainer"></div></div><div class="input-section"><textarea id="inputText" placeholder="Type your expense description and press Enter... (Use && or 'Also' for multiple transactions)"></textarea><div class="action-buttons"><button class="submit-button" onclick="EventHandlers.handleSubmit()">Submit Online</button><button class="save-button" onclick="EventHandlers.handleSave()">Save for Later</button></div></div></div><div class="edit-overlay"></div><div class="edit-modal"><h3>Edit Field</h3><div class="edit-modal-content"></div><div class="edit-modal-buttons"><button class="cancel" onclick="window.closeEditModal()">Cancel</button><button onclick="window.saveEdit()">Save</button></div></div><div class="submit-confirmation"><h3>Confirm Transactions</h3><div class="transaction-list"></div><div class="confirmation-buttons"><button class="cancel" onclick="closeConfirmation()">Cancel</button><button onclick="submitOnline()">Submit Online</button><button onclick="saveForLater()">Save for Later</button></div></div><script type="module">import config from './config.js'; window.CLIENT_ID=config.clientId; </script><script>window.closeEditModal=function(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.classList.remove('show'); if (overlay) overlay.classList.remove('show'); window.currentEditField=null;}; window.closeError=function(){ document.querySelector('.error-notification')?.classList.remove('show');}; window.saveEdit=function(){ if (window.EventHandlers){ window.EventHandlers.handleSaveEdit();}}; window.showEditModal=function(field, value){ if (window.ModalManager){ window.ModalManager.showEditModal(field, value);}}; window.processInput=function(){ if (window.processInputFunction){ window.processInputFunction();}}; window.navigateTransaction=function(direction){ if (window.navigateTransactionFunction){ window.navigateTransactionFunction(direction);}}; window.generatedData=null; window.tokenClient=null; window.transactions=[]; window.currentTransactionIndex=0; window.currentEditField=null; const ENV={ isProd: window.location.hostname !=='localhost', get apiBaseUrl(){ return this.isProd ? 'https://sheets.googleapis.com/v4/' : 'http://localhost:3000/api/';}}; const VERSION={ major: 0, minor: 0, patch: 25, buildDate: '2024-03-19', toString(){ return `${this.major}.${this.minor}.${this.patch}`;}}; const SCOPES="https://www.googleapis.com/auth/spreadsheets"; const SPREADSHEET_ID="__SPREADSHEET_ID__"; const FETCH_TIMEOUT=30000; const EVENTS={ INPUT: 'input', KEYDOWN: 'keydown', LOAD: 'load', DOMCONTENTLOADED: 'DOMContentLoaded'}; const STORAGE_KEYS={ PENDING_TRANSACTIONS: 'expenseSphere_pendingTransactions', TRAINING_DATA: 'editTrainingData', AI_PATTERNS: 'aiPatterns', HISTORICAL_TRANSACTIONS: 'historicalTransactions'}; const UI={ selectors:{ inputText: '#inputText', editableContainer: '#editableContainer', editModal: '.edit-modal', editOverlay: '.edit-overlay', saveButton: '.save-button', submitButton: '.submit-button', transactionIndicator: '.transaction-indicator', prevButton: '#prevTransaction', nextButton: '#nextTransaction'}, classes:{ show: 'show', edited: 'edited', expanded: 'expanded'}}; const TOKEN_MANAGEMENT={ async isTokenValid(token){ if (!token) return false; try{ const response=await fetchWithTimeout( `${ENV.apiBaseUrl}spreadsheets/${SPREADSHEET_ID}/values/ExpenseResults!A1`, { headers:{ Authorization: `Bearer ${token}`},} ); return response.ok;} catch{ return false;}}, storeToken(token){ try{ localStorage.setItem('expenseTrackerToken', token); localStorage.setItem('tokenTimestamp', Date.now().toString());} catch (e){ console.error('Error storing token:', e);}}, getStoredToken(){ try{ const token=localStorage.getItem('expenseTrackerToken'); const timestamp=parseInt(localStorage.getItem('tokenTimestamp'), 10); if (token && timestamp && (Date.now() - timestamp < 3600000)){ return token;}} catch (e){ console.error('Error getting token:', e);} return null;}, clearStoredToken(){ try{ localStorage.removeItem('expenseTrackerToken'); localStorage.removeItem('tokenTimestamp');} catch (e){ console.error('Error clearing token:', e);}}}; const utils={ async fetchWithTimeout(url, options={}){ const controller=new AbortController(); const timeoutId=setTimeout(()=>controller.abort(), FETCH_TIMEOUT); try{ const response=await fetch(url,{ ...options, signal: controller.signal}); clearTimeout(timeoutId); return response;} catch (error){ clearTimeout(timeoutId); throw error.name==='AbortError' ? new Error('Request timed out') : error;}}, getElement(selector){ return document.querySelector(selector);}, createElement(tag, className, innerHTML=''){ const element=document.createElement(tag); if (className) element.className=className; if (innerHTML) element.innerHTML=innerHTML; return element;}, showElement(element){ if (typeof element==='string'){ element=this.getElement(element);} element?.classList.add(UI.classes.show);}, hideElement(element){ if (typeof element==='string'){ element=this.getElement(element);} element?.classList.remove(UI.classes.show);}}; const ErrorHandler={ show(title, message, details=''){ const notification=utils.getElement('.error-notification'); if (!notification) return; const titleElement=notification.querySelector('.error-title'); const messageElement=notification.querySelector('.error-message'); if (titleElement && messageElement){ titleElement.textContent=title; messageElement.innerHTML=` <p>${message}</p>${details ? `<p><strong>Details:</strong>${details}</p>` : ''} `; utils.showElement(notification); setTimeout(()=>utils.hideElement(notification), 5000);}}, close(){ utils.hideElement('.error-notification');}}; const SuccessHandler={ show(message){ const existingNotification=utils.getElement('.success-notification'); if (existingNotification){ existingNotification.remove();} const notification=utils.createElement('div', 'success-notification show'); notification.textContent=message; document.body.appendChild(notification); setTimeout(()=>notification.remove(), 3000);}}; const PURCHASE_CATEGORIES=[ "Groceries & Household", "Gift to Family & Friends", "Petrol & Transport", "Medical & Medicine", "Utilities & Bills", "Eating Out & Entertainment" ]; const OfflineStorage={ savePendingTransaction(transaction){ try{ const pending=this.getPendingTransactions(); pending.push({ ...transaction, savedAt: new Date().toISOString(), id: Date.now().toString()}); localStorage.setItem(STORAGE_KEYS.PENDING_TRANSACTIONS, JSON.stringify(pending)); return true;} catch (error){ console.error('Error saving pending transaction:', error); return false;}}, getPendingTransactions(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEYS.PENDING_TRANSACTIONS) || '[]');} catch (error){ console.error('Error getting pending transactions:', error); return [];}}, removePendingTransaction(id){ try{ const pending=this.getPendingTransactions(); const filtered=pending.filter(t=>t.id !==id); localStorage.setItem(STORAGE_KEYS.PENDING_TRANSACTIONS, JSON.stringify(filtered)); return true;} catch (error){ console.error('Error removing pending transaction:', error); return false;}}, clearPendingTransactions(){ try{ localStorage.setItem(STORAGE_KEYS.PENDING_TRANSACTIONS, '[]'); return true;} catch (error){ console.error('Error clearing pending transactions:', error); return false;}}}; function showSubmitOptions(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} const pendingCount=OfflineStorage.getPendingTransactions().length; const modal=document.createElement('div'); modal.className='edit-modal show'; modal.innerHTML=` <h3>Submit Options</h3><div class="submit-options"><button onclick="submitOnline()" class="submit-option"><span>📤 Submit Now</span><small>Submit directly to Google Sheets</small></button><button onclick="saveForLater()" class="submit-option"><span>💾 Save for Later</span><small>Store locally and submit when online</small></button>${pendingCount >0 ? ` <div class="pending-transactions"><h4>Pending Transactions</h4><button onclick="showPendingTransactions()" class="view-pending"><span>📋 View Saved (${pendingCount})</span></button></div>` : ''} </div><div class="edit-modal-buttons"><button class="cancel" onclick="closeSubmitOptions()">Cancel</button></div>`; document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show');} function closeSubmitOptions(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} async function submitOnline(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} try{ showLoading(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ await submitData(transactions); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} catch (error){ console.error('Submit Error:', error); showError("Submit Failed", "Failed to submit transactions. Please try again.");} finally{ hideLoading();}} async function saveForLater(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge();} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}} function updatePendingBadge(){ const pendingCount=OfflineStorage.getPendingTransactions().length; const saveButton=document.querySelector('.save-button'); // Remove existing badge const existingBadge=saveButton.querySelector('.pending-badge'); if (existingBadge){ existingBadge.remove();} // Add new badge if there are pending transactions if (pendingCount >0){ const badge=document.createElement('span'); badge.className='pending-badge'; badge.textContent=pendingCount; badge.title=`${pendingCount} transaction${pendingCount >1 ? 's' : ''} saved for later`; saveButton.style.position='relative'; saveButton.appendChild(badge);}} async function initializeApp(){ try{ setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus();}} catch (error){ console.error('Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} function setupTouchNavigation(){ const container=document.querySelector('.container'); let touchStartX=0; let touchEndX=0; container.addEventListener('touchstart', e=>{ touchStartX=e.changedTouches[0].screenX;},{ passive: true}); container.addEventListener('touchend', e=>{ touchEndX=e.changedTouches[0].screenX; handleSwipe();},{ passive: true}); function handleSwipe(){ const SWIPE_THRESHOLD=50; const swipeDistance=touchEndX - touchStartX; if (Math.abs(swipeDistance) >SWIPE_THRESHOLD){ if (swipeDistance >0 && currentTransactionIndex >0){ navigateTransaction(-1);} else if (swipeDistance < 0 && currentTransactionIndex < transactions.length - 1){ navigateTransaction(1);}}}} function validateExpenseData(data){ try{ const required=[ "Date of Transaction", "Where did the money come from?", "How much money? (Tsh)", "What's the Purchase Category", "Purchase Description", "Where was the money payed to?" ]; const missingFields=required.filter(field=>{ const value=data[field]; return value===undefined || value===null || value.toString().trim()==='';}); if (missingFields.length >0){ throw new Error(`Missing required fields: ${missingFields.join(', ')}`);} if (isNaN(parseFloat(data["How much money? (Tsh)"]))){ throw new Error('Invalid amount value');} return true;} catch (error){ console.error('Validation error:', error); showError('Validation Error', error.message); return false;}} function storeTrainingPatterns(patterns){ try{ const serializedPatterns=JSON.stringify(patterns, (key, value)=>{ if (value instanceof Set){ return Array.from(value);} return value;}); localStorage.setItem('expensePatterns', serializedPatterns);} catch (e){ console.error('Error storing patterns:', e); showError('Storage Error', 'Failed to store training patterns');}} function loadTrainingPatterns(){ try{ const stored=localStorage.getItem('expensePatterns'); if (!stored) return null; return JSON.parse(stored, (key, value)=>{ if (key==='keywords' && Array.isArray(value)){ return new Set(value);} return value;});} catch (e){ console.error('Error loading patterns:', e); showError('Loading Error', 'Failed to load training patterns'); return null;}} function setupEventListeners(){ const inputTextArea=utils.getElement(UI.selectors.inputText); if (!inputTextArea) return; const newTextArea=inputTextArea.cloneNode(true); inputTextArea.parentNode.replaceChild(newTextArea, inputTextArea); let debounceTimeout; newTextArea.addEventListener(EVENTS.INPUT, ()=>{ clearTimeout(debounceTimeout); debounceTimeout=setTimeout(()=>window.processInput(), 300);}); newTextArea.addEventListener(EVENTS.KEYDOWN, event=>{ if (event.key==='Enter' && !event.shiftKey){ event.preventDefault(); clearTimeout(debounceTimeout); window.processInput();}}); const saveButton=utils.getElement(UI.selectors.saveButton); if (saveButton){ saveButton.addEventListener('click', event=>{ const pendingCount=OfflineStorage.getPendingTransactions().length; if (event.altKey && pendingCount >0){ window.showPendingTransactions();} else{ window.EventHandlers.handleSave();}});} const submitButton=utils.getElement(UI.selectors.submitButton); if (submitButton){ submitButton.addEventListener('click', ()=>window.EventHandlers.handleSubmit());} window.addEventListener('storage', event=>{ if (event.key===STORAGE_KEYS.PENDING_TRANSACTIONS){ updatePendingBadge();}}); utils.getElement('.container').addEventListener('click', event=>{ const isInteractive=event.target.closest('input, select, button, .editable-field, .compact-field, .edit-modal'); if (!isInteractive){ newTextArea.focus();}}); utils.getElement('.error-close')?.addEventListener('click', window.closeError); utils.getElement(UI.selectors.editOverlay)?.addEventListener('click', window.closeEditModal); // Store functions in window scope Object.assign(window,{ EventHandlers, ModalManager, processInputFunction: processInput, navigateTransactionFunction: navigateTransaction, showPendingTransactions, closePendingTransactions, submitPendingTransaction, removePendingTransaction, submitAllPending, closeSubmitOptions, submitOnline, saveForLater: window.EventHandlers.handleSave.bind(window.EventHandlers)});} const INITIAL_TRAINING_DATA=[ { category: "Groceries & Household", description: "gave maids 10k for home groceries", paidTo: "Gave to Maid (nyumbani)"}, { category: "Groceries & Household", description: "Gave to Maid at Breakfast for home", paidTo: "Gave to Maid (nyumbani)"}, { category: "Groceries & Household", description: "gave Irene for home when left", paidTo: "Gave to Irene"}, { category: "Groceries & Household", description: "gave to home maid for sabuni and other times", paidTo: "Gave to Maid (nyumbani)"}, { category: "Groceries & Household", description: "gave to maide for rice and mkaa", paidTo: "Gave to Maid (nyumbani)"}, { category: "Groceries & Household", description: "gave to maid for milk at home", paidTo: "Gave to Maid (nyumbani)"}, { category: "Groceries & Household", description: "gave money to home for shopping at gulio", paidTo: "Gave to Maid (nyumbani)"}, { category: "Gift to Family & Friends", description: "Gave to Irene to start her saloon", paidTo: "Gave to Irene"}, { category: "Gift to Family & Friends", description: "Gave Irene 100k for faiths sendoff", paidTo: "Gave to Irene"}, // ... add more training data as needed ]; const AI_SYSTEM={ confidenceThreshold: 0.75, learningRate: 0.1, maxPatterns: 2000, patterns: new Map(), historicalData: new Map(), async initialize(){ try{ // Load patterns const storedPatterns=localStorage.getItem('aiPatterns'); if (storedPatterns){ const parsed=JSON.parse(storedPatterns); this.patterns=new Map(Object.entries(parsed).map(([key, value])=>{ // Convert keywords array back to Set if it exists if (value.keywords){ value.keywords=new Set(Array.isArray(value.keywords) ? value.keywords : []);} return [key, value];}));} // Load historical data const storedHistory=localStorage.getItem('historicalTransactions'); if (storedHistory){ this.historicalData=new Map(Object.entries(JSON.parse(storedHistory)));} // Initialize with training data if no patterns exist if (this.patterns.size===0){ this.initializeWithTrainingData();}} catch (error){ console.error('AI System initialization error:', error); this.initializeWithTrainingData();}}, initializeWithTrainingData(){ // Clear existing patterns this.patterns.clear(); this.historicalData.clear(); // Process each training entry INITIAL_TRAINING_DATA.forEach(entry=>{ const key=`${entry.category}:${entry.paidTo}`; const words=entry.description.toLowerCase().split(/\s+/); let pattern=this.patterns.get(key) ||{ category: entry.category, paidTo: entry.paidTo, keywords: new Set(), frequency: 0, confidence: 0.8, // Initial confidence examples: []}; // Add keywords from description words.forEach(word=>{ if (word.length >2){ // Only add words longer than 2 characters pattern.keywords.add(word);}}); // Update pattern pattern.frequency++; pattern.examples.push(entry.description); if (pattern.examples.length >5){ pattern.examples.shift(); // Keep only last 5 examples} this.patterns.set(key, pattern); // Add to historical data const historyKey=entry.description.toLowerCase(); this.historicalData.set(historyKey,{ category: entry.category, paidTo: entry.paidTo, timestamp: Date.now(), frequency: 1});}); // Save the initialized patterns this.savePatterns();}, async savePatterns(){ try{ const serializedPatterns={}; for (const [key, value] of this.patterns.entries()){ serializedPatterns[key]={ ...value, keywords: Array.from(value.keywords)};} localStorage.setItem('aiPatterns', JSON.stringify(serializedPatterns)); const serializedHistory={}; for (const [key, value] of this.historicalData.entries()){ serializedHistory[key]=value;} localStorage.setItem('historicalTransactions', JSON.stringify(serializedHistory));} catch (error){ console.error('Error saving patterns:', error);}}, learnFromHistoricalData(entry){ const key=`${entry.category}:${entry.paidTo}`; const words=entry.description.toLowerCase().split(/\s+/); let pattern=this.patterns.get(key) ||{ category: entry.category, paidTo: entry.paidTo, keywords: new Set(), frequency: 0, confidence: 0.7, examples: []}; // Update keywords words.forEach(word=>{ if (word.length >2){ pattern.keywords.add(word);}}); // Update pattern metrics pattern.frequency++; pattern.examples.push(entry.description); if (pattern.examples.length >5){ pattern.examples.shift();} // Adjust confidence based on frequency pattern.confidence=Math.min(0.95, pattern.confidence + (this.learningRate * (1 - pattern.confidence))); this.patterns.set(key, pattern); // Update historical data const historyKey=entry.description.toLowerCase(); const existingHistory=this.historicalData.get(historyKey) ||{ category: entry.category, paidTo: entry.paidTo, timestamp: Date.now(), frequency: 0}; existingHistory.frequency++; this.historicalData.set(historyKey, existingHistory);}}; function analyzeTextContext(text){ const lowerText=text.toLowerCase(); // Priority check for grocery-related patterns const groceryIndicators=[ "maid", "nyumbani", "home", "groceries", "food", "breakfast", "kitchen", "shopping", "milk", "rice", "mkaa", "sabuni", "gulio" ]; const groceryScore=groceryIndicators.reduce((score, indicator)=>{ return score + (lowerText.includes(indicator) ? 1 : 0);}, 0) / groceryIndicators.length; // If strong grocery indicators are present, boost grocery confidence if (groceryScore >0.3){ return{ category: "Groceries & Household", confidence: Math.round(Math.min((groceryScore + 0.4) * 100, 95)), amount: extractAmount(text), paidTo: determinePaidTo(text, "Groceries & Household")};} // Continue with regular pattern matching let bestCategory=null; let bestPaidTo=null; let highestConfidence=0; // Context modifiers const contextModifiers={ "groceries": ["for home", "for groceries", "for shopping", "for food", "for breakfast", "for kitchen", "nyumbani", "home", "shopping"], "gift": ["gave to", "sent to", "support", "help", "changia", "mchango"]}; // Check for context let contextualScore=0; for (const [context, modifiers] of Object.entries(contextModifiers)){ if (modifiers.some(mod=>lowerText.includes(mod))){ contextualScore=context==="groceries" ? 0.8 : 0.6;}} // Check exact matches with context const exactMatches={ "Groceries & Household":{ keywords: ["grocery", "supermarket", "food", "household", "milk", "water", "uhai", "mkaa", "rice", "mchele", "maziwa", "breakfast", "kitchen", "maid", "nyumbani", "home"], context: ["home", "nyumbani", "shopping", "food", "cook"], priority: 2}, "Gift to Family & Friends":{ keywords: ["gave", "gift", "send to", "sent to", "irene", "family", "friend", "support", "help", "mchango", "changia"], excludeContext: ["groceries", "food", "shopping", "home", "nyumbani", "maid"], priority: 1}, "Petrol & Transport":{ keywords: ["petrol", "fuel", "transport", "fare", "taxi", "uber", "bolt", "baught petrol", "put petrol", "filled", "mafuta"], context: ["car", "vehicle", "drive", "road", "travel"], priority: 1}, "Medical & Medicine":{ keywords: ["medicine", "medical", "doctor", "hospital", "clinic", "pharmacy", "dawa"], priority: 1}, "Utilities & Bills":{ keywords: ["luku", "electricity", "water bill", "internet", "wifi", "gas", "trash", "takataka", "security", "netflix", "dawasa"], context: ["bill", "monthly", "subscription"], priority: 1}, "Eating Out & Entertainment":{ keywords: ["restaurant", "lunch", "dinner", "cafe", "pizza", "kfc", "chips", "mishkaki", "food court", "entertainment"], excludeContext: ["home", "nyumbani"], priority: 1}}; // Calculate match scores for each category for (const [category, patterns] of Object.entries(exactMatches)){ let matchScore=0; // Check keywords patterns.keywords.forEach(keyword=>{ if (lowerText.includes(keyword)){ matchScore +=1;}}); // Check context if (patterns.context){ patterns.context.forEach(ctx=>{ if (lowerText.includes(ctx)){ matchScore +=0.5;}});} // Apply priority multiplier matchScore *=(patterns.priority || 1); // Check exclude context if (patterns.excludeContext && patterns.excludeContext.some(ctx=>lowerText.includes(ctx))){ matchScore *=0.3; // Reduce confidence if exclusion context is found} // Apply contextual score if (category==="Groceries & Household" && contextualScore >0.7){ matchScore *=1.5; // Boost grocery confidence when context suggests it} else if (category==="Gift to Family & Friends" && contextualScore >0.7){ matchScore *=0.5; // Reduce gift confidence when grocery context is strong} if (matchScore >highestConfidence){ highestConfidence=matchScore; bestCategory=category; bestPaidTo=determinePaidTo(text, category);}} // Calculate final confidence score const finalConfidence=Math.round( Math.min( (highestConfidence * 0.6 + contextualScore * 0.4) * 100, 95 ) ); return{ category: bestCategory || "(OTHER) Food, Transport, Groceries, etc.", confidence: finalConfidence || 70, // Default confidence if no strong matches amount: extractAmount(text), paidTo: bestPaidTo || "(OTHER) Food, Transport, Groceries, etc."};} function determinePaidTo(text, category){ const lowerText=text.toLowerCase(); // First check for specific person mentions const personPatterns={ "Gave to Irene": ["irene", "irine"], "Gave to Maid (nyumbani)": ["maid", "dada", "nyumbani maid", "home maid"], "Gave to Benadeta": ["benadeta", "benadetha"], "Gave to Parents - Tina": ["tina", "tinah", "parents"]}; // Check for specific person first, regardless of context for (const [paidTo, patterns] of Object.entries(personPatterns)){ if (patterns.some(pattern=>lowerText.includes(pattern))){ return paidTo;}} // If no specific person found, then use category-based logic if (category==="Groceries & Household" && (lowerText.includes("home") || lowerText.includes("nyumbani"))){ return "Gave to Maid (nyumbani)";} // Default mappings based on category const categoryDefaults={ "Groceries & Household": "(OTHER) Food, Transport, Groceries, etc.", "Gift to Family & Friends": "Gave to Irene", "Petrol & Transport": "Spent on Raum"}; return categoryDefaults[category] || "(OTHER) Food, Transport, Groceries, etc.";} function extractAmount(text){ const amountMatch=text.match(/(\d+)[k\s]*(thousand|k)?/i); let amount=0; if (amountMatch){ amount=parseInt(amountMatch[1]); if (amountMatch[2] || amountMatch[0].toLowerCase().includes('k')){ amount *=1000;}} return amount;} // Initialize AI System with training data document.addEventListener('DOMContentLoaded', ()=>{ AI_SYSTEM.initialize();}); if (document.readyState==='loading'){ document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);} else{ initializeApp();} // Make functions available globally Object.assign(window,{ closeError, closeEditModal, saveEdit, showEditModal, processInput, authorize, confirmSubmit, navigateTransaction, closeConfirmation}); class SpeechRecognitionManager{ constructor(){ this.recognition=null; this.isListening=false;} initialize(){ if ('webkitSpeechRecognition' in window){ this.recognition=new webkitSpeechRecognition(); this.recognition.continuous=false; this.recognition.interimResults=false; this.recognition.lang='en-US'; this.recognition.onresult=(event)=>{ const text=event.results[0][0].transcript; document.getElementById('inputText').value=text; processInput();}; this.recognition.onend=()=>{ this.isListening=false; this.updateButtonState();}; this.recognition.onerror=(event)=>{ console.error('Speech recognition error:', event.error); this.isListening=false; this.updateButtonState(); if (event.error==='not-allowed'){ showError( "Microphone Access Denied", "Please allow microphone access to use voice input." );}}; // Add voice input button this.addVoiceButton();}} addVoiceButton(){ const inputSection=document.querySelector('.input-section'); const existingButton=inputSection.querySelector('.voice-input-button'); if (existingButton){ existingButton.remove();} const voiceButton=document.createElement('button'); voiceButton.className='voice-input-button'; voiceButton.innerHTML='🎤'; voiceButton.onclick=()=>this.toggleRecognition(); inputSection.appendChild(voiceButton);} toggleRecognition(){ if (!this.recognition) return; if (this.isListening){ this.recognition.stop();} else{ try{ this.recognition.start(); this.isListening=true; this.updateButtonState();} catch (error){ console.error('Speech recognition error:', error); this.isListening=false; this.updateButtonState();}}} updateButtonState(){ const button=document.querySelector('.voice-input-button'); if (button){ button.style.background=this.isListening ? '#ff4444' : 'var(--primary-color)'; button.innerHTML=this.isListening ? '⏹' : '🎤';}}} function processInput(){ const inputText=document.getElementById("inputText").value; if (inputText.trim()===""){ document.getElementById("editableContainer").innerHTML=""; transactions=[]; updateTransactionCounter(); return;} const transactionTexts=inputText .split(/&&|(?:Also|also|ALSO)/) .map(text=>text.trim()) .filter(text=>text.length >0); transactions=transactionTexts.map(text=>{ const analysis=analyzeTextContext(text); return{ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text, "Where was the money payed to?": analysis.paidTo, "Confidance level": `${analysis.confidence}%`, editedFields: new Set()};}); currentTransactionIndex=0; updateTransactionCounter(); displayEditableFields(transactions[currentTransactionIndex]);} function saveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}} function updateTransactionCounter(){ const indicator=document.querySelector('.transaction-indicator'); const prevBtn=document.getElementById('prevTransaction'); const nextBtn=document.getElementById('nextTransaction'); if (transactions.length >0){ indicator.textContent=`${currentTransactionIndex + 1} of ${transactions.length}`; prevBtn.disabled=currentTransactionIndex===0; nextBtn.disabled=currentTransactionIndex===transactions.length - 1;} else{ indicator.textContent='No Transactions'; prevBtn.disabled=true; nextBtn.disabled=true;}} function navigateTransaction(direction){ const newIndex=currentTransactionIndex + direction; if (newIndex >=0 && newIndex < transactions.length){ currentTransactionIndex=newIndex; displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();}} function storeEditTrainingData(field, oldValue, newValue, transaction){ try{ const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const key=transaction["Purchase Description"].toLowerCase(); if (!trainingData[key]){ trainingData[key]={ corrections:{}, frequency: 0};} if (!trainingData[key].corrections[field]){ trainingData[key].corrections[field]=[];} trainingData[key].corrections[field].push({ from: oldValue, to: newValue, timestamp: new Date().toISOString()}); trainingData[key].frequency++; localStorage.setItem('editTrainingData', JSON.stringify(trainingData));} catch (e){ console.error('Error storing training data:', e);}} async function authorize(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();} function showConfirmation(){ const confirmation=document.querySelector('.submit-confirmation'); const transactionList=confirmation.querySelector('.transaction-list'); transactionList.innerHTML=transactions.map((transaction, index)=>` <div class="transaction-item"><strong>Transaction ${index + 1}:</strong><br>Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>Category: ${transaction["What's the Purchase Category"]}<br>Paid To: ${transaction["Where was the money payed to?"]}<br>Description: ${transaction["Purchase Description"]} </div>`).join(''); confirmation.classList.add('show');} function closeConfirmation(){ document.querySelector('.submit-confirmation').classList.remove('show');} async function confirmSubmit(){ closeConfirmation(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} async function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); TOKEN_MANAGEMENT.clearStoredToken(); return;} try{ TOKEN_MANAGEMENT.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} async function submitData(token){ showLoading(); try{ if (!transactions || transactions.length===0){ throw new Error('No transactions to submit');} // Submit each transaction for (const transaction of transactions){ if (!validateExpenseData(transaction)){ throw new Error('Invalid expense data');} // Learn from the transaction before submitting AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]});} await AI_SYSTEM.savePatterns(); showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length >1 ? 's' : ''}`); clearForm();} catch (error){ console.error('Submit Error:', error); showError( "Submission Failed", "Failed to submit transactions.", error.message );} finally{ hideLoading();}} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter();} function displayEditableFields(transaction){ if (!transaction){ document.getElementById("editableContainer").innerHTML=""; return;} const container=document.getElementById("editableContainer"); container.innerHTML=""; // Essential fields shown by default const essentialFields=[ { field: "Date of Transaction", fullWidth: false}, { field: "How much money? (Tsh)", fullWidth: false}, { field: "What's the Purchase Category", fullWidth: true}, { field: "Where was the money payed to?", fullWidth: true} ]; // Hidden fields in collapsible section const collapsibleFields=[ { field: "Where did the money come from?", fullWidth: false}, { field: "Purchase Description", fullWidth: true} ]; // Display essential fields essentialFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); container.appendChild(fieldDiv);}); // Add confidence and feedback section const confidenceSection=document.createElement("div"); confidenceSection.className="confidence-section"; confidenceSection.style.cssText=` background: var(--bg-input); border-radius: 8px; padding: 12px; margin: 12px 0; `; // Calculate comprehensive confidence score const confidenceScore=calculateConfidenceScore(transaction); // Add confidence display const confidenceDisplay=document.createElement("div"); confidenceDisplay.className="confidence-display"; confidenceDisplay.style.cssText=` display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; `; const confidenceLabel=document.createElement("span"); confidenceLabel.textContent="AI Confidence:"; confidenceLabel.style.color="var(--text-muted)"; const confidenceValue=document.createElement("span"); confidenceValue.textContent=`${confidenceScore}%`; confidenceValue.style.color=getConfidenceColor(confidenceScore); confidenceValue.style.fontWeight="bold"; confidenceDisplay.appendChild(confidenceLabel); confidenceDisplay.appendChild(confidenceValue); // Add feedback section right below confidence const feedbackDiv=document.createElement("div"); feedbackDiv.className="feedback-section"; feedbackDiv.style.cssText=` display: flex; align-items: center; gap: 10px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--bg-card); `; const feedbackText=document.createElement("span"); feedbackText.textContent="Was this prediction accurate?"; feedbackText.style.cssText=` color: var(--text-muted); font-size: 0.9em; `; const thumbsUp=document.createElement("button"); thumbsUp.innerHTML="👍"; thumbsUp.className="feedback-button"; thumbsUp.title="Yes, this prediction is accurate"; const thumbsDown=document.createElement("button"); thumbsDown.innerHTML="👎"; thumbsDown.className="feedback-button"; thumbsDown.title="No, this prediction needs correction"; thumbsUp.onclick=()=>handleFeedback(transaction, true); thumbsDown.onclick=()=>handleFeedback(transaction, false); feedbackDiv.appendChild(feedbackText); feedbackDiv.appendChild(thumbsUp); feedbackDiv.appendChild(thumbsDown); confidenceSection.appendChild(confidenceDisplay); confidenceSection.appendChild(feedbackDiv); container.appendChild(confidenceSection); // Add collapsible section for additional details const collapsibleTrigger=document.createElement("button"); collapsibleTrigger.className="collapsible-trigger"; collapsibleTrigger.textContent="Show More Details"; container.appendChild(collapsibleTrigger); const collapsibleContent=document.createElement("div"); collapsibleContent.className="collapsible-content"; collapsibleFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); collapsibleContent.appendChild(fieldDiv);}); container.appendChild(collapsibleContent); collapsibleTrigger.onclick=function(){ this.classList.toggle('expanded'); collapsibleContent.classList.toggle('show');};} function calculateConfidenceScore(transaction){ let baseConfidence=0; const description=transaction["Purchase Description"].toLowerCase(); // Check training data matches const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const historicalMatch=trainingData[description]; if (historicalMatch){ // Direct match in training data baseConfidence=90; // Adjust based on frequency baseConfidence +=Math.min(historicalMatch.frequency * 2, 5);} else{ // Calculate based on pattern matching const analysis=analyzeTextContext(description); baseConfidence=parseInt(analysis.confidence); // Check for partial matches in training data const words=description.split(/\s+/); let partialMatches=0; Object.keys(trainingData).forEach(key=>{ const keyWords=key.split(/\s+/); const commonWords=words.filter(word=>keyWords.includes(word)); if (commonWords.length >1){ partialMatches++;}}); // Adjust confidence based on partial matches if (partialMatches >0){ baseConfidence +=Math.min(partialMatches * 3, 10);}} // Adjust based on specific indicators if (description.includes('maid') && description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} if (description.includes('irene') && !description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} // Cap the confidence return Math.min(Math.round(baseConfidence), 95);} function getConfidenceColor(score){ if (score >=90) return '#4CAF50'; if (score >=75) return '#8BC34A'; if (score >=60) return '#FFC107'; return '#FF5722';} function handleFeedback(transaction, isPositive){ if (isPositive){ // Store as positive example in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); showSuccess("Thanks for the feedback! This will help improve future predictions.");} else{ // Show feedback form for correction showFeedbackForm(transaction);}} function showFeedbackForm(transaction){ const modal=document.createElement("div"); modal.className="edit-modal show"; modal.innerHTML=` <h3>What was incorrect?</h3><div class="feedback-form"><div class="feedback-options"><label><input type="checkbox" value="category">Category (${transaction["What's the Purchase Category"]}) </label><label><input type="checkbox" value="paidTo">Paid To (${transaction["Where was the money payed to?"]}) </label></div><div class="correction-fields" style="display: none;"><h4>Please provide the correct values:</h4><div id="correctionInputs"></div></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeFeedbackForm()">Cancel</button><button onclick="submitFeedback()">Submit</button></div>`; // Add styles const style=document.createElement("style"); style.textContent=` .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} `; document.head.appendChild(style); // Show modal document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); // Add event listeners const checkboxes=modal.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox=>{ checkbox.addEventListener('change', ()=>{ const correctionFields=modal.querySelector('.correction-fields'); const correctionInputs=modal.querySelector('#correctionInputs'); if ([...checkboxes].some(cb=>cb.checked)){ correctionFields.style.display='block'; correctionInputs.innerHTML=''; if (checkbox.value==='category' && checkbox.checked){ addCategorySelect(correctionInputs);} if (checkbox.value==='paidTo' && checkbox.checked){ addPaidToSelect(correctionInputs);}} else{ correctionFields.style.display='none';}});});} function addCategorySelect(container){ const select=document.createElement('select'); select.id='correctionCategory'; select.innerHTML=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}">${cat}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.style.marginBottom='10px'; wrapper.innerHTML='<label>Correct Category:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function addPaidToSelect(container){ const paidToOptions=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ]; const select=document.createElement('select'); select.id='correctionPaidTo'; select.innerHTML=paidToOptions.map(opt=>`<option value="${opt}">${opt}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.innerHTML='<label>Correct Paid To:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function closeFeedbackForm(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} function submitFeedback(){ const transaction=transactions[currentTransactionIndex]; const categorySelect=document.getElementById('correctionCategory'); const paidToSelect=document.getElementById('correctionPaidTo'); if (categorySelect){ transaction["What's the Purchase Category"]=categorySelect.value;} if (paidToSelect){ transaction["Where was the money payed to?"]=paidToSelect.value;} // Store correction in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); // Update display displayEditableFields(transaction); closeFeedbackForm(); showSuccess("Thank you for your feedback! This will help improve future predictions.");} function showLoading(){ utils.showElement('.loading-overlay');} function hideLoading(){ utils.hideElement('.loading-overlay');} function showError(title, message, details=''){ ErrorHandler.show(title, message, details);} function closeError(){ ErrorHandler.close();} function showSuccess(message){ SuccessHandler.show(message);} function updateUI(selector, content){ const element=utils.getElement(selector); if (element){ if (typeof content==='string'){ element.innerHTML=content;} else if (content instanceof Node){ element.innerHTML=''; element.appendChild(content);}}} const EventHandlers={ async handleSubmit(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();}, async handleSave(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge();} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}}, handleEdit(field, value){ ModalManager.showEditModal(field, value);}, handleSaveEdit(){ try{ const modal=utils.getElement(UI.selectors.editModal); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} ModalManager.closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}}}; async function initializeApp(){ try{ // Initialize managers and handlers first window.ModalManager=ModalManager; window.EventHandlers=EventHandlers; // Then set up event listeners setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus();} // Remove redundant submit confirmation section const submitConfirmation=utils.getElement('.submit-confirmation'); if (submitConfirmation){ submitConfirmation.remove();}} catch (error){ console.error('Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} if (document.readyState==='loading'){ document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);} else{ initializeApp();} // Make functions available globally Object.assign(window,{ closeError, closeEditModal, saveEdit, showEditModal, processInput, authorize, confirmSubmit, navigateTransaction, closeConfirmation}); class SpeechRecognitionManager{ constructor(){ this.recognition=null; this.isListening=false;} initialize(){ if ('webkitSpeechRecognition' in window){ this.recognition=new webkitSpeechRecognition(); this.recognition.continuous=false; this.recognition.interimResults=false; this.recognition.lang='en-US'; this.recognition.onresult=(event)=>{ const text=event.results[0][0].transcript; document.getElementById('inputText').value=text; processInput();}; this.recognition.onend=()=>{ this.isListening=false; this.updateButtonState();}; this.recognition.onerror=(event)=>{ console.error('Speech recognition error:', event.error); this.isListening=false; this.updateButtonState(); if (event.error==='not-allowed'){ showError( "Microphone Access Denied", "Please allow microphone access to use voice input." );}}; // Add voice input button this.addVoiceButton();}} addVoiceButton(){ const inputSection=document.querySelector('.input-section'); const existingButton=inputSection.querySelector('.voice-input-button'); if (existingButton){ existingButton.remove();} const voiceButton=document.createElement('button'); voiceButton.className='voice-input-button'; voiceButton.innerHTML='🎤'; voiceButton.onclick=()=>this.toggleRecognition(); inputSection.appendChild(voiceButton);} toggleRecognition(){ if (!this.recognition) return; if (this.isListening){ this.recognition.stop();} else{ try{ this.recognition.start(); this.isListening=true; this.updateButtonState();} catch (error){ console.error('Speech recognition error:', error); this.isListening=false; this.updateButtonState();}}} updateButtonState(){ const button=document.querySelector('.voice-input-button'); if (button){ button.style.background=this.isListening ? '#ff4444' : 'var(--primary-color)'; button.innerHTML=this.isListening ? '⏹' : '🎤';}}} function processInput(){ const inputText=document.getElementById("inputText").value; if (inputText.trim()===""){ document.getElementById("editableContainer").innerHTML=""; transactions=[]; updateTransactionCounter(); return;} const transactionTexts=inputText .split(/&&|(?:Also|also|ALSO)/) .map(text=>text.trim()) .filter(text=>text.length >0); transactions=transactionTexts.map(text=>{ const analysis=analyzeTextContext(text); return{ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text, "Where was the money payed to?": analysis.paidTo, "Confidance level": `${analysis.confidence}%`, editedFields: new Set()};}); currentTransactionIndex=0; updateTransactionCounter(); displayEditableFields(transactions[currentTransactionIndex]);} function saveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}} function updateTransactionCounter(){ const indicator=document.querySelector('.transaction-indicator'); const prevBtn=document.getElementById('prevTransaction'); const nextBtn=document.getElementById('nextTransaction'); if (transactions.length >0){ indicator.textContent=`${currentTransactionIndex + 1} of ${transactions.length}`; prevBtn.disabled=currentTransactionIndex===0; nextBtn.disabled=currentTransactionIndex===transactions.length - 1;} else{ indicator.textContent='No Transactions'; prevBtn.disabled=true; nextBtn.disabled=true;}} function navigateTransaction(direction){ const newIndex=currentTransactionIndex + direction; if (newIndex >=0 && newIndex < transactions.length){ currentTransactionIndex=newIndex; displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();}} function storeEditTrainingData(field, oldValue, newValue, transaction){ try{ const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const key=transaction["Purchase Description"].toLowerCase(); if (!trainingData[key]){ trainingData[key]={ corrections:{}, frequency: 0};} if (!trainingData[key].corrections[field]){ trainingData[key].corrections[field]=[];} trainingData[key].corrections[field].push({ from: oldValue, to: newValue, timestamp: new Date().toISOString()}); trainingData[key].frequency++; localStorage.setItem('editTrainingData', JSON.stringify(trainingData));} catch (e){ console.error('Error storing training data:', e);}} async function authorize(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();} function showConfirmation(){ const confirmation=document.querySelector('.submit-confirmation'); const transactionList=confirmation.querySelector('.transaction-list'); transactionList.innerHTML=transactions.map((transaction, index)=>` <div class="transaction-item"><strong>Transaction ${index + 1}:</strong><br>Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>Category: ${transaction["What's the Purchase Category"]}<br>Paid To: ${transaction["Where was the money payed to?"]}<br>Description: ${transaction["Purchase Description"]} </div>`).join(''); confirmation.classList.add('show');} function closeConfirmation(){ document.querySelector('.submit-confirmation').classList.remove('show');} async function confirmSubmit(){ closeConfirmation(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} async function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); TOKEN_MANAGEMENT.clearStoredToken(); return;} try{ TOKEN_MANAGEMENT.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} async function submitData(token){ showLoading(); try{ if (!transactions || transactions.length===0){ throw new Error('No transactions to submit');} // Submit each transaction for (const transaction of transactions){ if (!validateExpenseData(transaction)){ throw new Error('Invalid expense data');} // Learn from the transaction before submitting AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]});} await AI_SYSTEM.savePatterns(); showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length >1 ? 's' : ''}`); clearForm();} catch (error){ console.error('Submit Error:', error); showError( "Submission Failed", "Failed to submit transactions.", error.message );} finally{ hideLoading();}} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter();} function displayEditableFields(transaction){ if (!transaction){ document.getElementById("editableContainer").innerHTML=""; return;} const container=document.getElementById("editableContainer"); container.innerHTML=""; // Essential fields shown by default const essentialFields=[ { field: "Date of Transaction", fullWidth: false}, { field: "How much money? (Tsh)", fullWidth: false}, { field: "What's the Purchase Category", fullWidth: true}, { field: "Where was the money payed to?", fullWidth: true} ]; // Hidden fields in collapsible section const collapsibleFields=[ { field: "Where did the money come from?", fullWidth: false}, { field: "Purchase Description", fullWidth: true} ]; // Display essential fields essentialFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); container.appendChild(fieldDiv);}); // Add confidence and feedback section const confidenceSection=document.createElement("div"); confidenceSection.className="confidence-section"; confidenceSection.style.cssText=` background: var(--bg-input); border-radius: 8px; padding: 12px; margin: 12px 0; `; // Calculate comprehensive confidence score const confidenceScore=calculateConfidenceScore(transaction); // Add confidence display const confidenceDisplay=document.createElement("div"); confidenceDisplay.className="confidence-display"; confidenceDisplay.style.cssText=` display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; `; const confidenceLabel=document.createElement("span"); confidenceLabel.textContent="AI Confidence:"; confidenceLabel.style.color="var(--text-muted)"; const confidenceValue=document.createElement("span"); confidenceValue.textContent=`${confidenceScore}%`; confidenceValue.style.color=getConfidenceColor(confidenceScore); confidenceValue.style.fontWeight="bold"; confidenceDisplay.appendChild(confidenceLabel); confidenceDisplay.appendChild(confidenceValue); // Add feedback section right below confidence const feedbackDiv=document.createElement("div"); feedbackDiv.className="feedback-section"; feedbackDiv.style.cssText=` display: flex; align-items: center; gap: 10px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--bg-card); `; const feedbackText=document.createElement("span"); feedbackText.textContent="Was this prediction accurate?"; feedbackText.style.cssText=` color: var(--text-muted); font-size: 0.9em; `; const thumbsUp=document.createElement("button"); thumbsUp.innerHTML="👍"; thumbsUp.className="feedback-button"; thumbsUp.title="Yes, this prediction is accurate"; const thumbsDown=document.createElement("button"); thumbsDown.innerHTML="👎"; thumbsDown.className="feedback-button"; thumbsDown.title="No, this prediction needs correction"; thumbsUp.onclick=()=>handleFeedback(transaction, true); thumbsDown.onclick=()=>handleFeedback(transaction, false); feedbackDiv.appendChild(feedbackText); feedbackDiv.appendChild(thumbsUp); feedbackDiv.appendChild(thumbsDown); confidenceSection.appendChild(confidenceDisplay); confidenceSection.appendChild(feedbackDiv); container.appendChild(confidenceSection); // Add collapsible section for additional details const collapsibleTrigger=document.createElement("button"); collapsibleTrigger.className="collapsible-trigger"; collapsibleTrigger.textContent="Show More Details"; container.appendChild(collapsibleTrigger); const collapsibleContent=document.createElement("div"); collapsibleContent.className="collapsible-content"; collapsibleFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); collapsibleContent.appendChild(fieldDiv);}); container.appendChild(collapsibleContent); collapsibleTrigger.onclick=function(){ this.classList.toggle('expanded'); collapsibleContent.classList.toggle('show');};} function calculateConfidenceScore(transaction){ let baseConfidence=0; const description=transaction["Purchase Description"].toLowerCase(); // Check training data matches const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const historicalMatch=trainingData[description]; if (historicalMatch){ // Direct match in training data baseConfidence=90; // Adjust based on frequency baseConfidence +=Math.min(historicalMatch.frequency * 2, 5);} else{ // Calculate based on pattern matching const analysis=analyzeTextContext(description); baseConfidence=parseInt(analysis.confidence); // Check for partial matches in training data const words=description.split(/\s+/); let partialMatches=0; Object.keys(trainingData).forEach(key=>{ const keyWords=key.split(/\s+/); const commonWords=words.filter(word=>keyWords.includes(word)); if (commonWords.length >1){ partialMatches++;}}); // Adjust confidence based on partial matches if (partialMatches >0){ baseConfidence +=Math.min(partialMatches * 3, 10);}} // Adjust based on specific indicators if (description.includes('maid') && description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} if (description.includes('irene') && !description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} // Cap the confidence return Math.min(Math.round(baseConfidence), 95);} function getConfidenceColor(score){ if (score >=90) return '#4CAF50'; if (score >=75) return '#8BC34A'; if (score >=60) return '#FFC107'; return '#FF5722';} function handleFeedback(transaction, isPositive){ if (isPositive){ // Store as positive example in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); showSuccess("Thanks for the feedback! This will help improve future predictions.");} else{ // Show feedback form for correction showFeedbackForm(transaction);}} function showFeedbackForm(transaction){ const modal=document.createElement("div"); modal.className="edit-modal show"; modal.innerHTML=` <h3>What was incorrect?</h3><div class="feedback-form"><div class="feedback-options"><label><input type="checkbox" value="category">Category (${transaction["What's the Purchase Category"]}) </label><label><input type="checkbox" value="paidTo">Paid To (${transaction["Where was the money payed to?"]}) </label></div><div class="correction-fields" style="display: none;"><h4>Please provide the correct values:</h4><div id="correctionInputs"></div></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeFeedbackForm()">Cancel</button><button onclick="submitFeedback()">Submit</button></div>`; // Add styles const style=document.createElement("style"); style.textContent=` .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} `; document.head.appendChild(style); // Show modal document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); // Add event listeners const checkboxes=modal.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox=>{ checkbox.addEventListener('change', ()=>{ const correctionFields=modal.querySelector('.correction-fields'); const correctionInputs=modal.querySelector('#correctionInputs'); if ([...checkboxes].some(cb=>cb.checked)){ correctionFields.style.display='block'; correctionInputs.innerHTML=''; if (checkbox.value==='category' && checkbox.checked){ addCategorySelect(correctionInputs);} if (checkbox.value==='paidTo' && checkbox.checked){ addPaidToSelect(correctionInputs);}} else{ correctionFields.style.display='none';}});});} function addCategorySelect(container){ const select=document.createElement('select'); select.id='correctionCategory'; select.innerHTML=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}">${cat}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.style.marginBottom='10px'; wrapper.innerHTML='<label>Correct Category:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function addPaidToSelect(container){ const paidToOptions=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ]; const select=document.createElement('select'); select.id='correctionPaidTo'; select.innerHTML=paidToOptions.map(opt=>`<option value="${opt}">${opt}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.innerHTML='<label>Correct Paid To:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function closeFeedbackForm(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} function submitFeedback(){ const transaction=transactions[currentTransactionIndex]; const categorySelect=document.getElementById('correctionCategory'); const paidToSelect=document.getElementById('correctionPaidTo'); if (categorySelect){ transaction["What's the Purchase Category"]=categorySelect.value;} if (paidToSelect){ transaction["Where was the money payed to?"]=paidToSelect.value;} // Store correction in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); // Update display displayEditableFields(transaction); closeFeedbackForm(); showSuccess("Thank you for your feedback! This will help improve future predictions.");} function showLoading(){ utils.showElement('.loading-overlay');} function hideLoading(){ utils.hideElement('.loading-overlay');} function showError(title, message, details=''){ ErrorHandler.show(title, message, details);} function closeError(){ ErrorHandler.close();} function showSuccess(message){ SuccessHandler.show(message);} function updateUI(selector, content){ const element=utils.getElement(selector); if (element){ if (typeof content==='string'){ element.innerHTML=content;} else if (content instanceof Node){ element.innerHTML=''; element.appendChild(content);}} const EventHandlers={ async handleSubmit(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();}, async handleSave(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge();} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}}, handleEdit(field, value){ ModalManager.showEditModal(field, value);}, handleSaveEdit(){ try{ const modal=utils.getElement(UI.selectors.editModal); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} ModalManager.closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}}}; async function initializeApp(){ try{ // Initialize managers and handlers first window.ModalManager=ModalManager; window.EventHandlers=EventHandlers; // Then set up event listeners setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus();} // Remove redundant submit confirmation section const submitConfirmation=utils.getElement('.submit-confirmation'); if (submitConfirmation){ submitConfirmation.remove();}} catch (error){ console.error('Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} if (document.readyState==='loading'){ document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);} else{ initializeApp();} // Make functions available globally Object.assign(window,{ closeError, closeEditModal, saveEdit, showEditModal, processInput, authorize, confirmSubmit, navigateTransaction, closeConfirmation}); class SpeechRecognitionManager{ constructor(){ this.recognition=null; this.isListening=false;} initialize(){ if ('webkitSpeechRecognition' in window){ this.recognition=new webkitSpeechRecognition(); this.recognition.continuous=false; this.recognition.interimResults=false; this.recognition.lang='en-US'; this.recognition.onresult=(event)=>{ const text=event.results[0][0].transcript; document.getElementById('inputText').value=text; processInput();}; this.recognition.onend=()=>{ this.isListening=false; this.updateButtonState();}; this.recognition.onerror=(event)=>{ console.error('Speech recognition error:', event.error); this.isListening=false; this.updateButtonState(); if (event.error==='not-allowed'){ showError( "Microphone Access Denied", "Please allow microphone access to use voice input." );}}; // Add voice input button this.addVoiceButton();}} addVoiceButton(){ const inputSection=document.querySelector('.input-section'); const existingButton=inputSection.querySelector('.voice-input-button'); if (existingButton){ existingButton.remove();} const voiceButton=document.createElement('button'); voiceButton.className='voice-input-button'; voiceButton.innerHTML='🎤'; voiceButton.onclick=()=>this.toggleRecognition(); inputSection.appendChild(voiceButton);} toggleRecognition(){ if (!this.recognition) return; if (this.isListening){ this.recognition.stop();} else{ try{ this.recognition.start(); this.isListening=true; this.updateButtonState();} catch (error){ console.error('Speech recognition error:', error); this.isListening=false; this.updateButtonState();}} updateButtonState(){ const button=document.querySelector('.voice-input-button'); if (button){ button.style.background=this.isListening ? '#ff4444' : 'var(--primary-color)'; button.innerHTML=this.isListening ? '⏹' : '🎤';}}} function processInput(){ const inputText=document.getElementById("inputText").value; if (inputText.trim()===""){ document.getElementById("editableContainer").innerHTML=""; transactions=[]; updateTransactionCounter(); return;} const transactionTexts=inputText .split(/&&|(?:Also|also|ALSO)/) .map(text=>text.trim()) .filter(text=>text.length >0); transactions=transactionTexts.map(text=>{ const analysis=analyzeTextContext(text); return{ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text, "Where was the money payed to?": analysis.paidTo, "Confidance level": `${analysis.confidence}%`, editedFields: new Set()};}); currentTransactionIndex=0; updateTransactionCounter(); displayEditableFields(transactions[currentTransactionIndex]);} function saveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}} function updateTransactionCounter(){ const indicator=document.querySelector('.transaction-indicator'); const prevBtn=document.getElementById('prevTransaction'); const nextBtn=document.getElementById('nextTransaction'); if (transactions.length >0){ indicator.textContent=`${currentTransactionIndex + 1} of ${transactions.length}`; prevBtn.disabled=currentTransactionIndex===0; nextBtn.disabled=currentTransactionIndex===transactions.length - 1;} else{ indicator.textContent='No Transactions'; prevBtn.disabled=true; nextBtn.disabled=true;}} function navigateTransaction(direction){ const newIndex=currentTransactionIndex + direction; if (newIndex >=0 && newIndex < transactions.length){ currentTransactionIndex=newIndex; displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();}} function storeEditTrainingData(field, oldValue, newValue, transaction){ try{ const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const key=transaction["Purchase Description"].toLowerCase(); if (!trainingData[key]){ trainingData[key]={ corrections:{}, frequency: 0};} if (!trainingData[key].corrections[field]){ trainingData[key].corrections[field]=[];} trainingData[key].corrections[field].push({ from: oldValue, to: newValue, timestamp: new Date().toISOString()}); trainingData[key].frequency++; localStorage.setItem('editTrainingData', JSON.stringify(trainingData));} catch (e){ console.error('Error storing training data:', e);}} async function authorize(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();} function showConfirmation(){ const confirmation=document.querySelector('.submit-confirmation'); const transactionList=confirmation.querySelector('.transaction-list'); transactionList.innerHTML=transactions.map((transaction, index)=>` <div class="transaction-item"><strong>Transaction ${index + 1}:</strong><br>Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>Category: ${transaction["What's the Purchase Category"]}<br>Paid To: ${transaction["Where was the money payed to?"]}<br>Description: ${transaction["Purchase Description"]} </div>`).join(''); confirmation.classList.add('show');} function closeConfirmation(){ document.querySelector('.submit-confirmation').classList.remove('show');} async function confirmSubmit(){ closeConfirmation(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} async function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); TOKEN_MANAGEMENT.clearStoredToken(); return;} try{ TOKEN_MANAGEMENT.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} async function submitData(token){ showLoading(); try{ if (!transactions || transactions.length===0){ throw new Error('No transactions to submit');} // Submit each transaction for (const transaction of transactions){ if (!validateExpenseData(transaction)){ throw new Error('Invalid expense data');} // Learn from the transaction before submitting AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]});} await AI_SYSTEM.savePatterns(); showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length >1 ? 's' : ''}`); clearForm();} catch (error){ console.error('Submit Error:', error); showError( "Submission Failed", "Failed to submit transactions.", error.message );} finally{ hideLoading();}} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter();} function displayEditableFields(transaction){ if (!transaction){ document.getElementById("editableContainer").innerHTML=""; return;} const container=document.getElementById("editableContainer"); container.innerHTML=""; // Essential fields shown by default const essentialFields=[ { field: "Date of Transaction", fullWidth: false}, { field: "How much money? (Tsh)", fullWidth: false}, { field: "What's the Purchase Category", fullWidth: true}, { field: "Where was the money payed to?", fullWidth: true} ]; // Hidden fields in collapsible section const collapsibleFields=[ { field: "Where did the money come from?", fullWidth: false}, { field: "Purchase Description", fullWidth: true} ]; // Display essential fields essentialFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); container.appendChild(fieldDiv);}); // Add confidence and feedback section const confidenceSection=document.createElement("div"); confidenceSection.className="confidence-section"; confidenceSection.style.cssText=` background: var(--bg-input); border-radius: 8px; padding: 12px; margin: 12px 0; `; // Calculate comprehensive confidence score const confidenceScore=calculateConfidenceScore(transaction); // Add confidence display const confidenceDisplay=document.createElement("div"); confidenceDisplay.className="confidence-display"; confidenceDisplay.style.cssText=` display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; `; const confidenceLabel=document.createElement("span"); confidenceLabel.textContent="AI Confidence:"; confidenceLabel.style.color="var(--text-muted)"; const confidenceValue=document.createElement("span"); confidenceValue.textContent=`${confidenceScore}%`; confidenceValue.style.color=getConfidenceColor(confidenceScore); confidenceValue.style.fontWeight="bold"; confidenceDisplay.appendChild(confidenceLabel); confidenceDisplay.appendChild(confidenceValue); // Add feedback section right below confidence const feedbackDiv=document.createElement("div"); feedbackDiv.className="feedback-section"; feedbackDiv.style.cssText=` display: flex; align-items: center; gap: 10px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--bg-card); `; const feedbackText=document.createElement("span"); feedbackText.textContent="Was this prediction accurate?"; feedbackText.style.cssText=` color: var(--text-muted); font-size: 0.9em; `; const thumbsUp=document.createElement("button"); thumbsUp.innerHTML="👍"; thumbsUp.className="feedback-button"; thumbsUp.title="Yes, this prediction is accurate"; const thumbsDown=document.createElement("button"); thumbsDown.innerHTML="👎"; thumbsDown.className="feedback-button"; thumbsDown.title="No, this prediction needs correction"; thumbsUp.onclick=()=>handleFeedback(transaction, true); thumbsDown.onclick=()=>handleFeedback(transaction, false); feedbackDiv.appendChild(feedbackText); feedbackDiv.appendChild(thumbsUp); feedbackDiv.appendChild(thumbsDown); confidenceSection.appendChild(confidenceDisplay); confidenceSection.appendChild(feedbackDiv); container.appendChild(confidenceSection); // Add collapsible section for additional details const collapsibleTrigger=document.createElement("button"); collapsibleTrigger.className="collapsible-trigger"; collapsibleTrigger.textContent="Show More Details"; container.appendChild(collapsibleTrigger); const collapsibleContent=document.createElement("div"); collapsibleContent.className="collapsible-content"; collapsibleFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); collapsibleContent.appendChild(fieldDiv);}); container.appendChild(collapsibleContent); collapsibleTrigger.onclick=function(){ this.classList.toggle('expanded'); collapsibleContent.classList.toggle('show');};} function calculateConfidenceScore(transaction){ let baseConfidence=0; const description=transaction["Purchase Description"].toLowerCase(); // Check training data matches const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const historicalMatch=trainingData[description]; if (historicalMatch){ // Direct match in training data baseConfidence=90; // Adjust based on frequency baseConfidence +=Math.min(historicalMatch.frequency * 2, 5);} else{ // Calculate based on pattern matching const analysis=analyzeTextContext(description); baseConfidence=parseInt(analysis.confidence); // Check for partial matches in training data const words=description.split(/\s+/); let partialMatches=0; Object.keys(trainingData).forEach(key=>{ const keyWords=key.split(/\s+/); const commonWords=words.filter(word=>keyWords.includes(word)); if (commonWords.length >1){ partialMatches++;}}); // Adjust confidence based on partial matches if (partialMatches >0){ baseConfidence +=Math.min(partialMatches * 3, 10);}} // Adjust based on specific indicators if (description.includes('maid') && description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} if (description.includes('irene') && !description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} // Cap the confidence return Math.min(Math.round(baseConfidence), 95);} function getConfidenceColor(score){ if (score >=90) return '#4CAF50'; if (score >=75) return '#8BC34A'; if (score >=60) return '#FFC107'; return '#FF5722';} function handleFeedback(transaction, isPositive){ if (isPositive){ // Store as positive example in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); showSuccess("Thanks for the feedback! This will help improve future predictions.");} else{ // Show feedback form for correction showFeedbackForm(transaction);}} function showFeedbackForm(transaction){ const modal=document.createElement("div"); modal.className="edit-modal show"; modal.innerHTML=` <h3>What was incorrect?</h3><div class="feedback-form"><div class="feedback-options"><label><input type="checkbox" value="category">Category (${transaction["What's the Purchase Category"]}) </label><label><input type="checkbox" value="paidTo">Paid To (${transaction["Where was the money payed to?"]}) </label></div><div class="correction-fields" style="display: none;"><h4>Please provide the correct values:</h4><div id="correctionInputs"></div></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeFeedbackForm()">Cancel</button><button onclick="submitFeedback()">Submit</button></div>`; // Add styles const style=document.createElement("style"); style.textContent=` .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} `; document.head.appendChild(style); // Show modal document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); // Add event listeners const checkboxes=modal.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox=>{ checkbox.addEventListener('change', ()=>{ const correctionFields=modal.querySelector('.correction-fields'); const correctionInputs=modal.querySelector('#correctionInputs'); if ([...checkboxes].some(cb=>cb.checked)){ correctionFields.style.display='block'; correctionInputs.innerHTML=''; if (checkbox.value==='category' && checkbox.checked){ addCategorySelect(correctionInputs);} if (checkbox.value==='paidTo' && checkbox.checked){ addPaidToSelect(correctionInputs);}} else{ correctionFields.style.display='none';}});});} function addCategorySelect(container){ const select=document.createElement('select'); select.id='correctionCategory'; select.innerHTML=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}">${cat}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.style.marginBottom='10px'; wrapper.innerHTML='<label>Correct Category:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function addPaidToSelect(container){ const paidToOptions=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ]; const select=document.createElement('select'); select.id='correctionPaidTo'; select.innerHTML=paidToOptions.map(opt=>`<option value="${opt}">${opt}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.innerHTML='<label>Correct Paid To:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function closeFeedbackForm(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} function submitFeedback(){ const transaction=transactions[currentTransactionIndex]; const categorySelect=document.getElementById('correctionCategory'); const paidToSelect=document.getElementById('correctionPaidTo'); if (categorySelect){ transaction["What's the Purchase Category"]=categorySelect.value;} if (paidToSelect){ transaction["Where was the money payed to?"]=paidToSelect.value;} // Store correction in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); // Update display displayEditableFields(transaction); closeFeedbackForm(); showSuccess("Thank you for your feedback! This will help improve future predictions.");} function showLoading(){ utils.showElement('.loading-overlay');} function hideLoading(){ utils.hideElement('.loading-overlay');} function showError(title, message, details=''){ ErrorHandler.show(title, message, details);} function closeError(){ ErrorHandler.close();} function showSuccess(message){ SuccessHandler.show(message);} function updateUI(selector, content){ const element=utils.getElement(selector); if (element){ if (typeof content==='string'){ element.innerHTML=content;} else if (content instanceof Node){ element.innerHTML=''; element.appendChild(content);}}}} const EventHandlers={ async handleSubmit(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();}, async handleSave(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge();} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}}, handleEdit(field, value){ ModalManager.showEditModal(field, value);}, handleSaveEdit(){ try{ const modal=utils.getElement(UI.selectors.editModal); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} ModalManager.closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}}}; async function initializeApp(){ try{ // Initialize managers and handlers first window.ModalManager=ModalManager; window.EventHandlers=EventHandlers; // Then set up event listeners setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus();} // Remove redundant submit confirmation section const submitConfirmation=utils.getElement('.submit-confirmation'); if (submitConfirmation){ submitConfirmation.remove();}} catch (error){ console.error('Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} if (document.readyState==='loading'){ document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);} else{ initializeApp();} // Make functions available globally Object.assign(window,{ closeError, closeEditModal, saveEdit, showEditModal, processInput, authorize, confirmSubmit, navigateTransaction, closeConfirmation}); class SpeechRecognitionManager{ constructor(){ this.recognition=null; this.isListening=false;} initialize(){ if ('webkitSpeechRecognition' in window){ this.recognition=new webkitSpeechRecognition(); this.recognition.continuous=false; this.recognition.interimResults=false; this.recognition.lang='en-US'; this.recognition.onresult=(event)=>{ const text=event.results[0][0].transcript; document.getElementById('inputText').value=text; processInput();}; this.recognition.onend=()=>{ this.isListening=false; this.updateButtonState();}; this.recognition.onerror=(event)=>{ console.error('Speech recognition error:', event.error); this.isListening=false; this.updateButtonState(); if (event.error==='not-allowed'){ showError( "Microphone Access Denied", "Please allow microphone access to use voice input." );}}; // Add voice input button this.addVoiceButton();}} addVoiceButton(){ const inputSection=document.querySelector('.input-section'); const existingButton=inputSection.querySelector('.voice-input-button'); if (existingButton){ existingButton.remove();} const voiceButton=document.createElement('button'); voiceButton.className='voice-input-button'; voiceButton.innerHTML='🎤'; voiceButton.onclick=()=>this.toggleRecognition(); inputSection.appendChild(voiceButton);} toggleRecognition(){ if (!this.recognition) return; if (this.isListening){ this.recognition.stop();} else{ try{ this.recognition.start(); this.isListening=true; this.updateButtonState();} catch (error){ console.error('Speech recognition error:', error); this.isListening=false; this.updateButtonState();}}} updateButtonState(){ const button=document.querySelector('.voice-input-button'); if (button){ button.style.background=this.isListening ? '#ff4444' : 'var(--primary-color)'; button.innerHTML=this.isListening ? '⏹' : '🎤';}}} function processInput(){ const inputText=document.getElementById("inputText").value; if (inputText.trim()===""){ document.getElementById("editableContainer").innerHTML=""; transactions=[]; updateTransactionCounter(); return;} const transactionTexts=inputText .split(/&&|(?:Also|also|ALSO)/) .map(text=>text.trim()) .filter(text=>text.length >0); transactions=transactionTexts.map(text=>{ const analysis=analyzeTextContext(text); return{ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text, "Where was the money payed to?": analysis.paidTo, "Confidance level": `${analysis.confidence}%`, editedFields: new Set()};}); currentTransactionIndex=0; updateTransactionCounter(); displayEditableFields(transactions[currentTransactionIndex]);} function saveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}} function updateTransactionCounter(){ const indicator=document.querySelector('.transaction-indicator'); const prevBtn=document.getElementById('prevTransaction'); const nextBtn=document.getElementById('nextTransaction'); if (transactions.length >0){ indicator.textContent=`${currentTransactionIndex + 1} of ${transactions.length}`; prevBtn.disabled=currentTransactionIndex===0; nextBtn.disabled=currentTransactionIndex===transactions.length - 1;} else{ indicator.textContent='No Transactions'; prevBtn.disabled=true; nextBtn.disabled=true;}} function navigateTransaction(direction){ const newIndex=currentTransactionIndex + direction; if (newIndex >=0 && newIndex < transactions.length){ currentTransactionIndex=newIndex; displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();}} function storeEditTrainingData(field, oldValue, newValue, transaction){ try{ const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const key=transaction["Purchase Description"].toLowerCase(); if (!trainingData[key]){ trainingData[key]={ corrections:{}, frequency: 0};} if (!trainingData[key].corrections[field]){ trainingData[key].corrections[field]=[];} trainingData[key].corrections[field].push({ from: oldValue, to: newValue, timestamp: new Date().toISOString()}); trainingData[key].frequency++; localStorage.setItem('editTrainingData', JSON.stringify(trainingData));} catch (e){ console.error('Error storing training data:', e);}} async function authorize(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();} function showConfirmation(){ const confirmation=document.querySelector('.submit-confirmation'); const transactionList=confirmation.querySelector('.transaction-list'); transactionList.innerHTML=transactions.map((transaction, index)=>` <div class="transaction-item"><strong>Transaction ${index + 1}:</strong><br>Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>Category: ${transaction["What's the Purchase Category"]}<br>Paid To: ${transaction["Where was the money payed to?"]}<br>Description: ${transaction["Purchase Description"]} </div>`).join(''); confirmation.classList.add('show');} function closeConfirmation(){ document.querySelector('.submit-confirmation').classList.remove('show');} async function confirmSubmit(){ closeConfirmation(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} async function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); TOKEN_MANAGEMENT.clearStoredToken(); return;} try{ TOKEN_MANAGEMENT.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} async function submitData(token){ showLoading(); try{ if (!transactions || transactions.length===0){ throw new Error('No transactions to submit');} // Submit each transaction for (const transaction of transactions){ if (!validateExpenseData(transaction)){ throw new Error('Invalid expense data');} // Learn from the transaction before submitting AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]});} await AI_SYSTEM.savePatterns(); showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length >1 ? 's' : ''}`); clearForm();} catch (error){ console.error('Submit Error:', error); showError( "Submission Failed", "Failed to submit transactions.", error.message );} finally{ hideLoading();}} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter();} function displayEditableFields(transaction){ if (!transaction){ document.getElementById("editableContainer").innerHTML=""; return;} const container=document.getElementById("editableContainer"); container.innerHTML=""; // Essential fields shown by default const essentialFields=[ { field: "Date of Transaction", fullWidth: false}, { field: "How much money? (Tsh)", fullWidth: false}, { field: "What's the Purchase Category", fullWidth: true}, { field: "Where was the money payed to?", fullWidth: true} ]; // Hidden fields in collapsible section const collapsibleFields=[ { field: "Where did the money come from?", fullWidth: false}, { field: "Purchase Description", fullWidth: true} ]; // Display essential fields essentialFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); container.appendChild(fieldDiv);}); // Add confidence and feedback section const confidenceSection=document.createElement("div"); confidenceSection.className="confidence-section"; confidenceSection.style.cssText=` background: var(--bg-input); border-radius: 8px; padding: 12px; margin: 12px 0; `; // Calculate comprehensive confidence score const confidenceScore=calculateConfidenceScore(transaction); // Add confidence display const confidenceDisplay=document.createElement("div"); confidenceDisplay.className="confidence-display"; confidenceDisplay.style.cssText=` display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; `; const confidenceLabel=document.createElement("span"); confidenceLabel.textContent="AI Confidence:"; confidenceLabel.style.color="var(--text-muted)"; const confidenceValue=document.createElement("span"); confidenceValue.textContent=`${confidenceScore}%`; confidenceValue.style.color=getConfidenceColor(confidenceScore); confidenceValue.style.fontWeight="bold"; confidenceDisplay.appendChild(confidenceLabel); confidenceDisplay.appendChild(confidenceValue); // Add feedback section right below confidence const feedbackDiv=document.createElement("div"); feedbackDiv.className="feedback-section"; feedbackDiv.style.cssText=` display: flex; align-items: center; gap: 10px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--bg-card); `; const feedbackText=document.createElement("span"); feedbackText.textContent="Was this prediction accurate?"; feedbackText.style.cssText=` color: var(--text-muted); font-size: 0.9em; `; const thumbsUp=document.createElement("button"); thumbsUp.innerHTML="👍"; thumbsUp.className="feedback-button"; thumbsUp.title="Yes, this prediction is accurate"; const thumbsDown=document.createElement("button"); thumbsDown.innerHTML="👎"; thumbsDown.className="feedback-button"; thumbsDown.title="No, this prediction needs correction"; thumbsUp.onclick=()=>handleFeedback(transaction, true); thumbsDown.onclick=()=>handleFeedback(transaction, false); feedbackDiv.appendChild(feedbackText); feedbackDiv.appendChild(thumbsUp); feedbackDiv.appendChild(thumbsDown); confidenceSection.appendChild(confidenceDisplay); confidenceSection.appendChild(feedbackDiv); container.appendChild(confidenceSection); // Add collapsible section for additional details const collapsibleTrigger=document.createElement("button"); collapsibleTrigger.className="collapsible-trigger"; collapsibleTrigger.textContent="Show More Details"; container.appendChild(collapsibleTrigger); const collapsibleContent=document.createElement("div"); collapsibleContent.className="collapsible-content"; collapsibleFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); collapsibleContent.appendChild(fieldDiv);}); container.appendChild(collapsibleContent); collapsibleTrigger.onclick=function(){ this.classList.toggle('expanded'); collapsibleContent.classList.toggle('show');};} function calculateConfidenceScore(transaction){ let baseConfidence=0; const description=transaction["Purchase Description"].toLowerCase(); // Check training data matches const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const historicalMatch=trainingData[description]; if (historicalMatch){ // Direct match in training data baseConfidence=90; // Adjust based on frequency baseConfidence +=Math.min(historicalMatch.frequency * 2, 5);} else{ // Calculate based on pattern matching const analysis=analyzeTextContext(description); baseConfidence=parseInt(analysis.confidence); // Check for partial matches in training data const words=description.split(/\s+/); let partialMatches=0; Object.keys(trainingData).forEach(key=>{ const keyWords=key.split(/\s+/); const commonWords=words.filter(word=>keyWords.includes(word)); if (commonWords.length >1){ partialMatches++;}}); // Adjust confidence based on partial matches if (partialMatches >0){ baseConfidence +=Math.min(partialMatches * 3, 10);}} // Adjust based on specific indicators if (description.includes('maid') && description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} if (description.includes('irene') && !description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} // Cap the confidence return Math.min(Math.round(baseConfidence), 95);} function getConfidenceColor(score){ if (score >=90) return '#4CAF50'; if (score >=75) return '#8BC34A'; if (score >=60) return '#FFC107'; return '#FF5722';} function handleFeedback(transaction, isPositive){ if (isPositive){ // Store as positive example in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); showSuccess("Thanks for the feedback! This will help improve future predictions.");} else{ // Show feedback form for correction showFeedbackForm(transaction);}} function showFeedbackForm(transaction){ const modal=document.createElement("div"); modal.className="edit-modal show"; modal.innerHTML=` <h3>What was incorrect?</h3><div class="feedback-form"><div class="feedback-options"><label><input type="checkbox" value="category">Category (${transaction["What's the Purchase Category"]}) </label><label><input type="checkbox" value="paidTo">Paid To (${transaction["Where was the money payed to?"]}) </label></div><div class="correction-fields" style="display: none;"><h4>Please provide the correct values:</h4><div id="correctionInputs"></div></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeFeedbackForm()">Cancel</button><button onclick="submitFeedback()">Submit</button></div>`; // Add styles const style=document.createElement("style"); style.textContent=` .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} `; document.head.appendChild(style); // Show modal document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); // Add event listeners const checkboxes=modal.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox=>{ checkbox.addEventListener('change', ()=>{ const correctionFields=modal.querySelector('.correction-fields'); const correctionInputs=modal.querySelector('#correctionInputs'); if ([...checkboxes].some(cb=>cb.checked)){ correctionFields.style.display='block'; correctionInputs.innerHTML=''; if (checkbox.value==='category' && checkbox.checked){ addCategorySelect(correctionInputs);} if (checkbox.value==='paidTo' && checkbox.checked){ addPaidToSelect(correctionInputs);}} else{ correctionFields.style.display='none';}});});} function addCategorySelect(container){ const select=document.createElement('select'); select.id='correctionCategory'; select.innerHTML=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}">${cat}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.style.marginBottom='10px'; wrapper.innerHTML='<label>Correct Category:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function addPaidToSelect(container){ const paidToOptions=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ]; const select=document.createElement('select'); select.id='correctionPaidTo'; select.innerHTML=paidToOptions.map(opt=>`<option value="${opt}">${opt}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.innerHTML='<label>Correct Paid To:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function closeFeedbackForm(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} function submitFeedback(){ const transaction=transactions[currentTransactionIndex]; const categorySelect=document.getElementById('correctionCategory'); const paidToSelect=document.getElementById('correctionPaidTo'); if (categorySelect){ transaction["What's the Purchase Category"]=categorySelect.value;} if (paidToSelect){ transaction["Where was the money payed to?"]=paidToSelect.value;} // Store correction in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); // Update display displayEditableFields(transaction); closeFeedbackForm(); showSuccess("Thank you for your feedback! This will help improve future predictions.");} function showLoading(){ utils.showElement('.loading-overlay');} function hideLoading(){ utils.hideElement('.loading-overlay');} function showError(title, message, details=''){ ErrorHandler.show(title, message, details);} function closeError(){ ErrorHandler.close();} function showSuccess(message){ SuccessHandler.show(message);} function updateUI(selector, content){ const element=utils.getElement(selector); if (element){ if (typeof content==='string'){ element.innerHTML=content;} else if (content instanceof Node){ element.innerHTML=''; element.appendChild(content);}}} const EventHandlers={ async handleSubmit(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();}, async handleSave(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge();} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}}, handleEdit(field, value){ ModalManager.showEditModal(field, value);}, handleSaveEdit(){ try{ const modal=utils.getElement(UI.selectors.editModal); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} ModalManager.closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}}}; async function initializeApp(){ try{ // Initialize managers and handlers first window.ModalManager=ModalManager; window.EventHandlers=EventHandlers; // Then set up event listeners setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus();} // Remove redundant submit confirmation section const submitConfirmation=utils.getElement('.submit-confirmation'); if (submitConfirmation){ submitConfirmation.remove();}} catch (error){ console.error('Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} if (document.readyState==='loading'){ document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);} else{ initializeApp();} // Make functions available globally Object.assign(window,{ closeError, closeEditModal, saveEdit, showEditModal, processInput, authorize, confirmSubmit, navigateTransaction, closeConfirmation}); class SpeechRecognitionManager{ constructor(){ this.recognition=null; this.isListening=false;} initialize(){ if ('webkitSpeechRecognition' in window){ this.recognition=new webkitSpeechRecognition(); this.recognition.continuous=false; this.recognition.interimResults=false; this.recognition.lang='en-US'; this.recognition.onresult=(event)=>{ const text=event.results[0][0].transcript; document.getElementById('inputText').value=text; processInput();}; this.recognition.onend=()=>{ this.isListening=false; this.updateButtonState();}; this.recognition.onerror=(event)=>{ console.error('Speech recognition error:', event.error); this.isListening=false; this.updateButtonState(); if (event.error==='not-allowed'){ showError( "Microphone Access Denied", "Please allow microphone access to use voice input." );}}; // Add voice input button this.addVoiceButton();}} addVoiceButton(){ const inputSection=document.querySelector('.input-section'); const existingButton=inputSection.querySelector('.voice-input-button'); if (existingButton){ existingButton.remove();} const voiceButton=document.createElement('button'); voiceButton.className='voice-input-button'; voiceButton.innerHTML='🎤'; voiceButton.onclick=()=>this.toggleRecognition(); inputSection.appendChild(voiceButton);} toggleRecognition(){ if (!this.recognition) return; if (this.isListening){ this.recognition.stop();} else{ try{ this.recognition.start(); this.isListening=true; this.updateButtonState();} catch (error){ console.error('Speech recognition error:', error); this.isListening=false; this.updateButtonState();}}} updateButtonState(){ const button=document.querySelector('.voice-input-button'); if (button){ button.style.background=this.isListening ? '#ff4444' : 'var(--primary-color)'; button.innerHTML=this.isListening ? '⏹' : '🎤';}}} function processInput(){ const inputText=document.getElementById("inputText").value; if (inputText.trim()===""){ document.getElementById("editableContainer").innerHTML=""; transactions=[]; updateTransactionCounter(); return;} const transactionTexts=inputText .split(/&&|(?:Also|also|ALSO)/) .map(text=>text.trim()) .filter(text=>text.length >0); transactions=transactionTexts.map(text=>{ const analysis=analyzeTextContext(text); return{ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text, "Where was the money payed to?": analysis.paidTo, "Confidance level": `${analysis.confidence}%`, editedFields: new Set()};}); currentTransactionIndex=0; updateTransactionCounter(); displayEditableFields(transactions[currentTransactionIndex]);} function saveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}} function updateTransactionCounter(){ const indicator=document.querySelector('.transaction-indicator'); const prevBtn=document.getElementById('prevTransaction'); const nextBtn=document.getElementById('nextTransaction'); if (transactions.length >0){ indicator.textContent=`${currentTransactionIndex + 1} of ${transactions.length}`; prevBtn.disabled=currentTransactionIndex===0; nextBtn.disabled=currentTransactionIndex===transactions.length - 1;} else{ indicator.textContent='No Transactions'; prevBtn.disabled=true; nextBtn.disabled=true;}} function navigateTransaction(direction){ const newIndex=currentTransactionIndex + direction; if (newIndex >=0 && newIndex < transactions.length){ currentTransactionIndex=newIndex; displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();}} function storeEditTrainingData(field, oldValue, newValue, transaction){ try{ const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const key=transaction["Purchase Description"].toLowerCase(); if (!trainingData[key]){ trainingData[key]={ corrections:{}, frequency: 0};} if (!trainingData[key].corrections[field]){ trainingData[key].corrections[field]=[];} trainingData[key].corrections[field].push({ from: oldValue, to: newValue, timestamp: new Date().toISOString()}); trainingData[key].frequency++; localStorage.setItem('editTrainingData', JSON.stringify(trainingData));} catch (e){ console.error('Error storing training data:', e);}} async function authorize(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();} function showConfirmation(){ const confirmation=document.querySelector('.submit-confirmation'); const transactionList=confirmation.querySelector('.transaction-list'); transactionList.innerHTML=transactions.map((transaction, index)=>` <div class="transaction-item"><strong>Transaction ${index + 1}:</strong><br>Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>Category: ${transaction["What's the Purchase Category"]}<br>Paid To: ${transaction["Where was the money payed to?"]}<br>Description: ${transaction["Purchase Description"]} </div>`).join(''); confirmation.classList.add('show');} function closeConfirmation(){ document.querySelector('.submit-confirmation').classList.remove('show');} async function confirmSubmit(){ closeConfirmation(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} async function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); TOKEN_MANAGEMENT.clearStoredToken(); return;} try{ TOKEN_MANAGEMENT.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} async function submitData(token){ showLoading(); try{ if (!transactions || transactions.length===0){ throw new Error('No transactions to submit');} // Submit each transaction for (const transaction of transactions){ if (!validateExpenseData(transaction)){ throw new Error('Invalid expense data');} // Learn from the transaction before submitting AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]});} await AI_SYSTEM.savePatterns(); showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length >1 ? 's' : ''}`); clearForm();} catch (error){ console.error('Submit Error:', error); showError( "Submission Failed", "Failed to submit transactions.", error.message );} finally{ hideLoading();}} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter();} function displayEditableFields(transaction){ if (!transaction){ document.getElementById("editableContainer").innerHTML=""; return;} const container=document.getElementById("editableContainer"); container.innerHTML=""; // Essential fields shown by default const essentialFields=[ { field: "Date of Transaction", fullWidth: false}, { field: "How much money? (Tsh)", fullWidth: false}, { field: "What's the Purchase Category", fullWidth: true}, { field: "Where was the money payed to?", fullWidth: true} ]; // Hidden fields in collapsible section const collapsibleFields=[ { field: "Where did the money come from?", fullWidth: false}, { field: "Purchase Description", fullWidth: true} ]; // Display essential fields essentialFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); container.appendChild(fieldDiv);}); // Add confidence and feedback section const confidenceSection=document.createElement("div"); confidenceSection.className="confidence-section"; confidenceSection.style.cssText=` background: var(--bg-input); border-radius: 8px; padding: 12px; margin: 12px 0; `; // Calculate comprehensive confidence score const confidenceScore=calculateConfidenceScore(transaction); // Add confidence display const confidenceDisplay=document.createElement("div"); confidenceDisplay.className="confidence-display"; confidenceDisplay.style.cssText=` display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; `; const confidenceLabel=document.createElement("span"); confidenceLabel.textContent="AI Confidence:"; confidenceLabel.style.color="var(--text-muted)"; const confidenceValue=document.createElement("span"); confidenceValue.textContent=`${confidenceScore}%`; confidenceValue.style.color=getConfidenceColor(confidenceScore); confidenceValue.style.fontWeight="bold"; confidenceDisplay.appendChild(confidenceLabel); confidenceDisplay.appendChild(confidenceValue); // Add feedback section right below confidence const feedbackDiv=document.createElement("div"); feedbackDiv.className="feedback-section"; feedbackDiv.style.cssText=` display: flex; align-items: center; gap: 10px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--bg-card); `; const feedbackText=document.createElement("span"); feedbackText.textContent="Was this prediction accurate?"; feedbackText.style.cssText=` color: var(--text-muted); font-size: 0.9em; `; const thumbsUp=document.createElement("button"); thumbsUp.innerHTML="👍"; thumbsUp.className="feedback-button"; thumbsUp.title="Yes, this prediction is accurate"; const thumbsDown=document.createElement("button"); thumbsDown.innerHTML="👎"; thumbsDown.className="feedback-button"; thumbsDown.title="No, this prediction needs correction"; thumbsUp.onclick=()=>handleFeedback(transaction, true); thumbsDown.onclick=()=>handleFeedback(transaction, false); feedbackDiv.appendChild(feedbackText); feedbackDiv.appendChild(thumbsUp); feedbackDiv.appendChild(thumbsDown); confidenceSection.appendChild(confidenceDisplay); confidenceSection.appendChild(feedbackDiv); container.appendChild(confidenceSection); // Add collapsible section for additional details const collapsibleTrigger=document.createElement("button"); collapsibleTrigger.className="collapsible-trigger"; collapsibleTrigger.textContent="Show More Details"; container.appendChild(collapsibleTrigger); const collapsibleContent=document.createElement("div"); collapsibleContent.className="collapsible-content"; collapsibleFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); collapsibleContent.appendChild(fieldDiv);}); container.appendChild(collapsibleContent); collapsibleTrigger.onclick=function(){ this.classList.toggle('expanded'); collapsibleContent.classList.toggle('show');};} function calculateConfidenceScore(transaction){ let baseConfidence=0; const description=transaction["Purchase Description"].toLowerCase(); // Check training data matches const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const historicalMatch=trainingData[description]; if (historicalMatch){ // Direct match in training data baseConfidence=90; // Adjust based on frequency baseConfidence +=Math.min(historicalMatch.frequency * 2, 5);} else{ // Calculate based on pattern matching const analysis=analyzeTextContext(description); baseConfidence=parseInt(analysis.confidence); // Check for partial matches in training data const words=description.split(/\s+/); let partialMatches=0; Object.keys(trainingData).forEach(key=>{ const keyWords=key.split(/\s+/); const commonWords=words.filter(word=>keyWords.includes(word)); if (commonWords.length >1){ partialMatches++;}}); // Adjust confidence based on partial matches if (partialMatches >0){ baseConfidence +=Math.min(partialMatches * 3, 10);}} // Adjust based on specific indicators if (description.includes('maid') && description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} if (description.includes('irene') && !description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} // Cap the confidence return Math.min(Math.round(baseConfidence), 95);} function getConfidenceColor(score){ if (score >=90) return '#4CAF50'; if (score >=75) return '#8BC34A'; if (score >=60) return '#FFC107'; return '#FF5722';} function handleFeedback(transaction, isPositive){ if (isPositive){ // Store as positive example in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); showSuccess("Thanks for the feedback! This will help improve future predictions.");} else{ // Show feedback form for correction showFeedbackForm(transaction);}} function showFeedbackForm(transaction){ const modal=document.createElement("div"); modal.className="edit-modal show"; modal.innerHTML=` <h3>What was incorrect?</h3><div class="feedback-form"><div class="feedback-options"><label><input type="checkbox" value="category">Category (${transaction["What's the Purchase Category"]}) </label><label><input type="checkbox" value="paidTo">Paid To (${transaction["Where was the money payed to?"]}) </label></div><div class="correction-fields" style="display: none;"><h4>Please provide the correct values:</h4><div id="correctionInputs"></div></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeFeedbackForm()">Cancel</button><button onclick="submitFeedback()">Submit</button></div>`; // Add styles const style=document.createElement("style"); style.textContent=` .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} `; document.head.appendChild(style); // Show modal document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); // Add event listeners const checkboxes=modal.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox=>{ checkbox.addEventListener('change', ()=>{ const correctionFields=modal.querySelector('.correction-fields'); const correctionInputs=modal.querySelector('#correctionInputs'); if ([...checkboxes].some(cb=>cb.checked)){ correctionFields.style.display='block'; correctionInputs.innerHTML=''; if (checkbox.value==='category' && checkbox.checked){ addCategorySelect(correctionInputs);} if (checkbox.value==='paidTo' && checkbox.checked){ addPaidToSelect(correctionInputs);}} else{ correctionFields.style.display='none';}});});} function addCategorySelect(container){ const select=document.createElement('select'); select.id='correctionCategory'; select.innerHTML=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}">${cat}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.style.marginBottom='10px'; wrapper.innerHTML='<label>Correct Category:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function addPaidToSelect(container){ const paidToOptions=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ]; const select=document.createElement('select'); select.id='correctionPaidTo'; select.innerHTML=paidToOptions.map(opt=>`<option value="${opt}">${opt}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.innerHTML='<label>Correct Paid To:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function closeFeedbackForm(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} function submitFeedback(){ const transaction=transactions[currentTransactionIndex]; const categorySelect=document.getElementById('correctionCategory'); const paidToSelect=document.getElementById('correctionPaidTo'); if (categorySelect){ transaction["What's the Purchase Category"]=categorySelect.value;} if (paidToSelect){ transaction["Where was the money payed to?"]=paidToSelect.value;} // Store correction in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); // Update display displayEditableFields(transaction); closeFeedbackForm(); showSuccess("Thank you for your feedback! This will help improve future predictions.");} function showLoading(){ utils.showElement('.loading-overlay');} function hideLoading(){ utils.hideElement('.loading-overlay');} function showError(title, message, details=''){ ErrorHandler.show(title, message, details);} function closeError(){ ErrorHandler.close();} function showSuccess(message){ SuccessHandler.show(message);} function updateUI(selector, content){ const element=utils.getElement(selector); if (element){ if (typeof content==='string'){ element.innerHTML=content;} else if (content instanceof Node){ element.innerHTML=''; element.appendChild(content);}}} const EventHandlers={ async handleSubmit(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();}, async handleSave(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge();} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}}, handleEdit(field, value){ ModalManager.showEditModal(field, value);}, handleSaveEdit(){ try{ const modal=utils.getElement(UI.selectors.editModal); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} ModalManager.closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}}}; async function initializeApp(){ try{ // Initialize managers and handlers first window.ModalManager=ModalManager; window.EventHandlers=EventHandlers; // Then set up event listeners setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus();} // Remove redundant submit confirmation section const submitConfirmation=utils.getElement('.submit-confirmation'); if (submitConfirmation){ submitConfirmation.remove();}} catch (error){ console.error('Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} if (document.readyState==='loading'){ document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);} else{ initializeApp();} // Make functions available globally Object.assign(window,{ closeError, closeEditModal, saveEdit, showEditModal, processInput, authorize, confirmSubmit, navigateTransaction, closeConfirmation}); class SpeechRecognitionManager{ constructor(){ this.recognition=null; this.isListening=false;} initialize(){ if ('webkitSpeechRecognition' in window){ this.recognition=new webkitSpeechRecognition(); this.recognition.continuous=false; this.recognition.interimResults=false; this.recognition.lang='en-US'; this.recognition.onresult=(event)=>{ const text=event.results[0][0].transcript; document.getElementById('inputText').value=text; processInput();}; this.recognition.onend=()=>{ this.isListening=false; this.updateButtonState();}; this.recognition.onerror=(event)=>{ console.error('Speech recognition error:', event.error); this.isListening=false; this.updateButtonState(); if (event.error==='not-allowed'){ showError( "Microphone Access Denied", "Please allow microphone access to use voice input." );}}; // Add voice input button this.addVoiceButton();}} addVoiceButton(){ const inputSection=document.querySelector('.input-section'); const existingButton=inputSection.querySelector('.voice-input-button'); if (existingButton){ existingButton.remove();} const voiceButton=document.createElement('button'); voiceButton.className='voice-input-button'; voiceButton.innerHTML='🎤'; voiceButton.onclick=()=>this.toggleRecognition(); inputSection.appendChild(voiceButton);} toggleRecognition(){ if (!this.recognition) return; if (this.isListening){ this.recognition.stop();} else{ try{ this.recognition.start(); this.isListening=true; this.updateButtonState();} catch (error){ console.error('Speech recognition error:', error); this.isListening=false; this.updateButtonState();}}} updateButtonState(){ const button=document.querySelector('.voice-input-button'); if (button){ button.style.background=this.isListening ? '#ff4444' : 'var(--primary-color)'; button.innerHTML=this.isListening ? '⏹' : '🎤';}}} function processInput(){ const inputText=document.getElementById("inputText").value; if (inputText.trim()===""){ document.getElementById("editableContainer").innerHTML=""; transactions=[]; updateTransactionCounter(); return;} const transactionTexts=inputText .split(/&&|(?:Also|also|ALSO)/) .map(text=>text.trim()) .filter(text=>text.length >0); transactions=transactionTexts.map(text=>{ const analysis=analyzeTextContext(text); return{ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text, "Where was the money payed to?": analysis.paidTo, "Confidance level": `${analysis.confidence}%`, editedFields: new Set()};}); currentTransactionIndex=0; updateTransactionCounter(); displayEditableFields(transactions[currentTransactionIndex]);} function saveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}} function updateTransactionCounter(){ const indicator=document.querySelector('.transaction-indicator'); const prevBtn=document.getElementById('prevTransaction'); const nextBtn=document.getElementById('nextTransaction'); if (transactions.length >0){ indicator.textContent=`${currentTransactionIndex + 1} of ${transactions.length}`; prevBtn.disabled=currentTransactionIndex===0; nextBtn.disabled=currentTransactionIndex===transactions.length - 1;} else{ indicator.textContent='No Transactions'; prevBtn.disabled=true; nextBtn.disabled=true;}} function navigateTransaction(direction){ const newIndex=currentTransactionIndex + direction; if (newIndex >=0 && newIndex < transactions.length){ currentTransactionIndex=newIndex; displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();}} function storeEditTrainingData(field, oldValue, newValue, transaction){ try{ const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const key=transaction["Purchase Description"].toLowerCase(); if (!trainingData[key]){ trainingData[key]={ corrections:{}, frequency: 0};} if (!trainingData[key].corrections[field]){ trainingData[key].corrections[field]=[];} trainingData[key].corrections[field].push({ from: oldValue, to: newValue, timestamp: new Date().toISOString()}); trainingData[key].frequency++; localStorage.setItem('editTrainingData', JSON.stringify(trainingData));} catch (e){ console.error('Error storing training data:', e);}} async function authorize(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();} function showConfirmation(){ const confirmation=document.querySelector('.submit-confirmation'); const transactionList=confirmation.querySelector('.transaction-list'); transactionList.innerHTML=transactions.map((transaction, index)=>` <div class="transaction-item"><strong>Transaction ${index + 1}:</strong><br>Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>Category: ${transaction["What's the Purchase Category"]}<br>Paid To: ${transaction["Where was the money payed to?"]}<br>Description: ${transaction["Purchase Description"]} </div>`).join(''); confirmation.classList.add('show');} function closeConfirmation(){ document.querySelector('.submit-confirmation').classList.remove('show');} async function confirmSubmit(){ closeConfirmation(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} async function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); TOKEN_MANAGEMENT.clearStoredToken(); return;} try{ TOKEN_MANAGEMENT.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} async function submitData(token){ showLoading(); try{ if (!transactions || transactions.length===0){ throw new Error('No transactions to submit');} // Submit each transaction for (const transaction of transactions){ if (!validateExpenseData(transaction)){ throw new Error('Invalid expense data');} // Learn from the transaction before submitting AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]});} await AI_SYSTEM.savePatterns(); showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length >1 ? 's' : ''}`); clearForm();} catch (error){ console.error('Submit Error:', error); showError( "Submission Failed", "Failed to submit transactions.", error.message );} finally{ hideLoading();}} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter();} function displayEditableFields(transaction){ if (!transaction){ document.getElementById("editableContainer").innerHTML=""; return;} const container=document.getElementById("editableContainer"); container.innerHTML=""; // Essential fields shown by default const essentialFields=[ { field: "Date of Transaction", fullWidth: false}, { field: "How much money? (Tsh)", fullWidth: false}, { field: "What's the Purchase Category", fullWidth: true}, { field: "Where was the money payed to?", fullWidth: true} ]; // Hidden fields in collapsible section const collapsibleFields=[ { field: "Where did the money come from?", fullWidth: false}, { field: "Purchase Description", fullWidth: true} ]; // Display essential fields essentialFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); container.appendChild(fieldDiv);}); // Add confidence and feedback section const confidenceSection=document.createElement("div"); confidenceSection.className="confidence-section"; confidenceSection.style.cssText=` background: var(--bg-input); border-radius: 8px; padding: 12px; margin: 12px 0; `; // Calculate comprehensive confidence score const confidenceScore=calculateConfidenceScore(transaction); // Add confidence display const confidenceDisplay=document.createElement("div"); confidenceDisplay.className="confidence-display"; confidenceDisplay.style.cssText=` display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; `; const confidenceLabel=document.createElement("span"); confidenceLabel.textContent="AI Confidence:"; confidenceLabel.style.color="var(--text-muted)"; const confidenceValue=document.createElement("span"); confidenceValue.textContent=`${confidenceScore}%`; confidenceValue.style.color=getConfidenceColor(confidenceScore); confidenceValue.style.fontWeight="bold"; confidenceDisplay.appendChild(confidenceLabel); confidenceDisplay.appendChild(confidenceValue); // Add feedback section right below confidence const feedbackDiv=document.createElement("div"); feedbackDiv.className="feedback-section"; feedbackDiv.style.cssText=` display: flex; align-items: center; gap: 10px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--bg-card); `; const feedbackText=document.createElement("span"); feedbackText.textContent="Was this prediction accurate?"; feedbackText.style.cssText=` color: var(--text-muted); font-size: 0.9em; `; const thumbsUp=document.createElement("button"); thumbsUp.innerHTML="👍"; thumbsUp.className="feedback-button"; thumbsUp.title="Yes, this prediction is accurate"; const thumbsDown=document.createElement("button"); thumbsDown.innerHTML="👎"; thumbsDown.className="feedback-button"; thumbsDown.title="No, this prediction needs correction"; thumbsUp.onclick=()=>handleFeedback(transaction, true); thumbsDown.onclick=()=>handleFeedback(transaction, false); feedbackDiv.appendChild(feedbackText); feedbackDiv.appendChild(thumbsUp); feedbackDiv.appendChild(thumbsDown); confidenceSection.appendChild(confidenceDisplay); confidenceSection.appendChild(feedbackDiv); container.appendChild(confidenceSection); // Add collapsible section for additional details const collapsibleTrigger=document.createElement("button"); collapsibleTrigger.className="collapsible-trigger"; collapsibleTrigger.textContent="Show More Details"; container.appendChild(collapsibleTrigger); const collapsibleContent=document.createElement("div"); collapsibleContent.className="collapsible-content"; collapsibleFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); collapsibleContent.appendChild(fieldDiv);}); container.appendChild(collapsibleContent); collapsibleTrigger.onclick=function(){ this.classList.toggle('expanded'); collapsibleContent.classList.toggle('show');};} function calculateConfidenceScore(transaction){ let baseConfidence=0; const description=transaction["Purchase Description"].toLowerCase(); // Check training data matches const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const historicalMatch=trainingData[description]; if (historicalMatch){ // Direct match in training data baseConfidence=90; // Adjust based on frequency baseConfidence +=Math.min(historicalMatch.frequency * 2, 5);} else{ // Calculate based on pattern matching const analysis=analyzeTextContext(description); baseConfidence=parseInt(analysis.confidence); // Check for partial matches in training data const words=description.split(/\s+/); let partialMatches=0; Object.keys(trainingData).forEach(key=>{ const keyWords=key.split(/\s+/); const commonWords=words.filter(word=>keyWords.includes(word)); if (commonWords.length >1){ partialMatches++;}}); // Adjust confidence based on partial matches if (partialMatches >0){ baseConfidence +=Math.min(partialMatches * 3, 10);}} // Adjust based on specific indicators if (description.includes('maid') && description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} if (description.includes('irene') && !description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} // Cap the confidence return Math.min(Math.round(baseConfidence), 95);} function getConfidenceColor(score){ if (score >=90) return '#4CAF50'; if (score >=75) return '#8BC34A'; if (score >=60) return '#FFC107'; return '#FF5722';} function handleFeedback(transaction, isPositive){ if (isPositive){ // Store as positive example in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); showSuccess("Thanks for the feedback! This will help improve future predictions.");} else{ // Show feedback form for correction showFeedbackForm(transaction);}} function showFeedbackForm(transaction){ const modal=document.createElement("div"); modal.className="edit-modal show"; modal.innerHTML=` <h3>What was incorrect?</h3><div class="feedback-form"><div class="feedback-options"><label><input type="checkbox" value="category">Category (${transaction["What's the Purchase Category"]}) </label><label><input type="checkbox" value="paidTo">Paid To (${transaction["Where was the money payed to?"]}) </label></div><div class="correction-fields" style="display: none;"><h4>Please provide the correct values:</h4><div id="correctionInputs"></div></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeFeedbackForm()">Cancel</button><button onclick="submitFeedback()">Submit</button></div>`; // Add styles const style=document.createElement("style"); style.textContent=` .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} `; document.head.appendChild(style); // Show modal document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); // Add event listeners const checkboxes=modal.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox=>{ checkbox.addEventListener('change', ()=>{ const correctionFields=modal.querySelector('.correction-fields'); const correctionInputs=modal.querySelector('#correctionInputs'); if ([...checkboxes].some(cb=>cb.checked)){ correctionFields.style.display='block'; correctionInputs.innerHTML=''; if (checkbox.value==='category' && checkbox.checked){ addCategorySelect(correctionInputs);} if (checkbox.value==='paidTo' && checkbox.checked){ addPaidToSelect(correctionInputs);}} else{ correctionFields.style.display='none';}});});} function addCategorySelect(container){ const select=document.createElement('select'); select.id='correctionCategory'; select.innerHTML=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}">${cat}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.style.marginBottom='10px'; wrapper.innerHTML='<label>Correct Category:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function addPaidToSelect(container){ const paidToOptions=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ]; const select=document.createElement('select'); select.id='correctionPaidTo'; select.innerHTML=paidToOptions.map(opt=>`<option value="${opt}">${opt}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.innerHTML='<label>Correct Paid To:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function closeFeedbackForm(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} function submitFeedback(){ const transaction=transactions[currentTransactionIndex]; const categorySelect=document.getElementById('correctionCategory'); const paidToSelect=document.getElementById('correctionPaidTo'); if (categorySelect){ transaction["What's the Purchase Category"]=categorySelect.value;} if (paidToSelect){ transaction["Where was the money payed to?"]=paidToSelect.value;} // Store correction in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); // Update display displayEditableFields(transaction); closeFeedbackForm(); showSuccess("Thank you for your feedback! This will help improve future predictions.");} function showLoading(){ utils.showElement('.loading-overlay');} function hideLoading(){ utils.hideElement('.loading-overlay');} function showError(title, message, details=''){ ErrorHandler.show(title, message, details);} function closeError(){ ErrorHandler.close();} function showSuccess(message){ SuccessHandler.show(message);} function updateUI(selector, content){ const element=utils.getElement(selector); if (element){ if (typeof content==='string'){ element.innerHTML=content;} else if (content instanceof Node){ element.innerHTML=''; element.appendChild(content);}}} const EventHandlers={ async handleSubmit(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();}, async handleSave(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge();} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}}, handleEdit(field, value){ ModalManager.showEditModal(field, value);}, handleSaveEdit(){ try{ const modal=utils.getElement(UI.selectors.editModal); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} ModalManager.closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}}}; async function initializeApp(){ try{ // Initialize managers and handlers first window.ModalManager=ModalManager; window.EventHandlers=EventHandlers; // Then set up event listeners setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus();} // Remove redundant submit confirmation section const submitConfirmation=utils.getElement('.submit-confirmation'); if (submitConfirmation){ submitConfirmation.remove();}} catch (error){ console.error('Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} if (document.readyState==='loading'){ document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);} else{ initializeApp();} // Make functions available globally Object.assign(window,{ closeError, closeEditModal, saveEdit, showEditModal, processInput, authorize, confirmSubmit, navigateTransaction, closeConfirmation}); class SpeechRecognitionManager{ constructor(){ this.recognition=null; this.isListening=false;} initialize(){ if ('webkitSpeechRecognition' in window){ this.recognition=new webkitSpeechRecognition(); this.recognition.continuous=false; this.recognition.interimResults=false; this.recognition.lang='en-US'; this.recognition.onresult=(event)=>{ const text=event.results[0][0].transcript; document.getElementById('inputText').value=text; processInput();}; this.recognition.onend=()=>{ this.isListening=false; this.updateButtonState();}; this.recognition.onerror=(event)=>{ console.error('Speech recognition error:', event.error); this.isListening=false; this.updateButtonState(); if (event.error==='not-allowed'){ showError( "Microphone Access Denied", "Please allow microphone access to use voice input." );}}; // Add voice input button this.addVoiceButton();}} addVoiceButton(){ const inputSection=document.querySelector('.input-section'); const existingButton=inputSection.querySelector('.voice-input-button'); if (existingButton){ existingButton.remove();} const voiceButton=document.createElement('button'); voiceButton.className='voice-input-button'; voiceButton.innerHTML='🎤'; voiceButton.onclick=()=>this.toggleRecognition(); inputSection.appendChild(voiceButton);} toggleRecognition(){ if (!this.recognition) return; if (this.isListening){ this.recognition.stop();} else{ try{ this.recognition.start(); this.isListening=true; this.updateButtonState();} catch (error){ console.error('Speech recognition error:', error); this.isListening=false; this.updateButtonState();}}} updateButtonState(){ const button=document.querySelector('.voice-input-button'); if (button){ button.style.background=this.isListening ? '#ff4444' : 'var(--primary-color)'; button.innerHTML=this.isListening ? '⏹' : '🎤';}}} function processInput(){ const inputText=document.getElementById("inputText").value; if (inputText.trim()===""){ document.getElementById("editableContainer").innerHTML=""; transactions=[]; updateTransactionCounter(); return;} const transactionTexts=inputText .split(/&&|(?:Also|also|ALSO)/) .map(text=>text.trim()) .filter(text=>text.length >0); transactions=transactionTexts.map(text=>{ const analysis=analyzeTextContext(text); return{ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text, "Where was the money payed to?": analysis.paidTo, "Confidance level": `${analysis.confidence}%`, editedFields: new Set()};}); currentTransactionIndex=0; updateTransactionCounter(); displayEditableFields(transactions[currentTransactionIndex]);} function saveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}} function updateTransactionCounter(){ const indicator=document.querySelector('.transaction-indicator'); const prevBtn=document.getElementById('prevTransaction'); const nextBtn=document.getElementById('nextTransaction'); if (transactions.length >0){ indicator.textContent=`${currentTransactionIndex + 1} of ${transactions.length}`; prevBtn.disabled=currentTransactionIndex===0; nextBtn.disabled=currentTransactionIndex===transactions.length - 1;} else{ indicator.textContent='No Transactions'; prevBtn.disabled=true; nextBtn.disabled=true;}} function navigateTransaction(direction){ const newIndex=currentTransactionIndex + direction; if (newIndex >=0 && newIndex < transactions.length){ currentTransactionIndex=newIndex; displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();}} function storeEditTrainingData(field, oldValue, newValue, transaction){ try{ const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const key=transaction["Purchase Description"].toLowerCase(); if (!trainingData[key]){ trainingData[key]={ corrections:{}, frequency: 0};} if (!trainingData[key].corrections[field]){ trainingData[key].corrections[field]=[];} trainingData[key].corrections[field].push({ from: oldValue, to: newValue, timestamp: new Date().toISOString()}); trainingData[key].frequency++; localStorage.setItem('editTrainingData', JSON.stringify(trainingData));} catch (e){ console.error('Error storing training data:', e);}} async function authorize(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();} function showConfirmation(){ const confirmation=document.querySelector('.submit-confirmation'); const transactionList=confirmation.querySelector('.transaction-list'); transactionList.innerHTML=transactions.map((transaction, index)=>` <div class="transaction-item"><strong>Transaction ${index + 1}:</strong><br>Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>Category: ${transaction["What's the Purchase Category"]}<br>Paid To: ${transaction["Where was the money payed to?"]}<br>Description: ${transaction["Purchase Description"]} </div>`).join(''); confirmation.classList.add('show');} function closeConfirmation(){ document.querySelector('.submit-confirmation').classList.remove('show');} async function confirmSubmit(){ closeConfirmation(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} async function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); TOKEN_MANAGEMENT.clearStoredToken(); return;} try{ TOKEN_MANAGEMENT.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} async function submitData(token){ showLoading(); try{ if (!transactions || transactions.length===0){ throw new Error('No transactions to submit');} // Submit each transaction for (const transaction of transactions){ if (!validateExpenseData(transaction)){ throw new Error('Invalid expense data');} // Learn from the transaction before submitting AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]});} await AI_SYSTEM.savePatterns(); showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length >1 ? 's' : ''}`); clearForm();} catch (error){ console.error('Submit Error:', error); showError( "Submission Failed", "Failed to submit transactions.", error.message );} finally{ hideLoading();}} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter();} function displayEditableFields(transaction){ if (!transaction){ document.getElementById("editableContainer").innerHTML=""; return;} const container=document.getElementById("editableContainer"); container.innerHTML=""; // Essential fields shown by default const essentialFields=[ { field: "Date of Transaction", fullWidth: false}, { field: "How much money? (Tsh)", fullWidth: false}, { field: "What's the Purchase Category", fullWidth: true}, { field: "Where was the money payed to?", fullWidth: true} ]; // Hidden fields in collapsible section const collapsibleFields=[ { field: "Where did the money come from?", fullWidth: false}, { field: "Purchase Description", fullWidth: true} ]; // Display essential fields essentialFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); container.appendChild(fieldDiv);}); // Add confidence and feedback section const confidenceSection=document.createElement("div"); confidenceSection.className="confidence-section"; confidenceSection.style.cssText=` background: var(--bg-input); border-radius: 8px; padding: 12px; margin: 12px 0; `; // Calculate comprehensive confidence score const confidenceScore=calculateConfidenceScore(transaction); // Add confidence display const confidenceDisplay=document.createElement("div"); confidenceDisplay.className="confidence-display"; confidenceDisplay.style.cssText=` display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; `; const confidenceLabel=document.createElement("span"); confidenceLabel.textContent="AI Confidence:"; confidenceLabel.style.color="var(--text-muted)"; const confidenceValue=document.createElement("span"); confidenceValue.textContent=`${confidenceScore}%`; confidenceValue.style.color=getConfidenceColor(confidenceScore); confidenceValue.style.fontWeight="bold"; confidenceDisplay.appendChild(confidenceLabel); confidenceDisplay.appendChild(confidenceValue); // Add feedback section right below confidence const feedbackDiv=document.createElement("div"); feedbackDiv.className="feedback-section"; feedbackDiv.style.cssText=` display: flex; align-items: center; gap: 10px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--bg-card); `; const feedbackText=document.createElement("span"); feedbackText.textContent="Was this prediction accurate?"; feedbackText.style.cssText=` color: var(--text-muted); font-size: 0.9em; `; const thumbsUp=document.createElement("button"); thumbsUp.innerHTML="👍"; thumbsUp.className="feedback-button"; thumbsUp.title="Yes, this prediction is accurate"; const thumbsDown=document.createElement("button"); thumbsDown.innerHTML="👎"; thumbsDown.className="feedback-button"; thumbsDown.title="No, this prediction needs correction"; thumbsUp.onclick=()=>handleFeedback(transaction, true); thumbsDown.onclick=()=>handleFeedback(transaction, false); feedbackDiv.appendChild(feedbackText); feedbackDiv.appendChild(thumbsUp); feedbackDiv.appendChild(thumbsDown); confidenceSection.appendChild(confidenceDisplay); confidenceSection.appendChild(feedbackDiv); container.appendChild(confidenceSection); // Add collapsible section for additional details const collapsibleTrigger=document.createElement("button"); collapsibleTrigger.className="collapsible-trigger"; collapsibleTrigger.textContent="Show More Details"; container.appendChild(collapsibleTrigger); const collapsibleContent=document.createElement("div"); collapsibleContent.className="collapsible-content"; collapsibleFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); collapsibleContent.appendChild(fieldDiv);}); container.appendChild(collapsibleContent); collapsibleTrigger.onclick=function(){ this.classList.toggle('expanded'); collapsibleContent.classList.toggle('show');};} function calculateConfidenceScore(transaction){ let baseConfidence=0; const description=transaction["Purchase Description"].toLowerCase(); // Check training data matches const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const historicalMatch=trainingData[description]; if (historicalMatch){ // Direct match in training data baseConfidence=90; // Adjust based on frequency baseConfidence +=Math.min(historicalMatch.frequency * 2, 5);} else{ // Calculate based on pattern matching const analysis=analyzeTextContext(description); baseConfidence=parseInt(analysis.confidence); // Check for partial matches in training data const words=description.split(/\s+/); let partialMatches=0; Object.keys(trainingData).forEach(key=>{ const keyWords=key.split(/\s+/); const commonWords=words.filter(word=>keyWords.includes(word)); if (commonWords.length >1){ partialMatches++;}}); // Adjust confidence based on partial matches if (partialMatches >0){ baseConfidence +=Math.min(partialMatches * 3, 10);}} // Adjust based on specific indicators if (description.includes('maid') && description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} if (description.includes('irene') && !description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} // Cap the confidence return Math.min(Math.round(baseConfidence), 95);} function getConfidenceColor(score){ if (score >=90) return '#4CAF50'; if (score >=75) return '#8BC34A'; if (score >=60) return '#FFC107'; return '#FF5722';} function handleFeedback(transaction, isPositive){ if (isPositive){ // Store as positive example in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); showSuccess("Thanks for the feedback! This will help improve future predictions.");} else{ // Show feedback form for correction showFeedbackForm(transaction);}} function showFeedbackForm(transaction){ const modal=document.createElement("div"); modal.className="edit-modal show"; modal.innerHTML=` <h3>What was incorrect?</h3><div class="feedback-form"><div class="feedback-options"><label><input type="checkbox" value="category">Category (${transaction["What's the Purchase Category"]}) </label><label><input type="checkbox" value="paidTo">Paid To (${transaction["Where was the money payed to?"]}) </label></div><div class="correction-fields" style="display: none;"><h4>Please provide the correct values:</h4><div id="correctionInputs"></div></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeFeedbackForm()">Cancel</button><button onclick="submitFeedback()">Submit</button></div>`; // Add styles const style=document.createElement("style"); style.textContent=` .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} `; document.head.appendChild(style); // Show modal document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); // Add event listeners const checkboxes=modal.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox=>{ checkbox.addEventListener('change', ()=>{ const correctionFields=modal.querySelector('.correction-fields'); const correctionInputs=modal.querySelector('#correctionInputs'); if ([...checkboxes].some(cb=>cb.checked)){ correctionFields.style.display='block'; correctionInputs.innerHTML=''; if (checkbox.value==='category' && checkbox.checked){ addCategorySelect(correctionInputs);} if (checkbox.value==='paidTo' && checkbox.checked){ addPaidToSelect(correctionInputs);}} else{ correctionFields.style.display='none';}});});} function addCategorySelect(container){ const select=document.createElement('select'); select.id='correctionCategory'; select.innerHTML=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}">${cat}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.style.marginBottom='10px'; wrapper.innerHTML='<label>Correct Category:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function addPaidToSelect(container){ const paidToOptions=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ]; const select=document.createElement('select'); select.id='correctionPaidTo'; select.innerHTML=paidToOptions.map(opt=>`<option value="${opt}">${opt}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.innerHTML='<label>Correct Paid To:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function closeFeedbackForm(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} function submitFeedback(){ const transaction=transactions[currentTransactionIndex]; const categorySelect=document.getElementById('correctionCategory'); const paidToSelect=document.getElementById('correctionPaidTo'); if (categorySelect){ transaction["What's the Purchase Category"]=categorySelect.value;} if (paidToSelect){ transaction["Where was the money payed to?"]=paidToSelect.value;} // Store correction in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); // Update display displayEditableFields(transaction); closeFeedbackForm(); showSuccess("Thank you for your feedback! This will help improve future predictions.");} function showLoading(){ utils.showElement('.loading-overlay');} function hideLoading(){ utils.hideElement('.loading-overlay');} function showError(title, message, details=''){ ErrorHandler.show(title, message, details);} function closeError(){ ErrorHandler.close();} function showSuccess(message){ SuccessHandler.show(message);} function updateUI(selector, content){ const element=utils.getElement(selector); if (element){ if (typeof content==='string'){ element.innerHTML=content;} else if (content instanceof Node){ element.innerHTML=''; element.appendChild(content);}}} const EventHandlers={ async handleSubmit(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();}, async handleSave(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge();} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}}, handleEdit(field, value){ ModalManager.showEditModal(field, value);}, handleSaveEdit(){ try{ const modal=utils.getElement(UI.selectors.editModal); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} ModalManager.closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}}}; async function initializeApp(){ try{ // Initialize managers and handlers first window.ModalManager=ModalManager; window.EventHandlers=EventHandlers; // Then set up event listeners setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus();} // Remove redundant submit confirmation section const submitConfirmation=utils.getElement('.submit-confirmation'); if (submitConfirmation){ submitConfirmation.remove();}} catch (error){ console.error('Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} if (document.readyState==='loading'){ document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);} else{ initializeApp();} // Make functions available globally Object.assign(window,{ closeError, closeEditModal, saveEdit, showEditModal, processInput, authorize, confirmSubmit, navigateTransaction, closeConfirmation}); class SpeechRecognitionManager{ constructor(){ this.recognition=null; this.isListening=false;} initialize(){ if ('webkitSpeechRecognition' in window){ this.recognition=new webkitSpeechRecognition(); this.recognition.continuous=false; this.recognition.interimResults=false; this.recognition.lang='en-US'; this.recognition.onresult=(event)=>{ const text=event.results[0][0].transcript; document.getElementById('inputText').value=text; processInput();}; this.recognition.onend=()=>{ this.isListening=false; this.updateButtonState();}; this.recognition.onerror=(event)=>{ console.error('Speech recognition error:', event.error); this.isListening=false; this.updateButtonState(); if (event.error==='not-allowed'){ showError( "Microphone Access Denied", "Please allow microphone access to use voice input." );}}; // Add voice input button this.addVoiceButton();}} addVoiceButton(){ const inputSection=document.querySelector('.input-section'); const existingButton=inputSection.querySelector('.voice-input-button'); if (existingButton){ existingButton.remove();} const voiceButton=document.createElement('button'); voiceButton.className='voice-input-button'; voiceButton.innerHTML='🎤'; voiceButton.onclick=()=>this.toggleRecognition(); inputSection.appendChild(voiceButton);} toggleRecognition(){ if (!this.recognition) return; if (this.isListening){ this.recognition.stop();} else{ try{ this.recognition.start(); this.isListening=true; this.updateButtonState();} catch (error){ console.error('Speech recognition error:', error); this.isListening=false; this.updateButtonState();}}} updateButtonState(){ const button=document.querySelector('.voice-input-button'); if (button){ button.style.background=this.isListening ? '#ff4444' : 'var(--primary-color)'; button.innerHTML=this.isListening ? '⏹' : '🎤';}}} function processInput(){ const inputText=document.getElementById("inputText").value; if (inputText.trim()===""){ document.getElementById("editableContainer").innerHTML=""; transactions=[]; updateTransactionCounter(); return;} const transactionTexts=inputText .split(/&&|(?:Also|also|ALSO)/) .map(text=>text.trim()) .filter(text=>text.length >0); transactions=transactionTexts.map(text=>{ const analysis=analyzeTextContext(text); return{ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text, "Where was the money payed to?": analysis.paidTo, "Confidance level": `${analysis.confidence}%`, editedFields: new Set()};}); currentTransactionIndex=0; updateTransactionCounter(); displayEditableFields(transactions[currentTransactionIndex]);} function saveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}} function updateTransactionCounter(){ const indicator=document.querySelector('.transaction-indicator'); const prevBtn=document.getElementById('prevTransaction'); const nextBtn=document.getElementById('nextTransaction'); if (transactions.length >0){ indicator.textContent=`${currentTransactionIndex + 1} of ${transactions.length}`; prevBtn.disabled=currentTransactionIndex===0; nextBtn.disabled=currentTransactionIndex===transactions.length - 1;} else{ indicator.textContent='No Transactions'; prevBtn.disabled=true; nextBtn.disabled=true;}} function navigateTransaction(direction){ const newIndex=currentTransactionIndex + direction; if (newIndex >=0 && newIndex < transactions.length){ currentTransactionIndex=newIndex; displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();}} function storeEditTrainingData(field, oldValue, newValue, transaction){ try{ const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const key=transaction["Purchase Description"].toLowerCase(); if (!trainingData[key]){ trainingData[key]={ corrections:{}, frequency: 0};} if (!trainingData[key].corrections[field]){ trainingData[key].corrections[field]=[];} trainingData[key].corrections[field].push({ from: oldValue, to: newValue, timestamp: new Date().toISOString()}); trainingData[key].frequency++; localStorage.setItem('editTrainingData', JSON.stringify(trainingData));} catch (e){ console.error('Error storing training data:', e);}} async function authorize(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();} function showConfirmation(){ const confirmation=document.querySelector('.submit-confirmation'); const transactionList=confirmation.querySelector('.transaction-list'); transactionList.innerHTML=transactions.map((transaction, index)=>` <div class="transaction-item"><strong>Transaction ${index + 1}:</strong><br>Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>Category: ${transaction["What's the Purchase Category"]}<br>Paid To: ${transaction["Where was the money payed to?"]}<br>Description: ${transaction["Purchase Description"]} </div>`).join(''); confirmation.classList.add('show');} function closeConfirmation(){ document.querySelector('.submit-confirmation').classList.remove('show');} async function confirmSubmit(){ closeConfirmation(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} async function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); TOKEN_MANAGEMENT.clearStoredToken(); return;} try{ TOKEN_MANAGEMENT.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} async function submitData(token){ showLoading(); try{ if (!transactions || transactions.length===0){ throw new Error('No transactions to submit');} // Submit each transaction for (const transaction of transactions){ if (!validateExpenseData(transaction)){ throw new Error('Invalid expense data');} // Learn from the transaction before submitting AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]});} await AI_SYSTEM.savePatterns(); showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length >1 ? 's' : ''}`); clearForm();} catch (error){ console.error('Submit Error:', error); showError( "Submission Failed", "Failed to submit transactions.", error.message );} finally{ hideLoading();}} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter();} function displayEditableFields(transaction){ if (!transaction){ document.getElementById("editableContainer").innerHTML=""; return;} const container=document.getElementById("editableContainer"); container.innerHTML=""; // Essential fields shown by default const essentialFields=[ { field: "Date of Transaction", fullWidth: false}, { field: "How much money? (Tsh)", fullWidth: false}, { field: "What's the Purchase Category", fullWidth: true}, { field: "Where was the money payed to?", fullWidth: true} ]; // Hidden fields in collapsible section const collapsibleFields=[ { field: "Where did the money come from?", fullWidth: false}, { field: "Purchase Description", fullWidth: true} ]; // Display essential fields essentialFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); container.appendChild(fieldDiv);}); // Add confidence and feedback section const confidenceSection=document.createElement("div"); confidenceSection.className="confidence-section"; confidenceSection.style.cssText=` background: var(--bg-input); border-radius: 8px; padding: 12px; margin: 12px 0; `; // Calculate comprehensive confidence score const confidenceScore=calculateConfidenceScore(transaction); // Add confidence display const confidenceDisplay=document.createElement("div"); confidenceDisplay.className="confidence-display"; confidenceDisplay.style.cssText=` display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; `; const confidenceLabel=document.createElement("span"); confidenceLabel.textContent="AI Confidence:"; confidenceLabel.style.color="var(--text-muted)"; const confidenceValue=document.createElement("span"); confidenceValue.textContent=`${confidenceScore}%`; confidenceValue.style.color=getConfidenceColor(confidenceScore); confidenceValue.style.fontWeight="bold"; confidenceDisplay.appendChild(confidenceLabel); confidenceDisplay.appendChild(confidenceValue); // Add feedback section right below confidence const feedbackDiv=document.createElement("div"); feedbackDiv.className="feedback-section"; feedbackDiv.style.cssText=` display: flex; align-items: center; gap: 10px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--bg-card); `; const feedbackText=document.createElement("span"); feedbackText.textContent="Was this prediction accurate?"; feedbackText.style.cssText=` color: var(--text-muted); font-size: 0.9em; `; const thumbsUp=document.createElement("button"); thumbsUp.innerHTML="👍"; thumbsUp.className="feedback-button"; thumbsUp.title="Yes, this prediction is accurate"; const thumbsDown=document.createElement("button"); thumbsDown.innerHTML="👎"; thumbsDown.className="feedback-button"; thumbsDown.title="No, this prediction needs correction"; thumbsUp.onclick=()=>handleFeedback(transaction, true); thumbsDown.onclick=()=>handleFeedback(transaction, false); feedbackDiv.appendChild(feedbackText); feedbackDiv.appendChild(thumbsUp); feedbackDiv.appendChild(thumbsDown); confidenceSection.appendChild(confidenceDisplay); confidenceSection.appendChild(feedbackDiv); container.appendChild(confidenceSection); // Add collapsible section for additional details const collapsibleTrigger=document.createElement("button"); collapsibleTrigger.className="collapsible-trigger"; collapsibleTrigger.textContent="Show More Details"; container.appendChild(collapsibleTrigger); const collapsibleContent=document.createElement("div"); collapsibleContent.className="collapsible-content"; collapsibleFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); collapsibleContent.appendChild(fieldDiv);}); container.appendChild(collapsibleContent); collapsibleTrigger.onclick=function(){ this.classList.toggle('expanded'); collapsibleContent.classList.toggle('show');};} function calculateConfidenceScore(transaction){ let baseConfidence=0; const description=transaction["Purchase Description"].toLowerCase(); // Check training data matches const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const historicalMatch=trainingData[description]; if (historicalMatch){ // Direct match in training data baseConfidence=90; // Adjust based on frequency baseConfidence +=Math.min(historicalMatch.frequency * 2, 5);} else{ // Calculate based on pattern matching const analysis=analyzeTextContext(description); baseConfidence=parseInt(analysis.confidence); // Check for partial matches in training data const words=description.split(/\s+/); let partialMatches=0; Object.keys(trainingData).forEach(key=>{ const keyWords=key.split(/\s+/); const commonWords=words.filter(word=>keyWords.includes(word)); if (commonWords.length >1){ partialMatches++;}}); // Adjust confidence based on partial matches if (partialMatches >0){ baseConfidence +=Math.min(partialMatches * 3, 10);}} // Adjust based on specific indicators if (description.includes('maid') && description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} if (description.includes('irene') && !description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} // Cap the confidence return Math.min(Math.round(baseConfidence), 95);} function getConfidenceColor(score){ if (score >=90) return '#4CAF50'; if (score >=75) return '#8BC34A'; if (score >=60) return '#FFC107'; return '#FF5722';} function handleFeedback(transaction, isPositive){ if (isPositive){ // Store as positive example in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); showSuccess("Thanks for the feedback! This will help improve future predictions.");} else{ // Show feedback form for correction showFeedbackForm(transaction);}} function showFeedbackForm(transaction){ const modal=document.createElement("div"); modal.className="edit-modal show"; modal.innerHTML=` <h3>What was incorrect?</h3><div class="feedback-form"><div class="feedback-options"><label><input type="checkbox" value="category">Category (${transaction["What's the Purchase Category"]}) </label><label><input type="checkbox" value="paidTo">Paid To (${transaction["Where was the money payed to?"]}) </label></div><div class="correction-fields" style="display: none;"><h4>Please provide the correct values:</h4><div id="correctionInputs"></div></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeFeedbackForm()">Cancel</button><button onclick="submitFeedback()">Submit</button></div>`; // Add styles const style=document.createElement("style"); style.textContent=` .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} `; document.head.appendChild(style); // Show modal document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); // Add event listeners const checkboxes=modal.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox=>{ checkbox.addEventListener('change', ()=>{ const correctionFields=modal.querySelector('.correction-fields'); const correctionInputs=modal.querySelector('#correctionInputs'); if ([...checkboxes].some(cb=>cb.checked)){ correctionFields.style.display='block'; correctionInputs.innerHTML=''; if (checkbox.value==='category' && checkbox.checked){ addCategorySelect(correctionInputs);} if (checkbox.value==='paidTo' && checkbox.checked){ addPaidToSelect(correctionInputs);}} else{ correctionFields.style.display='none';}});});} function addCategorySelect(container){ const select=document.createElement('select'); select.id='correctionCategory'; select.innerHTML=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}">${cat}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.style.marginBottom='10px'; wrapper.innerHTML='<label>Correct Category:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function addPaidToSelect(container){ const paidToOptions=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ]; const select=document.createElement('select'); select.id='correctionPaidTo'; select.innerHTML=paidToOptions.map(opt=>`<option value="${opt}">${opt}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.innerHTML='<label>Correct Paid To:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function closeFeedbackForm(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} function submitFeedback(){ const transaction=transactions[currentTransactionIndex]; const categorySelect=document.getElementById('correctionCategory'); const paidToSelect=document.getElementById('correctionPaidTo'); if (categorySelect){ transaction["What's the Purchase Category"]=categorySelect.value;} if (paidToSelect){ transaction["Where was the money payed to?"]=paidToSelect.value;} // Store correction in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); // Update display displayEditableFields(transaction); closeFeedbackForm(); showSuccess("Thank you for your feedback! This will help improve future predictions.");} function showLoading(){ utils.showElement('.loading-overlay');} function hideLoading(){ utils.hideElement('.loading-overlay');} function showError(title, message, details=''){ ErrorHandler.show(title, message, details);} function closeError(){ ErrorHandler.close();} function showSuccess(message){ SuccessHandler.show(message);} function updateUI(selector, content){ const element=utils.getElement(selector); if (element){ if (typeof content==='string'){ element.innerHTML=content;} else if (content instanceof Node){ element.innerHTML=''; element.appendChild(content);}}} const EventHandlers={ async handleSubmit(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();}, async handleSave(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge();} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}}, handleEdit(field, value){ ModalManager.showEditModal(field, value);}, handleSaveEdit(){ try{ const modal=utils.getElement(UI.selectors.editModal); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} ModalManager.closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}}}; async function initializeApp(){ try{ // Initialize managers and handlers first window.ModalManager=ModalManager; window.EventHandlers=EventHandlers; // Then set up event listeners setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus();} // Remove redundant submit confirmation section const submitConfirmation=utils.getElement('.submit-confirmation'); if (submitConfirmation){ submitConfirmation.remove();}} catch (error){ console.error('Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} if (document.readyState==='loading'){ document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);} else{ initializeApp();} // Make functions available globally Object.assign(window,{ closeError, closeEditModal, saveEdit, showEditModal, processInput, authorize, confirmSubmit, navigateTransaction, closeConfirmation}); class SpeechRecognitionManager{ constructor(){ this.recognition=null; this.isListening=false;} initialize(){ if ('webkitSpeechRecognition' in window){ this.recognition=new webkitSpeechRecognition(); this.recognition.continuous=false; this.recognition.interimResults=false; this.recognition.lang='en-US'; this.recognition.onresult=(event)=>{ const text=event.results[0][0].transcript; document.getElementById('inputText').value=text; processInput();}; this.recognition.onend=()=>{ this.isListening=false; this.updateButtonState();}; this.recognition.onerror=(event)=>{ console.error('Speech recognition error:', event.error); this.isListening=false; this.updateButtonState(); if (event.error==='not-allowed'){ showError( "Microphone Access Denied", "Please allow microphone access to use voice input." );}}; // Add voice input button this.addVoiceButton();}} addVoiceButton(){ const inputSection=document.querySelector('.input-section'); const existingButton=inputSection.querySelector('.voice-input-button'); if (existingButton){ existingButton.remove();} const voiceButton=document.createElement('button'); voiceButton.className='voice-input-button'; voiceButton.innerHTML='🎤'; voiceButton.onclick=()=>this.toggleRecognition(); inputSection.appendChild(voiceButton);} toggleRecognition(){ if (!this.recognition) return; if (this.isListening){ this.recognition.stop();} else{ try{ this.recognition.start(); this.isListening=true; this.updateButtonState();} catch (error){ console.error('Speech recognition error:', error); this.isListening=false; this.updateButtonState();}}} updateButtonState(){ const button=document.querySelector('.voice-input-button'); if (button){ button.style.background=this.isListening ? '#ff4444' : 'var(--primary-color)'; button.innerHTML=this.isListening ? '⏹' : '🎤';}}} function processInput(){ const inputText=document.getElementById("inputText").value; if (inputText.trim()===""){ document.getElementById("editableContainer").innerHTML=""; transactions=[]; updateTransactionCounter(); return;} const transactionTexts=inputText .split(/&&|(?:Also|also|ALSO)/) .map(text=>text.trim()) .filter(text=>text.length >0); transactions=transactionTexts.map(text=>{ const analysis=analyzeTextContext(text); return{ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text, "Where was the money payed to?": analysis.paidTo, "Confidance level": `${analysis.confidence}%`, editedFields: new Set()};}); currentTransactionIndex=0; updateTransactionCounter(); displayEditableFields(transactions[currentTransactionIndex]);} function saveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}} function updateTransactionCounter(){ const indicator=document.querySelector('.transaction-indicator'); const prevBtn=document.getElementById('prevTransaction'); const nextBtn=document.getElementById('nextTransaction'); if (transactions.length >0){ indicator.textContent=`${currentTransactionIndex + 1} of ${transactions.length}`; prevBtn.disabled=currentTransactionIndex===0; nextBtn.disabled=currentTransactionIndex===transactions.length - 1;} else{ indicator.textContent='No Transactions'; prevBtn.disabled=true; nextBtn.disabled=true;}} function navigateTransaction(direction){ const newIndex=currentTransactionIndex + direction; if (newIndex >=0 && newIndex < transactions.length){ currentTransactionIndex=newIndex; displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();}} function storeEditTrainingData(field, oldValue, newValue, transaction){ try{ const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const key=transaction["Purchase Description"].toLowerCase(); if (!trainingData[key]){ trainingData[key]={ corrections:{}, frequency: 0};} if (!trainingData[key].corrections[field]){ trainingData[key].corrections[field]=[];} trainingData[key].corrections[field].push({ from: oldValue, to: newValue, timestamp: new Date().toISOString()}); trainingData[key].frequency++; localStorage.setItem('editTrainingData', JSON.stringify(trainingData));} catch (e){ console.error('Error storing training data:', e);}} async function authorize(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();} function showConfirmation(){ const confirmation=document.querySelector('.submit-confirmation'); const transactionList=confirmation.querySelector('.transaction-list'); transactionList.innerHTML=transactions.map((transaction, index)=>` <div class="transaction-item"><strong>Transaction ${index + 1}:</strong><br>Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>Category: ${transaction["What's the Purchase Category"]}<br>Paid To: ${transaction["Where was the money payed to?"]}<br>Description: ${transaction["Purchase Description"]} </div>`).join(''); confirmation.classList.add('show');} function closeConfirmation(){ document.querySelector('.submit-confirmation').classList.remove('show');} async function confirmSubmit(){ closeConfirmation(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} async function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); TOKEN_MANAGEMENT.clearStoredToken(); return;} try{ TOKEN_MANAGEMENT.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} async function submitData(token){ showLoading(); try{ if (!transactions || transactions.length===0){ throw new Error('No transactions to submit');} // Submit each transaction for (const transaction of transactions){ if (!validateExpenseData(transaction)){ throw new Error('Invalid expense data');} // Learn from the transaction before submitting AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]});} await AI_SYSTEM.savePatterns(); showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length >1 ? 's' : ''}`); clearForm();} catch (error){ console.error('Submit Error:', error); showError( "Submission Failed", "Failed to submit transactions.", error.message );} finally{ hideLoading();}} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter();} function displayEditableFields(transaction){ if (!transaction){ document.getElementById("editableContainer").innerHTML=""; return;} const container=document.getElementById("editableContainer"); container.innerHTML=""; // Essential fields shown by default const essentialFields=[ { field: "Date of Transaction", fullWidth: false}, { field: "How much money? (Tsh)", fullWidth: false}, { field: "What's the Purchase Category", fullWidth: true}, { field: "Where was the money payed to?", fullWidth: true} ]; // Hidden fields in collapsible section const collapsibleFields=[ { field: "Where did the money come from?", fullWidth: false}, { field: "Purchase Description", fullWidth: true} ]; // Display essential fields essentialFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); container.appendChild(fieldDiv);}); // Add confidence and feedback section const confidenceSection=document.createElement("div"); confidenceSection.className="confidence-section"; confidenceSection.style.cssText=` background: var(--bg-input); border-radius: 8px; padding: 12px; margin: 12px 0; `; // Calculate comprehensive confidence score const confidenceScore=calculateConfidenceScore(transaction); // Add confidence display const confidenceDisplay=document.createElement("div"); confidenceDisplay.className="confidence-display"; confidenceDisplay.style.cssText=` display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; `; const confidenceLabel=document.createElement("span"); confidenceLabel.textContent="AI Confidence:"; confidenceLabel.style.color="var(--text-muted)"; const confidenceValue=document.createElement("span"); confidenceValue.textContent=`${confidenceScore}%`; confidenceValue.style.color=getConfidenceColor(confidenceScore); confidenceValue.style.fontWeight="bold"; confidenceDisplay.appendChild(confidenceLabel); confidenceDisplay.appendChild(confidenceValue); // Add feedback section right below confidence const feedbackDiv=document.createElement("div"); feedbackDiv.className="feedback-section"; feedbackDiv.style.cssText=` display: flex; align-items: center; gap: 10px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--bg-card); `; const feedbackText=document.createElement("span"); feedbackText.textContent="Was this prediction accurate?"; feedbackText.style.cssText=` color: var(--text-muted); font-size: 0.9em; `; const thumbsUp=document.createElement("button"); thumbsUp.innerHTML="👍"; thumbsUp.className="feedback-button"; thumbsUp.title="Yes, this prediction is accurate"; const thumbsDown=document.createElement("button"); thumbsDown.innerHTML="👎"; thumbsDown.className="feedback-button"; thumbsDown.title="No, this prediction needs correction"; thumbsUp.onclick=()=>handleFeedback(transaction, true); thumbsDown.onclick=()=>handleFeedback(transaction, false); feedbackDiv.appendChild(feedbackText); feedbackDiv.appendChild(thumbsUp); feedbackDiv.appendChild(thumbsDown); confidenceSection.appendChild(confidenceDisplay); confidenceSection.appendChild(feedbackDiv); container.appendChild(confidenceSection); // Add collapsible section for additional details const collapsibleTrigger=document.createElement("button"); collapsibleTrigger.className="collapsible-trigger"; collapsibleTrigger.textContent="Show More Details"; container.appendChild(collapsibleTrigger); const collapsibleContent=document.createElement("div"); collapsibleContent.className="collapsible-content"; collapsibleFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); collapsibleContent.appendChild(fieldDiv);}); container.appendChild(collapsibleContent); collapsibleTrigger.onclick=function(){ this.classList.toggle('expanded'); collapsibleContent.classList.toggle('show');};} function calculateConfidenceScore(transaction){ let baseConfidence=0; const description=transaction["Purchase Description"].toLowerCase(); // Check training data matches const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const historicalMatch=trainingData[description]; if (historicalMatch){ // Direct match in training data baseConfidence=90; // Adjust based on frequency baseConfidence +=Math.min(historicalMatch.frequency * 2, 5);} else{ // Calculate based on pattern matching const analysis=analyzeTextContext(description); baseConfidence=parseInt(analysis.confidence); // Check for partial matches in training data const words=description.split(/\s+/); let partialMatches=0; Object.keys(trainingData).forEach(key=>{ const keyWords=key.split(/\s+/); const commonWords=words.filter(word=>keyWords.includes(word)); if (commonWords.length >1){ partialMatches++;}}); // Adjust confidence based on partial matches if (partialMatches >0){ baseConfidence +=Math.min(partialMatches * 3, 10);}} // Adjust based on specific indicators if (description.includes('maid') && description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} if (description.includes('irene') && !description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} // Cap the confidence return Math.min(Math.round(baseConfidence), 95);} function getConfidenceColor(score){ if (score >=90) return '#4CAF50'; if (score >=75) return '#8BC34A'; if (score >=60) return '#FFC107'; return '#FF5722';} function handleFeedback(transaction, isPositive){ if (isPositive){ // Store as positive example in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); showSuccess("Thanks for the feedback! This will help improve future predictions.");} else{ // Show feedback form for correction showFeedbackForm(transaction);}} function showFeedbackForm(transaction){ const modal=document.createElement("div"); modal.className="edit-modal show"; modal.innerHTML=` <h3>What was incorrect?</h3><div class="feedback-form"><div class="feedback-options"><label><input type="checkbox" value="category">Category (${transaction["What's the Purchase Category"]}) </label><label><input type="checkbox" value="paidTo">Paid To (${transaction["Where was the money payed to?"]}) </label></div><div class="correction-fields" style="display: none;"><h4>Please provide the correct values:</h4><div id="correctionInputs"></div></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeFeedbackForm()">Cancel</button><button onclick="submitFeedback()">Submit</button></div>`; // Add styles const style=document.createElement("style"); style.textContent=` .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} `; document.head.appendChild(style); // Show modal document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); // Add event listeners const checkboxes=modal.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox=>{ checkbox.addEventListener('change', ()=>{ const correctionFields=modal.querySelector('.correction-fields'); const correctionInputs=modal.querySelector('#correctionInputs'); if ([...checkboxes].some(cb=>cb.checked)){ correctionFields.style.display='block'; correctionInputs.innerHTML=''; if (checkbox.value==='category' && checkbox.checked){ addCategorySelect(correctionInputs);} if (checkbox.value==='paidTo' && checkbox.checked){ addPaidToSelect(correctionInputs);}} else{ correctionFields.style.display='none';}});});} function addCategorySelect(container){ const select=document.createElement('select'); select.id='correctionCategory'; select.innerHTML=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}">${cat}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.style.marginBottom='10px'; wrapper.innerHTML='<label>Correct Category:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function addPaidToSelect(container){ const paidToOptions=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ]; const select=document.createElement('select'); select.id='correctionPaidTo'; select.innerHTML=paidToOptions.map(opt=>`<option value="${opt}">${opt}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.innerHTML='<label>Correct Paid To:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function closeFeedbackForm(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} function submitFeedback(){ const transaction=transactions[currentTransactionIndex]; const categorySelect=document.getElementById('correctionCategory'); const paidToSelect=document.getElementById('correctionPaidTo'); if (categorySelect){ transaction["What's the Purchase Category"]=categorySelect.value;} if (paidToSelect){ transaction["Where was the money payed to?"]=paidToSelect.value;} // Store correction in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); // Update display displayEditableFields(transaction); closeFeedbackForm(); showSuccess("Thank you for your feedback! This will help improve future predictions.");} function showLoading(){ utils.showElement('.loading-overlay');} function hideLoading(){ utils.hideElement('.loading-overlay');} function showError(title, message, details=''){ ErrorHandler.show(title, message, details);} function closeError(){ ErrorHandler.close();} function showSuccess(message){ SuccessHandler.show(message);} function updateUI(selector, content){ const element=utils.getElement(selector); if (element){ if (typeof content==='string'){ element.innerHTML=content;} else if (content instanceof Node){ element.innerHTML=''; element.appendChild(content);}}} const EventHandlers={ async handleSubmit(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();}, async handleSave(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge();} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}}, handleEdit(field, value){ ModalManager.showEditModal(field, value);}, handleSaveEdit(){ try{ const modal=utils.getElement(UI.selectors.editModal); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} ModalManager.closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}}}; async function initializeApp(){ try{ // Initialize managers and handlers first window.ModalManager=ModalManager; window.EventHandlers=EventHandlers; // Then set up event listeners setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus();} // Remove redundant submit confirmation section const submitConfirmation=utils.getElement('.submit-confirmation'); if (submitConfirmation){ submitConfirmation.remove();}} catch (error){ console.error('Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} if (document.readyState==='loading'){ document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);} else{ initializeApp();} // Make functions available globally Object.assign(window,{ closeError, closeEditModal, saveEdit, showEditModal, processInput, authorize, confirmSubmit, navigateTransaction, closeConfirmation}); class SpeechRecognitionManager{ constructor(){ this.recognition=null; this.isListening=false;} initialize(){ if ('webkitSpeechRecognition' in window){ this.recognition=new webkitSpeechRecognition(); this.recognition.continuous=false; this.recognition.interimResults=false; this.recognition.lang='en-US'; this.recognition.onresult=(event)=>{ const text=event.results[0][0].transcript; document.getElementById('inputText').value=text; processInput();}; this.recognition.onend=()=>{ this.isListening=false; this.updateButtonState();}; this.recognition.onerror=(event)=>{ console.error('Speech recognition error:', event.error); this.isListening=false; this.updateButtonState(); if (event.error==='not-allowed'){ showError( "Microphone Access Denied", "Please allow microphone access to use voice input." );}}; // Add voice input button this.addVoiceButton();}} addVoiceButton(){ const inputSection=document.querySelector('.input-section'); const existingButton=inputSection.querySelector('.voice-input-button'); if (existingButton){ existingButton.remove();} const voiceButton=document.createElement('button'); voiceButton.className='voice-input-button'; voiceButton.innerHTML='🎤'; voiceButton.onclick=()=>this.toggleRecognition(); inputSection.appendChild(voiceButton);} toggleRecognition(){ if (!this.recognition) return; if (this.isListening){ this.recognition.stop();} else{ try{ this.recognition.start(); this.isListening=true; this.updateButtonState();} catch (error){ console.error('Speech recognition error:', error); this.isListening=false; this.updateButtonState();}}} updateButtonState(){ const button=document.querySelector('.voice-input-button'); if (button){ button.style.background=this.isListening ? '#ff4444' : 'var(--primary-color)'; button.innerHTML=this.isListening ? '⏹' : '🎤';}}} function processInput(){ const inputText=document.getElementById("inputText").value; if (inputText.trim()===""){ document.getElementById("editableContainer").innerHTML=""; transactions=[]; updateTransactionCounter(); return;} const transactionTexts=inputText .split(/&&|(?:Also|also|ALSO)/) .map(text=>text.trim()) .filter(text=>text.length >0); transactions=transactionTexts.map(text=>{ const analysis=analyzeTextContext(text); return{ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text, "Where was the money payed to?": analysis.paidTo, "Confidance level": `${analysis.confidence}%`, editedFields: new Set()};}); currentTransactionIndex=0; updateTransactionCounter(); displayEditableFields(transactions[currentTransactionIndex]);} function saveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}} function updateTransactionCounter(){ const indicator=document.querySelector('.transaction-indicator'); const prevBtn=document.getElementById('prevTransaction'); const nextBtn=document.getElementById('nextTransaction'); if (transactions.length >0){ indicator.textContent=`${currentTransactionIndex + 1} of ${transactions.length}`; prevBtn.disabled=currentTransactionIndex===0; nextBtn.disabled=currentTransactionIndex===transactions.length - 1;} else{ indicator.textContent='No Transactions'; prevBtn.disabled=true; nextBtn.disabled=true;}} function navigateTransaction(direction){ const newIndex=currentTransactionIndex + direction; if (newIndex >=0 && newIndex < transactions.length){ currentTransactionIndex=newIndex; displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();}} function storeEditTrainingData(field, oldValue, newValue, transaction){ try{ const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const key=transaction["Purchase Description"].toLowerCase(); if (!trainingData[key]){ trainingData[key]={ corrections:{}, frequency: 0};} if (!trainingData[key].corrections[field]){ trainingData[key].corrections[field]=[];} trainingData[key].corrections[field].push({ from: oldValue, to: newValue, timestamp: new Date().toISOString()}); trainingData[key].frequency++; localStorage.setItem('editTrainingData', JSON.stringify(trainingData));} catch (e){ console.error('Error storing training data:', e);}} async function authorize(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();} function showConfirmation(){ const confirmation=document.querySelector('.submit-confirmation'); const transactionList=confirmation.querySelector('.transaction-list'); transactionList.innerHTML=transactions.map((transaction, index)=>` <div class="transaction-item"><strong>Transaction ${index + 1}:</strong><br>Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>Category: ${transaction["What's the Purchase Category"]}<br>Paid To: ${transaction["Where was the money payed to?"]}<br>Description: ${transaction["Purchase Description"]} </div>`).join(''); confirmation.classList.add('show');} function closeConfirmation(){ document.querySelector('.submit-confirmation').classList.remove('show');} async function confirmSubmit(){ closeConfirmation(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} async function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); TOKEN_MANAGEMENT.clearStoredToken(); return;} try{ TOKEN_MANAGEMENT.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} async function submitData(token){ showLoading(); try{ if (!transactions || transactions.length===0){ throw new Error('No transactions to submit');} // Submit each transaction for (const transaction of transactions){ if (!validateExpenseData(transaction)){ throw new Error('Invalid expense data');} // Learn from the transaction before submitting AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]});} await AI_SYSTEM.savePatterns(); showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length >1 ? 's' : ''}`); clearForm();} catch (error){ console.error('Submit Error:', error); showError( "Submission Failed", "Failed to submit transactions.", error.message );} finally{ hideLoading();}} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter();} function displayEditableFields(transaction){ if (!transaction){ document.getElementById("editableContainer").innerHTML=""; return;} const container=document.getElementById("editableContainer"); container.innerHTML=""; // Essential fields shown by default const essentialFields=[ { field: "Date of Transaction", fullWidth: false}, { field: "How much money? (Tsh)", fullWidth: false}, { field: "What's the Purchase Category", fullWidth: true}, { field: "Where was the money payed to?", fullWidth: true} ]; // Hidden fields in collapsible section const collapsibleFields=[ { field: "Where did the money come from?", fullWidth: false}, { field: "Purchase Description", fullWidth: true} ]; // Display essential fields essentialFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); container.appendChild(fieldDiv);}); // Add confidence and feedback section const confidenceSection=document.createElement("div"); confidenceSection.className="confidence-section"; confidenceSection.style.cssText=` background: var(--bg-input); border-radius: 8px; padding: 12px; margin: 12px 0; `; // Calculate comprehensive confidence score const confidenceScore=calculateConfidenceScore(transaction); // Add confidence display const confidenceDisplay=document.createElement("div"); confidenceDisplay.className="confidence-display"; confidenceDisplay.style.cssText=` display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; `; const confidenceLabel=document.createElement("span"); confidenceLabel.textContent="AI Confidence:"; confidenceLabel.style.color="var(--text-muted)"; const confidenceValue=document.createElement("span"); confidenceValue.textContent=`${confidenceScore}%`; confidenceValue.style.color=getConfidenceColor(confidenceScore); confidenceValue.style.fontWeight="bold"; confidenceDisplay.appendChild(confidenceLabel); confidenceDisplay.appendChild(confidenceValue); // Add feedback section right below confidence const feedbackDiv=document.createElement("div"); feedbackDiv.className="feedback-section"; feedbackDiv.style.cssText=` display: flex; align-items: center; gap: 10px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--bg-card); `; const feedbackText=document.createElement("span"); feedbackText.textContent="Was this prediction accurate?"; feedbackText.style.cssText=` color: var(--text-muted); font-size: 0.9em; `; const thumbsUp=document.createElement("button"); thumbsUp.innerHTML="👍"; thumbsUp.className="feedback-button"; thumbsUp.title="Yes, this prediction is accurate"; const thumbsDown=document.createElement("button"); thumbsDown.innerHTML="👎"; thumbsDown.className="feedback-button"; thumbsDown.title="No, this prediction needs correction"; thumbsUp.onclick=()=>handleFeedback(transaction, true); thumbsDown.onclick=()=>handleFeedback(transaction, false); feedbackDiv.appendChild(feedbackText); feedbackDiv.appendChild(thumbsUp); feedbackDiv.appendChild(thumbsDown); confidenceSection.appendChild(confidenceDisplay); confidenceSection.appendChild(feedbackDiv); container.appendChild(confidenceSection); // Add collapsible section for additional details const collapsibleTrigger=document.createElement("button"); collapsibleTrigger.className="collapsible-trigger"; collapsibleTrigger.textContent="Show More Details"; container.appendChild(collapsibleTrigger); const collapsibleContent=document.createElement("div"); collapsibleContent.className="collapsible-content"; collapsibleFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); collapsibleContent.appendChild(fieldDiv);}); container.appendChild(collapsibleContent); collapsibleTrigger.onclick=function(){ this.classList.toggle('expanded'); collapsibleContent.classList.toggle('show');};} function calculateConfidenceScore(transaction){ let baseConfidence=0; const description=transaction["Purchase Description"].toLowerCase(); // Check training data matches const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const historicalMatch=trainingData[description]; if (historicalMatch){ // Direct match in training data baseConfidence=90; // Adjust based on frequency baseConfidence +=Math.min(historicalMatch.frequency * 2, 5);} else{ // Calculate based on pattern matching const analysis=analyzeTextContext(description); baseConfidence=parseInt(analysis.confidence); // Check for partial matches in training data const words=description.split(/\s+/); let partialMatches=0; Object.keys(trainingData).forEach(key=>{ const keyWords=key.split(/\s+/); const commonWords=words.filter(word=>keyWords.includes(word)); if (commonWords.length >1){ partialMatches++;}}); // Adjust confidence based on partial matches if (partialMatches >0){ baseConfidence +=Math.min(partialMatches * 3, 10);}} // Adjust based on specific indicators if (description.includes('maid') && description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} if (description.includes('irene') && !description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} // Cap the confidence return Math.min(Math.round(baseConfidence), 95);} function getConfidenceColor(score){ if (score >=90) return '#4CAF50'; if (score >=75) return '#8BC34A'; if (score >=60) return '#FFC107'; return '#FF5722';} function handleFeedback(transaction, isPositive){ if (isPositive){ // Store as positive example in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); showSuccess("Thanks for the feedback! This will help improve future predictions.");} else{ // Show feedback form for correction showFeedbackForm(transaction);}} function showFeedbackForm(transaction){ const modal=document.createElement("div"); modal.className="edit-modal show"; modal.innerHTML=` <h3>What was incorrect?</h3><div class="feedback-form"><div class="feedback-options"><label><input type="checkbox" value="category">Category (${transaction["What's the Purchase Category"]}) </label><label><input type="checkbox" value="paidTo">Paid To (${transaction["Where was the money payed to?"]}) </label></div><div class="correction-fields" style="display: none;"><h4>Please provide the correct values:</h4><div id="correctionInputs"></div></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeFeedbackForm()">Cancel</button><button onclick="submitFeedback()">Submit</button></div>`; // Add styles const style=document.createElement("style"); style.textContent=` .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} `; document.head.appendChild(style); // Show modal document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); // Add event listeners const checkboxes=modal.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox=>{ checkbox.addEventListener('change', ()=>{ const correctionFields=modal.querySelector('.correction-fields'); const correctionInputs=modal.querySelector('#correctionInputs'); if ([...checkboxes].some(cb=>cb.checked)){ correctionFields.style.display='block'; correctionInputs.innerHTML=''; if (checkbox.value==='category' && checkbox.checked){ addCategorySelect(correctionInputs);} if (checkbox.value==='paidTo' && checkbox.checked){ addPaidToSelect(correctionInputs);}} else{ correctionFields.style.display='none';}});});} function addCategorySelect(container){ const select=document.createElement('select'); select.id='correctionCategory'; select.innerHTML=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}">${cat}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.style.marginBottom='10px'; wrapper.innerHTML='<label>Correct Category:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function addPaidToSelect(container){ const paidToOptions=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ]; const select=document.createElement('select'); select.id='correctionPaidTo'; select.innerHTML=paidToOptions.map(opt=>`<option value="${opt}">${opt}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.innerHTML='<label>Correct Paid To:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function closeFeedbackForm(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} function submitFeedback(){ const transaction=transactions[currentTransactionIndex]; const categorySelect=document.getElementById('correctionCategory'); const paidToSelect=document.getElementById('correctionPaidTo'); if (categorySelect){ transaction["What's the Purchase Category"]=categorySelect.value;} if (paidToSelect){ transaction["Where was the money payed to?"]=paidToSelect.value;} // Store correction in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); // Update display displayEditableFields(transaction); closeFeedbackForm(); showSuccess("Thank you for your feedback! This will help improve future predictions.");} function showLoading(){ utils.showElement('.loading-overlay');} function hideLoading(){ utils.hideElement('.loading-overlay');} function showError(title, message, details=''){ ErrorHandler.show(title, message, details);} function closeError(){ ErrorHandler.close();} function showSuccess(message){ SuccessHandler.show(message);} function updateUI(selector, content){ const element=utils.getElement(selector); if (element){ if (typeof content==='string'){ element.innerHTML=content;} else if (content instanceof Node){ element.innerHTML=''; element.appendChild(content);}}} const EventHandlers={ async handleSubmit(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();}, async handleSave(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge();} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}}, handleEdit(field, value){ ModalManager.showEditModal(field, value);}, handleSaveEdit(){ try{ const modal=utils.getElement(UI.selectors.editModal); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} ModalManager.closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}}}; async function initializeApp(){ try{ // Initialize managers and handlers first window.ModalManager=ModalManager; window.EventHandlers=EventHandlers; // Then set up event listeners setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus();} // Remove redundant submit confirmation section const submitConfirmation=utils.getElement('.submit-confirmation'); if (submitConfirmation){ submitConfirmation.remove();}} catch (error){ console.error('Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} if (document.readyState==='loading'){ document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);} else{ initializeApp();} // Make functions available globally Object.assign(window,{ closeError, closeEditModal, saveEdit, showEditModal, processInput, authorize, confirmSubmit, navigateTransaction, closeConfirmation}); class SpeechRecognitionManager{ constructor(){ this.recognition=null; this.isListening=false;} initialize(){ if ('webkitSpeechRecognition' in window){ this.recognition=new webkitSpeechRecognition(); this.recognition.continuous=false; this.recognition.interimResults=false; this.recognition.lang='en-US'; this.recognition.onresult=(event)=>{ const text=event.results[0][0].transcript; document.getElementById('inputText').value=text; processInput();}; this.recognition.onend=()=>{ this.isListening=false; this.updateButtonState();}; this.recognition.onerror=(event)=>{ console.error('Speech recognition error:', event.error); this.isListening=false; this.updateButtonState(); if (event.error==='not-allowed'){ showError( "Microphone Access Denied", "Please allow microphone access to use voice input." );}}; // Add voice input button this.addVoiceButton();}} addVoiceButton(){ const inputSection=document.querySelector('.input-section'); const existingButton=inputSection.querySelector('.voice-input-button'); if (existingButton){ existingButton.remove();} const voiceButton=document.createElement('button'); voiceButton.className='voice-input-button'; voiceButton.innerHTML='🎤'; voiceButton.onclick=()=>this.toggleRecognition(); inputSection.appendChild(voiceButton);} toggleRecognition(){ if (!this.recognition) return; if (this.isListening){ this.recognition.stop();} else{ try{ this.recognition.start(); this.isListening=true; this.updateButtonState();} catch (error){ console.error('Speech recognition error:', error); this.isListening=false; this.updateButtonState();}}} updateButtonState(){ const button=document.querySelector('.voice-input-button'); if (button){ button.style.background=this.isListening ? '#ff4444' : 'var(--primary-color)'; button.innerHTML=this.isListening ? '⏹' : '🎤';}}} function processInput(){ const inputText=document.getElementById("inputText").value; if (inputText.trim()===""){ document.getElementById("editableContainer").innerHTML=""; transactions=[]; updateTransactionCounter(); return;} const transactionTexts=inputText .split(/&&|(?:Also|also|ALSO)/) .map(text=>text.trim()) .filter(text=>text.length >0); transactions=transactionTexts.map(text=>{ const analysis=analyzeTextContext(text); return{ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text, "Where was the money payed to?": analysis.paidTo, "Confidance level": `${analysis.confidence}%`, editedFields: new Set()};}); currentTransactionIndex=0; updateTransactionCounter(); displayEditableFields(transactions[currentTransactionIndex]);} function saveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}} function updateTransactionCounter(){ const indicator=document.querySelector('.transaction-indicator'); const prevBtn=document.getElementById('prevTransaction'); const nextBtn=document.getElementById('nextTransaction'); if (transactions.length >0){ indicator.textContent=`${currentTransactionIndex + 1} of ${transactions.length}`; prevBtn.disabled=currentTransactionIndex===0; nextBtn.disabled=currentTransactionIndex===transactions.length - 1;} else{ indicator.textContent='No Transactions'; prevBtn.disabled=true; nextBtn.disabled=true;}} function navigateTransaction(direction){ const newIndex=currentTransactionIndex + direction; if (newIndex >=0 && newIndex < transactions.length){ currentTransactionIndex=newIndex; displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();}} function storeEditTrainingData(field, oldValue, newValue, transaction){ try{ const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const key=transaction["Purchase Description"].toLowerCase(); if (!trainingData[key]){ trainingData[key]={ corrections:{}, frequency: 0};} if (!trainingData[key].corrections[field]){ trainingData[key].corrections[field]=[];} trainingData[key].corrections[field].push({ from: oldValue, to: newValue, timestamp: new Date().toISOString()}); trainingData[key].frequency++; localStorage.setItem('editTrainingData', JSON.stringify(trainingData));} catch (e){ console.error('Error storing training data:', e);}} async function authorize(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();} function showConfirmation(){ const confirmation=document.querySelector('.submit-confirmation'); const transactionList=confirmation.querySelector('.transaction-list'); transactionList.innerHTML=transactions.map((transaction, index)=>` <div class="transaction-item"><strong>Transaction ${index + 1}:</strong><br>Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>Category: ${transaction["What's the Purchase Category"]}<br>Paid To: ${transaction["Where was the money payed to?"]}<br>Description: ${transaction["Purchase Description"]} </div>`).join(''); confirmation.classList.add('show');} function closeConfirmation(){ document.querySelector('.submit-confirmation').classList.remove('show');} async function confirmSubmit(){ closeConfirmation(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} async function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); TOKEN_MANAGEMENT.clearStoredToken(); return;} try{ TOKEN_MANAGEMENT.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} async function submitData(token){ showLoading(); try{ if (!transactions || transactions.length===0){ throw new Error('No transactions to submit');} // Submit each transaction for (const transaction of transactions){ if (!validateExpenseData(transaction)){ throw new Error('Invalid expense data');} // Learn from the transaction before submitting AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]});} await AI_SYSTEM.savePatterns(); showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length >1 ? 's' : ''}`); clearForm();} catch (error){ console.error('Submit Error:', error); showError( "Submission Failed", "Failed to submit transactions.", error.message );} finally{ hideLoading();}} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter();} function displayEditableFields(transaction){ if (!transaction){ document.getElementById("editableContainer").innerHTML=""; return;} const container=document.getElementById("editableContainer"); container.innerHTML=""; // Essential fields shown by default const essentialFields=[ { field: "Date of Transaction", fullWidth: false}, { field: "How much money? (Tsh)", fullWidth: false}, { field: "What's the Purchase Category", fullWidth: true}, { field: "Where was the money payed to?", fullWidth: true} ]; // Hidden fields in collapsible section const collapsibleFields=[ { field: "Where did the money come from?", fullWidth: false}, { field: "Purchase Description", fullWidth: true} ]; // Display essential fields essentialFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); container.appendChild(fieldDiv);}); // Add confidence and feedback section const confidenceSection=document.createElement("div"); confidenceSection.className="confidence-section"; confidenceSection.style.cssText=` background: var(--bg-input); border-radius: 8px; padding: 12px; margin: 12px 0; `; // Calculate comprehensive confidence score const confidenceScore=calculateConfidenceScore(transaction); // Add confidence display const confidenceDisplay=document.createElement("div"); confidenceDisplay.className="confidence-display"; confidenceDisplay.style.cssText=` display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; `; const confidenceLabel=document.createElement("span"); confidenceLabel.textContent="AI Confidence:"; confidenceLabel.style.color="var(--text-muted)"; const confidenceValue=document.createElement("span"); confidenceValue.textContent=`${confidenceScore}%`; confidenceValue.style.color=getConfidenceColor(confidenceScore); confidenceValue.style.fontWeight="bold"; confidenceDisplay.appendChild(confidenceLabel); confidenceDisplay.appendChild(confidenceValue); // Add feedback section right below confidence const feedbackDiv=document.createElement("div"); feedbackDiv.className="feedback-section"; feedbackDiv.style.cssText=` display: flex; align-items: center; gap: 10px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--bg-card); `; const feedbackText=document.createElement("span"); feedbackText.textContent="Was this prediction accurate?"; feedbackText.style.cssText=` color: var(--text-muted); font-size: 0.9em; `; const thumbsUp=document.createElement("button"); thumbsUp.innerHTML="👍"; thumbsUp.className="feedback-button"; thumbsUp.title="Yes, this prediction is accurate"; const thumbsDown=document.createElement("button"); thumbsDown.innerHTML="👎"; thumbsDown.className="feedback-button"; thumbsDown.title="No, this prediction needs correction"; thumbsUp.onclick=()=>handleFeedback(transaction, true); thumbsDown.onclick=()=>handleFeedback(transaction, false); feedbackDiv.appendChild(feedbackText); feedbackDiv.appendChild(thumbsUp); feedbackDiv.appendChild(thumbsDown); confidenceSection.appendChild(confidenceDisplay); confidenceSection.appendChild(feedbackDiv); container.appendChild(confidenceSection); // Add collapsible section for additional details const collapsibleTrigger=document.createElement("button"); collapsibleTrigger.className="collapsible-trigger"; collapsibleTrigger.textContent="Show More Details"; container.appendChild(collapsibleTrigger); const collapsibleContent=document.createElement("div"); collapsibleContent.className="collapsible-content"; collapsibleFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); collapsibleContent.appendChild(fieldDiv);}); container.appendChild(collapsibleContent); collapsibleTrigger.onclick=function(){ this.classList.toggle('expanded'); collapsibleContent.classList.toggle('show');};} function calculateConfidenceScore(transaction){ let baseConfidence=0; const description=transaction["Purchase Description"].toLowerCase(); // Check training data matches const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const historicalMatch=trainingData[description]; if (historicalMatch){ // Direct match in training data baseConfidence=90; // Adjust based on frequency baseConfidence +=Math.min(historicalMatch.frequency * 2, 5);} else{ // Calculate based on pattern matching const analysis=analyzeTextContext(description); baseConfidence=parseInt(analysis.confidence); // Check for partial matches in training data const words=description.split(/\s+/); let partialMatches=0; Object.keys(trainingData).forEach(key=>{ const keyWords=key.split(/\s+/); const commonWords=words.filter(word=>keyWords.includes(word)); if (commonWords.length >1){ partialMatches++;}}); // Adjust confidence based on partial matches if (partialMatches >0){ baseConfidence +=Math.min(partialMatches * 3, 10);}} // Adjust based on specific indicators if (description.includes('maid') && description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} if (description.includes('irene') && !description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} // Cap the confidence return Math.min(Math.round(baseConfidence), 95);} function getConfidenceColor(score){ if (score >=90) return '#4CAF50'; if (score >=75) return '#8BC34A'; if (score >=60) return '#FFC107'; return '#FF5722';} function handleFeedback(transaction, isPositive){ if (isPositive){ // Store as positive example in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); showSuccess("Thanks for the feedback! This will help improve future predictions.");} else{ // Show feedback form for correction showFeedbackForm(transaction);}} function showFeedbackForm(transaction){ const modal=document.createElement("div"); modal.className="edit-modal show"; modal.innerHTML=` <h3>What was incorrect?</h3><div class="feedback-form"><div class="feedback-options"><label><input type="checkbox" value="category">Category (${transaction["What's the Purchase Category"]}) </label><label><input type="checkbox" value="paidTo">Paid To (${transaction["Where was the money payed to?"]}) </label></div><div class="correction-fields" style="display: none;"><h4>Please provide the correct values:</h4><div id="correctionInputs"></div></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeFeedbackForm()">Cancel</button><button onclick="submitFeedback()">Submit</button></div>`; // Add styles const style=document.createElement("style"); style.textContent=` .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} `; document.head.appendChild(style); // Show modal document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); // Add event listeners const checkboxes=modal.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox=>{ checkbox.addEventListener('change', ()=>{ const correctionFields=modal.querySelector('.correction-fields'); const correctionInputs=modal.querySelector('#correctionInputs'); if ([...checkboxes].some(cb=>cb.checked)){ correctionFields.style.display='block'; correctionInputs.innerHTML=''; if (checkbox.value==='category' && checkbox.checked){ addCategorySelect(correctionInputs);} if (checkbox.value==='paidTo' && checkbox.checked){ addPaidToSelect(correctionInputs);}} else{ correctionFields.style.display='none';}});});} function addCategorySelect(container){ const select=document.createElement('select'); select.id='correctionCategory'; select.innerHTML=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}">${cat}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.style.marginBottom='10px'; wrapper.innerHTML='<label>Correct Category:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function addPaidToSelect(container){ const paidToOptions=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ]; const select=document.createElement('select'); select.id='correctionPaidTo'; select.innerHTML=paidToOptions.map(opt=>`<option value="${opt}">${opt}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.innerHTML='<label>Correct Paid To:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function closeFeedbackForm(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} function submitFeedback(){ const transaction=transactions[currentTransactionIndex]; const categorySelect=document.getElementById('correctionCategory'); const paidToSelect=document.getElementById('correctionPaidTo'); if (categorySelect){ transaction["What's the Purchase Category"]=categorySelect.value;} if (paidToSelect){ transaction["Where was the money payed to?"]=paidToSelect.value;} // Store correction in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); // Update display displayEditableFields(transaction); closeFeedbackForm(); showSuccess("Thank you for your feedback! This will help improve future predictions.");} function showLoading(){ utils.showElement('.loading-overlay');} function hideLoading(){ utils.hideElement('.loading-overlay');} function showError(title, message, details=''){ ErrorHandler.show(title, message, details);} function closeError(){ ErrorHandler.close();} function showSuccess(message){ SuccessHandler.show(message);} function updateUI(selector, content){ const element=utils.getElement(selector); if (element){ if (typeof content==='string'){ element.innerHTML=content;} else if (content instanceof Node){ element.innerHTML=''; element.appendChild(content);}}} const EventHandlers={ async handleSubmit(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();}, async handleSave(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge();} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}}, handleEdit(field, value){ ModalManager.showEditModal(field, value);}, handleSaveEdit(){ try{ const modal=utils.getElement(UI.selectors.editModal); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} ModalManager.closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}}}; async function initializeApp(){ try{ // Initialize managers and handlers first window.ModalManager=ModalManager; window.EventHandlers=EventHandlers; // Then set up event listeners setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus();} // Remove redundant submit confirmation section const submitConfirmation=utils.getElement('.submit-confirmation'); if (submitConfirmation){ submitConfirmation.remove();}} catch (error){ console.error('Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} if (document.readyState==='loading'){ document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);} else{ initializeApp();} // Make functions available globally Object.assign(window,{ closeError, closeEditModal, saveEdit, showEditModal, processInput, authorize, confirmSubmit, navigateTransaction, closeConfirmation}); class SpeechRecognitionManager{ constructor(){ this.recognition=null; this.isListening=false;} initialize(){ if ('webkitSpeechRecognition' in window){ this.recognition=new webkitSpeechRecognition(); this.recognition.continuous=false; this.recognition.interimResults=false; this.recognition.lang='en-US'; this.recognition.onresult=(event)=>{ const text=event.results[0][0].transcript; document.getElementById('inputText').value=text; processInput();}; this.recognition.onend=()=>{ this.isListening=false; this.updateButtonState();}; this.recognition.onerror=(event)=>{ console.error('Speech recognition error:', event.error); this.isListening=false; this.updateButtonState(); if (event.error==='not-allowed'){ showError( "Microphone Access Denied", "Please allow microphone access to use voice input." );}}; // Add voice input button this.addVoiceButton();}} addVoiceButton(){ const inputSection=document.querySelector('.input-section'); const existingButton=inputSection.querySelector('.voice-input-button'); if (existingButton){ existingButton.remove();} const voiceButton=document.createElement('button'); voiceButton.className='voice-input-button'; voiceButton.innerHTML='🎤'; voiceButton.onclick=()=>this.toggleRecognition(); inputSection.appendChild(voiceButton);} toggleRecognition(){ if (!this.recognition) return; if (this.isListening){ this.recognition.stop();} else{ try{ this.recognition.start(); this.isListening=true; this.updateButtonState();} catch (error){ console.error('Speech recognition error:', error); this.isListening=false; this.updateButtonState();}}} updateButtonState(){ const button=document.querySelector('.voice-input-button'); if (button){ button.style.background=this.isListening ? '#ff4444' : 'var(--primary-color)'; button.innerHTML=this.isListening ? '⏹' : '🎤';}}} function processInput(){ const inputText=document.getElementById("inputText").value; if (inputText.trim()===""){ document.getElementById("editableContainer").innerHTML=""; transactions=[]; updateTransactionCounter(); return;} const transactionTexts=inputText .split(/&&|(?:Also|also|ALSO)/) .map(text=>text.trim()) .filter(text=>text.length >0); transactions=transactionTexts.map(text=>{ const analysis=analyzeTextContext(text); return{ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text, "Where was the money payed to?": analysis.paidTo, "Confidance level": `${analysis.confidence}%`, editedFields: new Set()};}); currentTransactionIndex=0; updateTransactionCounter(); displayEditableFields(transactions[currentTransactionIndex]);} function saveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}} function updateTransactionCounter(){ const indicator=document.querySelector('.transaction-indicator'); const prevBtn=document.getElementById('prevTransaction'); const nextBtn=document.getElementById('nextTransaction'); if (transactions.length >0){ indicator.textContent=`${currentTransactionIndex + 1} of ${transactions.length}`; prevBtn.disabled=currentTransactionIndex===0; nextBtn.disabled=currentTransactionIndex===transactions.length - 1;} else{ indicator.textContent='No Transactions'; prevBtn.disabled=true; nextBtn.disabled=true;}} function navigateTransaction(direction){ const newIndex=currentTransactionIndex + direction; if (newIndex >=0 && newIndex < transactions.length){ currentTransactionIndex=newIndex; displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();}} function storeEditTrainingData(field, oldValue, newValue, transaction){ try{ const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const key=transaction["Purchase Description"].toLowerCase(); if (!trainingData[key]){ trainingData[key]={ corrections:{}, frequency: 0};} if (!trainingData[key].corrections[field]){ trainingData[key].corrections[field]=[];} trainingData[key].corrections[field].push({ from: oldValue, to: newValue, timestamp: new Date().toISOString()}); trainingData[key].frequency++; localStorage.setItem('editTrainingData', JSON.stringify(trainingData));} catch (e){ console.error('Error storing training data:', e);}} async function authorize(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();} function showConfirmation(){ const confirmation=document.querySelector('.submit-confirmation'); const transactionList=confirmation.querySelector('.transaction-list'); transactionList.innerHTML=transactions.map((transaction, index)=>` <div class="transaction-item"><strong>Transaction ${index + 1}:</strong><br>Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>Category: ${transaction["What's the Purchase Category"]}<br>Paid To: ${transaction["Where was the money payed to?"]}<br>Description: ${transaction["Purchase Description"]} </div>`).join(''); confirmation.classList.add('show');} function closeConfirmation(){ document.querySelector('.submit-confirmation').classList.remove('show');} async function confirmSubmit(){ closeConfirmation(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} async function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); TOKEN_MANAGEMENT.clearStoredToken(); return;} try{ TOKEN_MANAGEMENT.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} async function submitData(token){ showLoading(); try{ if (!transactions || transactions.length===0){ throw new Error('No transactions to submit');} // Submit each transaction for (const transaction of transactions){ if (!validateExpenseData(transaction)){ throw new Error('Invalid expense data');} // Learn from the transaction before submitting AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]});} await AI_SYSTEM.savePatterns(); showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length >1 ? 's' : ''}`); clearForm();} catch (error){ console.error('Submit Error:', error); showError( "Submission Failed", "Failed to submit transactions.", error.message );} finally{ hideLoading();}} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter();} function displayEditableFields(transaction){ if (!transaction){ document.getElementById("editableContainer").innerHTML=""; return;} const container=document.getElementById("editableContainer"); container.innerHTML=""; // Essential fields shown by default const essentialFields=[ { field: "Date of Transaction", fullWidth: false}, { field: "How much money? (Tsh)", fullWidth: false}, { field: "What's the Purchase Category", fullWidth: true}, { field: "Where was the money payed to?", fullWidth: true} ]; // Hidden fields in collapsible section const collapsibleFields=[ { field: "Where did the money come from?", fullWidth: false}, { field: "Purchase Description", fullWidth: true} ]; // Display essential fields essentialFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); container.appendChild(fieldDiv);}); // Add confidence and feedback section const confidenceSection=document.createElement("div"); confidenceSection.className="confidence-section"; confidenceSection.style.cssText=` background: var(--bg-input); border-radius: 8px; padding: 12px; margin: 12px 0; `; // Calculate comprehensive confidence score const confidenceScore=calculateConfidenceScore(transaction); // Add confidence display const confidenceDisplay=document.createElement("div"); confidenceDisplay.className="confidence-display"; confidenceDisplay.style.cssText=` display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; `; const confidenceLabel=document.createElement("span"); confidenceLabel.textContent="AI Confidence:"; confidenceLabel.style.color="var(--text-muted)"; const confidenceValue=document.createElement("span"); confidenceValue.textContent=`${confidenceScore}%`; confidenceValue.style.color=getConfidenceColor(confidenceScore); confidenceValue.style.fontWeight="bold"; confidenceDisplay.appendChild(confidenceLabel); confidenceDisplay.appendChild(confidenceValue); // Add feedback section right below confidence const feedbackDiv=document.createElement("div"); feedbackDiv.className="feedback-section"; feedbackDiv.style.cssText=` display: flex; align-items: center; gap: 10px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--bg-card); `; const feedbackText=document.createElement("span"); feedbackText.textContent="Was this prediction accurate?"; feedbackText.style.cssText=` color: var(--text-muted); font-size: 0.9em; `; const thumbsUp=document.createElement("button"); thumbsUp.innerHTML="👍"; thumbsUp.className="feedback-button"; thumbsUp.title="Yes, this prediction is accurate"; const thumbsDown=document.createElement("button"); thumbsDown.innerHTML="👎"; thumbsDown.className="feedback-button"; thumbsDown.title="No, this prediction needs correction"; thumbsUp.onclick=()=>handleFeedback(transaction, true); thumbsDown.onclick=()=>handleFeedback(transaction, false); feedbackDiv.appendChild(feedbackText); feedbackDiv.appendChild(thumbsUp); feedbackDiv.appendChild(thumbsDown); confidenceSection.appendChild(confidenceDisplay); confidenceSection.appendChild(feedbackDiv); container.appendChild(confidenceSection); // Add collapsible section for additional details const collapsibleTrigger=document.createElement("button"); collapsibleTrigger.className="collapsible-trigger"; collapsibleTrigger.textContent="Show More Details"; container.appendChild(collapsibleTrigger); const collapsibleContent=document.createElement("div"); collapsibleContent.className="collapsible-content"; collapsibleFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); collapsibleContent.appendChild(fieldDiv);}); container.appendChild(collapsibleContent); collapsibleTrigger.onclick=function(){ this.classList.toggle('expanded'); collapsibleContent.classList.toggle('show');};} function calculateConfidenceScore(transaction){ let baseConfidence=0; const description=transaction["Purchase Description"].toLowerCase(); // Check training data matches const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const historicalMatch=trainingData[description]; if (historicalMatch){ // Direct match in training data baseConfidence=90; // Adjust based on frequency baseConfidence +=Math.min(historicalMatch.frequency * 2, 5);} else{ // Calculate based on pattern matching const analysis=analyzeTextContext(description); baseConfidence=parseInt(analysis.confidence); // Check for partial matches in training data const words=description.split(/\s+/); let partialMatches=0; Object.keys(trainingData).forEach(key=>{ const keyWords=key.split(/\s+/); const commonWords=words.filter(word=>keyWords.includes(word)); if (commonWords.length >1){ partialMatches++;}}); // Adjust confidence based on partial matches if (partialMatches >0){ baseConfidence +=Math.min(partialMatches * 3, 10);}} // Adjust based on specific indicators if (description.includes('maid') && description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} if (description.includes('irene') && !description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} // Cap the confidence return Math.min(Math.round(baseConfidence), 95);} function getConfidenceColor(score){ if (score >=90) return '#4CAF50'; if (score >=75) return '#8BC34A'; if (score >=60) return '#FFC107'; return '#FF5722';} function handleFeedback(transaction, isPositive){ if (isPositive){ // Store as positive example in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); showSuccess("Thanks for the feedback! This will help improve future predictions.");} else{ // Show feedback form for correction showFeedbackForm(transaction);}} function showFeedbackForm(transaction){ const modal=document.createElement("div"); modal.className="edit-modal show"; modal.innerHTML=` <h3>What was incorrect?</h3><div class="feedback-form"><div class="feedback-options"><label><input type="checkbox" value="category">Category (${transaction["What's the Purchase Category"]}) </label><label><input type="checkbox" value="paidTo">Paid To (${transaction["Where was the money payed to?"]}) </label></div><div class="correction-fields" style="display: none;"><h4>Please provide the correct values:</h4><div id="correctionInputs"></div></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeFeedbackForm()">Cancel</button><button onclick="submitFeedback()">Submit</button></div>`; // Add styles const style=document.createElement("style"); style.textContent=` .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} `; document.head.appendChild(style); // Show modal document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); // Add event listeners const checkboxes=modal.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox=>{ checkbox.addEventListener('change', ()=>{ const correctionFields=modal.querySelector('.correction-fields'); const correctionInputs=modal.querySelector('#correctionInputs'); if ([...checkboxes].some(cb=>cb.checked)){ correctionFields.style.display='block'; correctionInputs.innerHTML=''; if (checkbox.value==='category' && checkbox.checked){ addCategorySelect(correctionInputs);} if (checkbox.value==='paidTo' && checkbox.checked){ addPaidToSelect(correctionInputs);}} else{ correctionFields.style.display='none';}});});} function addCategorySelect(container){ const select=document.createElement('select'); select.id='correctionCategory'; select.innerHTML=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}">${cat}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.style.marginBottom='10px'; wrapper.innerHTML='<label>Correct Category:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function addPaidToSelect(container){ const paidToOptions=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ]; const select=document.createElement('select'); select.id='correctionPaidTo'; select.innerHTML=paidToOptions.map(opt=>`<option value="${opt}">${opt}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.innerHTML='<label>Correct Paid To:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function closeFeedbackForm(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} function submitFeedback(){ const transaction=transactions[currentTransactionIndex]; const categorySelect=document.getElementById('correctionCategory'); const paidToSelect=document.getElementById('correctionPaidTo'); if (categorySelect){ transaction["What's the Purchase Category"]=categorySelect.value;} if (paidToSelect){ transaction["Where was the money payed to?"]=paidToSelect.value;} // Store correction in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); // Update display displayEditableFields(transaction); closeFeedbackForm(); showSuccess("Thank you for your feedback! This will help improve future predictions.");} function showLoading(){ utils.showElement('.loading-overlay');} function hideLoading(){ utils.hideElement('.loading-overlay');} function showError(title, message, details=''){ ErrorHandler.show(title, message, details);} function closeError(){ ErrorHandler.close();} function showSuccess(message){ SuccessHandler.show(message);} function updateUI(selector, content){ const element=utils.getElement(selector); if (element){ if (typeof content==='string'){ element.innerHTML=content;} else if (content instanceof Node){ element.innerHTML=''; element.appendChild(content);}}} const EventHandlers={ async handleSubmit(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();}, async handleSave(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge();} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}}, handleEdit(field, value){ ModalManager.showEditModal(field, value);}, handleSaveEdit(){ try{ const modal=utils.getElement(UI.selectors.editModal); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} ModalManager.closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}}}; async function initializeApp(){ try{ // Initialize managers and handlers first window.ModalManager=ModalManager; window.EventHandlers=EventHandlers; // Then set up event listeners setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus();} // Remove redundant submit confirmation section const submitConfirmation=utils.getElement('.submit-confirmation'); if (submitConfirmation){ submitConfirmation.remove();}} catch (error){ console.error('Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} if (document.readyState==='loading'){ document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);} else{ initializeApp();} // Make functions available globally Object.assign(window,{ closeError, closeEditModal, saveEdit, showEditModal, processInput, authorize, confirmSubmit, navigateTransaction, closeConfirmation}); class SpeechRecognitionManager{ constructor(){ this.recognition=null; this.isListening=false;} initialize(){ if ('webkitSpeechRecognition' in window){ this.recognition=new webkitSpeechRecognition(); this.recognition.continuous=false; this.recognition.interimResults=false; this.recognition.lang='en-US'; this.recognition.onresult=(event)=>{ const text=event.results[0][0].transcript; document.getElementById('inputText').value=text; processInput();}; this.recognition.onend=()=>{ this.isListening=false; this.updateButtonState();}; this.recognition.onerror=(event)=>{ console.error('Speech recognition error:', event.error); this.isListening=false; this.updateButtonState(); if (event.error==='not-allowed'){ showError( "Microphone Access Denied", "Please allow microphone access to use voice input." );}}; // Add voice input button this.addVoiceButton();}} addVoiceButton(){ const inputSection=document.querySelector('.input-section'); const existingButton=inputSection.querySelector('.voice-input-button'); if (existingButton){ existingButton.remove();} const voiceButton=document.createElement('button'); voiceButton.className='voice-input-button'; voiceButton.innerHTML='🎤'; voiceButton.onclick=()=>this.toggleRecognition(); inputSection.appendChild(voiceButton);} toggleRecognition(){ if (!this.recognition) return; if (this.isListening){ this.recognition.stop();} else{ try{ this.recognition.start(); this.isListening=true; this.updateButtonState();} catch (error){ console.error('Speech recognition error:', error); this.isListening=false; this.updateButtonState();}}} updateButtonState(){ const button=document.querySelector('.voice-input-button'); if (button){ button.style.background=this.isListening ? '#ff4444' : 'var(--primary-color)'; button.innerHTML=this.isListening ? '⏹' : '🎤';}}} function processInput(){ const inputText=document.getElementById("inputText").value; if (inputText.trim()===""){ document.getElementById("editableContainer").innerHTML=""; transactions=[]; updateTransactionCounter(); return;} const transactionTexts=inputText .split(/&&|(?:Also|also|ALSO)/) .map(text=>text.trim()) .filter(text=>text.length >0); transactions=transactionTexts.map(text=>{ const analysis=analyzeTextContext(text); return{ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text, "Where was the money payed to?": analysis.paidTo, "Confidance level": `${analysis.confidence}%`, editedFields: new Set()};}); currentTransactionIndex=0; updateTransactionCounter(); displayEditableFields(transactions[currentTransactionIndex]);} function saveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}} function updateTransactionCounter(){ const indicator=document.querySelector('.transaction-indicator'); const prevBtn=document.getElementById('prevTransaction'); const nextBtn=document.getElementById('nextTransaction'); if (transactions.length >0){ indicator.textContent=`${currentTransactionIndex + 1} of ${transactions.length}`; prevBtn.disabled=currentTransactionIndex===0; nextBtn.disabled=currentTransactionIndex===transactions.length - 1;} else{ indicator.textContent='No Transactions'; prevBtn.disabled=true; nextBtn.disabled=true;}} function navigateTransaction(direction){ const newIndex=currentTransactionIndex + direction; if (newIndex >=0 && newIndex < transactions.length){ currentTransactionIndex=newIndex; displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();}} function storeEditTrainingData(field, oldValue, newValue, transaction){ try{ const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const key=transaction["Purchase Description"].toLowerCase(); if (!trainingData[key]){ trainingData[key]={ corrections:{}, frequency: 0};} if (!trainingData[key].corrections[field]){ trainingData[key].corrections[field]=[];} trainingData[key].corrections[field].push({ from: oldValue, to: newValue, timestamp: new Date().toISOString()}); trainingData[key].frequency++; localStorage.setItem('editTrainingData', JSON.stringify(trainingData));} catch (e){ console.error('Error storing training data:', e);}} async function authorize(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();} function showConfirmation(){ const confirmation=document.querySelector('.submit-confirmation'); const transactionList=confirmation.querySelector('.transaction-list'); transactionList.innerHTML=transactions.map((transaction, index)=>` <div class="transaction-item"><strong>Transaction ${index + 1}:</strong><br>Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>Category: ${transaction["What's the Purchase Category"]}<br>Paid To: ${transaction["Where was the money payed to?"]}<br>Description: ${transaction["Purchase Description"]} </div>`).join(''); confirmation.classList.add('show');} function closeConfirmation(){ document.querySelector('.submit-confirmation').classList.remove('show');} async function confirmSubmit(){ closeConfirmation(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} async function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); TOKEN_MANAGEMENT.clearStoredToken(); return;} try{ TOKEN_MANAGEMENT.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} async function submitData(token){ showLoading(); try{ if (!transactions || transactions.length===0){ throw new Error('No transactions to submit');} // Submit each transaction for (const transaction of transactions){ if (!validateExpenseData(transaction)){ throw new Error('Invalid expense data');} // Learn from the transaction before submitting AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]});} await AI_SYSTEM.savePatterns(); showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length >1 ? 's' : ''}`); clearForm();} catch (error){ console.error('Submit Error:', error); showError( "Submission Failed", "Failed to submit transactions.", error.message );} finally{ hideLoading();}} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter();} function displayEditableFields(transaction){ if (!transaction){ document.getElementById("editableContainer").innerHTML=""; return;} const container=document.getElementById("editableContainer"); container.innerHTML=""; // Essential fields shown by default const essentialFields=[ { field: "Date of Transaction", fullWidth: false}, { field: "How much money? (Tsh)", fullWidth: false}, { field: "What's the Purchase Category", fullWidth: true}, { field: "Where was the money payed to?", fullWidth: true} ]; // Hidden fields in collapsible section const collapsibleFields=[ { field: "Where did the money come from?", fullWidth: false}, { field: "Purchase Description", fullWidth: true} ]; // Display essential fields essentialFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); container.appendChild(fieldDiv);}); // Add confidence and feedback section const confidenceSection=document.createElement("div"); confidenceSection.className="confidence-section"; confidenceSection.style.cssText=` background: var(--bg-input); border-radius: 8px; padding: 12px; margin: 12px 0; `; // Calculate comprehensive confidence score const confidenceScore=calculateConfidenceScore(transaction); // Add confidence display const confidenceDisplay=document.createElement("div"); confidenceDisplay.className="confidence-display"; confidenceDisplay.style.cssText=` display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; `; const confidenceLabel=document.createElement("span"); confidenceLabel.textContent="AI Confidence:"; confidenceLabel.style.color="var(--text-muted)"; const confidenceValue=document.createElement("span"); confidenceValue.textContent=`${confidenceScore}%`; confidenceValue.style.color=getConfidenceColor(confidenceScore); confidenceValue.style.fontWeight="bold"; confidenceDisplay.appendChild(confidenceLabel); confidenceDisplay.appendChild(confidenceValue); // Add feedback section right below confidence const feedbackDiv=document.createElement("div"); feedbackDiv.className="feedback-section"; feedbackDiv.style.cssText=` display: flex; align-items: center; gap: 10px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--bg-card); `; const feedbackText=document.createElement("span"); feedbackText.textContent="Was this prediction accurate?"; feedbackText.style.cssText=` color: var(--text-muted); font-size: 0.9em; `; const thumbsUp=document.createElement("button"); thumbsUp.innerHTML="👍"; thumbsUp.className="feedback-button"; thumbsUp.title="Yes, this prediction is accurate"; const thumbsDown=document.createElement("button"); thumbsDown.innerHTML="👎"; thumbsDown.className="feedback-button"; thumbsDown.title="No, this prediction needs correction"; thumbsUp.onclick=()=>handleFeedback(transaction, true); thumbsDown.onclick=()=>handleFeedback(transaction, false); feedbackDiv.appendChild(feedbackText); feedbackDiv.appendChild(thumbsUp); feedbackDiv.appendChild(thumbsDown); confidenceSection.appendChild(confidenceDisplay); confidenceSection.appendChild(feedbackDiv); container.appendChild(confidenceSection); // Add collapsible section for additional details const collapsibleTrigger=document.createElement("button"); collapsibleTrigger.className="collapsible-trigger"; collapsibleTrigger.textContent="Show More Details"; container.appendChild(collapsibleTrigger); const collapsibleContent=document.createElement("div"); collapsibleContent.className="collapsible-content"; collapsibleFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); collapsibleContent.appendChild(fieldDiv);}); container.appendChild(collapsibleContent); collapsibleTrigger.onclick=function(){ this.classList.toggle('expanded'); collapsibleContent.classList.toggle('show');};} function calculateConfidenceScore(transaction){ let baseConfidence=0; const description=transaction["Purchase Description"].toLowerCase(); // Check training data matches const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const historicalMatch=trainingData[description]; if (historicalMatch){ // Direct match in training data baseConfidence=90; // Adjust based on frequency baseConfidence +=Math.min(historicalMatch.frequency * 2, 5);} else{ // Calculate based on pattern matching const analysis=analyzeTextContext(description); baseConfidence=parseInt(analysis.confidence); // Check for partial matches in training data const words=description.split(/\s+/); let partialMatches=0; Object.keys(trainingData).forEach(key=>{ const keyWords=key.split(/\s+/); const commonWords=words.filter(word=>keyWords.includes(word)); if (commonWords.length >1){ partialMatches++;}}); // Adjust confidence based on partial matches if (partialMatches >0){ baseConfidence +=Math.min(partialMatches * 3, 10);}} // Adjust based on specific indicators if (description.includes('maid') && description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} if (description.includes('irene') && !description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} // Cap the confidence return Math.min(Math.round(baseConfidence), 95);} function getConfidenceColor(score){ if (score >=90) return '#4CAF50'; if (score >=75) return '#8BC34A'; if (score >=60) return '#FFC107'; return '#FF5722';} function handleFeedback(transaction, isPositive){ if (isPositive){ // Store as positive example in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); showSuccess("Thanks for the feedback! This will help improve future predictions.");} else{ // Show feedback form for correction showFeedbackForm(transaction);}} function showFeedbackForm(transaction){ const modal=document.createElement("div"); modal.className="edit-modal show"; modal.innerHTML=` <h3>What was incorrect?</h3><div class="feedback-form"><div class="feedback-options"><label><input type="checkbox" value="category">Category (${transaction["What's the Purchase Category"]}) </label><label><input type="checkbox" value="paidTo">Paid To (${transaction["Where was the money payed to?"]}) </label></div><div class="correction-fields" style="display: none;"><h4>Please provide the correct values:</h4><div id="correctionInputs"></div></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeFeedbackForm()">Cancel</button><button onclick="submitFeedback()">Submit</button></div>`; // Add styles const style=document.createElement("style"); style.textContent=` .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} `; document.head.appendChild(style); // Show modal document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); // Add event listeners const checkboxes=modal.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox=>{ checkbox.addEventListener('change', ()=>{ const correctionFields=modal.querySelector('.correction-fields'); const correctionInputs=modal.querySelector('#correctionInputs'); if ([...checkboxes].some(cb=>cb.checked)){ correctionFields.style.display='block'; correctionInputs.innerHTML=''; if (checkbox.value==='category' && checkbox.checked){ addCategorySelect(correctionInputs);} if (checkbox.value==='paidTo' && checkbox.checked){ addPaidToSelect(correctionInputs);}} else{ correctionFields.style.display='none';}});});} function addCategorySelect(container){ const select=document.createElement('select'); select.id='correctionCategory'; select.innerHTML=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}">${cat}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.style.marginBottom='10px'; wrapper.innerHTML='<label>Correct Category:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function addPaidToSelect(container){ const paidToOptions=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ]; const select=document.createElement('select'); select.id='correctionPaidTo'; select.innerHTML=paidToOptions.map(opt=>`<option value="${opt}">${opt}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.innerHTML='<label>Correct Paid To:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function closeFeedbackForm(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} function submitFeedback(){ const transaction=transactions[currentTransactionIndex]; const categorySelect=document.getElementById('correctionCategory'); const paidToSelect=document.getElementById('correctionPaidTo'); if (categorySelect){ transaction["What's the Purchase Category"]=categorySelect.value;} if (paidToSelect){ transaction["Where was the money payed to?"]=paidToSelect.value;} // Store correction in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); // Update display displayEditableFields(transaction); closeFeedbackForm(); showSuccess("Thank you for your feedback! This will help improve future predictions.");} function showLoading(){ utils.showElement('.loading-overlay');} function hideLoading(){ utils.hideElement('.loading-overlay');} function showError(title, message, details=''){ ErrorHandler.show(title, message, details);} function closeError(){ ErrorHandler.close();} function showSuccess(message){ SuccessHandler.show(message);} function updateUI(selector, content){ const element=utils.getElement(selector); if (element){ if (typeof content==='string'){ element.innerHTML=content;} else if (content instanceof Node){ element.innerHTML=''; element.appendChild(content);}}} const EventHandlers={ async handleSubmit(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();}, async handleSave(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge();} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}}, handleEdit(field, value){ ModalManager.showEditModal(field, value);}, handleSaveEdit(){ try{ const modal=utils.getElement(UI.selectors.editModal); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} ModalManager.closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}}}; async function initializeApp(){ try{ // Initialize managers and handlers first window.ModalManager=ModalManager; window.EventHandlers=EventHandlers; // Then set up event listeners setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus();} // Remove redundant submit confirmation section const submitConfirmation=utils.getElement('.submit-confirmation'); if (submitConfirmation){ submitConfirmation.remove();}} catch (error){ console.error('Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} if (document.readyState==='loading'){ document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);} else{ initializeApp();} // Make functions available globally Object.assign(window,{ closeError, closeEditModal, saveEdit, showEditModal, processInput, authorize, confirmSubmit, navigateTransaction, closeConfirmation}); class SpeechRecognitionManager{ constructor(){ this.recognition=null; this.isListening=false;} initialize(){ if ('webkitSpeechRecognition' in window){ this.recognition=new webkitSpeechRecognition(); this.recognition.continuous=false; this.recognition.interimResults=false; this.recognition.lang='en-US'; this.recognition.onresult=(event)=>{ const text=event.results[0][0].transcript; document.getElementById('inputText').value=text; processInput();}; this.recognition.onend=()=>{ this.isListening=false; this.updateButtonState();}; this.recognition.onerror=(event)=>{ console.error('Speech recognition error:', event.error); this.isListening=false; this.updateButtonState(); if (event.error==='not-allowed'){ showError( "Microphone Access Denied", "Please allow microphone access to use voice input." );}}; // Add voice input button this.addVoiceButton();}} addVoiceButton(){ const inputSection=document.querySelector('.input-section'); const existingButton=inputSection.querySelector('.voice-input-button'); if (existingButton){ existingButton.remove();} const voiceButton=document.createElement('button'); voiceButton.className='voice-input-button'; voiceButton.innerHTML='🎤'; voiceButton.onclick=()=>this.toggleRecognition(); inputSection.appendChild(voiceButton);} toggleRecognition(){ if (!this.recognition) return; if (this.isListening){ this.recognition.stop();} else{ try{ this.recognition.start(); this.isListening=true; this.updateButtonState();} catch (error){ console.error('Speech recognition error:', error); this.isListening=false; this.updateButtonState();}}} updateButtonState(){ const button=document.querySelector('.voice-input-button'); if (button){ button.style.background=this.isListening ? '#ff4444' : 'var(--primary-color)'; button.innerHTML=this.isListening ? '⏹' : '🎤';}}} function processInput(){ const inputText=document.getElementById("inputText").value; if (inputText.trim()===""){ document.getElementById("editableContainer").innerHTML=""; transactions=[]; updateTransactionCounter(); return;} const transactionTexts=inputText .split(/&&|(?:Also|also|ALSO)/) .map(text=>text.trim()) .filter(text=>text.length >0); transactions=transactionTexts.map(text=>{ const analysis=analyzeTextContext(text); return{ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text, "Where was the money payed to?": analysis.paidTo, "Confidance level": `${analysis.confidence}%`, editedFields: new Set()};}); currentTransactionIndex=0; updateTransactionCounter(); displayEditableFields(transactions[currentTransactionIndex]);} function saveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}} function updateTransactionCounter(){ const indicator=document.querySelector('.transaction-indicator'); const prevBtn=document.getElementById('prevTransaction'); const nextBtn=document.getElementById('nextTransaction'); if (transactions.length >0){ indicator.textContent=`${currentTransactionIndex + 1} of ${transactions.length}`; prevBtn.disabled=currentTransactionIndex===0; nextBtn.disabled=currentTransactionIndex===transactions.length - 1;} else{ indicator.textContent='No Transactions'; prevBtn.disabled=true; nextBtn.disabled=true;}} function navigateTransaction(direction){ const newIndex=currentTransactionIndex + direction; if (newIndex >=0 && newIndex < transactions.length){ currentTransactionIndex=newIndex; displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();}} function storeEditTrainingData(field, oldValue, newValue, transaction){ try{ const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const key=transaction["Purchase Description"].toLowerCase(); if (!trainingData[key]){ trainingData[key]={ corrections:{}, frequency: 0};} if (!trainingData[key].corrections[field]){ trainingData[key].corrections[field]=[];} trainingData[key].corrections[field].push({ from: oldValue, to: newValue, timestamp: new Date().toISOString()}); trainingData[key].frequency++; localStorage.setItem('editTrainingData', JSON.stringify(trainingData));} catch (e){ console.error('Error storing training data:', e);}} async function authorize(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();} function showConfirmation(){ const confirmation=document.querySelector('.submit-confirmation'); const transactionList=confirmation.querySelector('.transaction-list'); transactionList.innerHTML=transactions.map((transaction, index)=>` <div class="transaction-item"><strong>Transaction ${index + 1}:</strong><br>Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>Category: ${transaction["What's the Purchase Category"]}<br>Paid To: ${transaction["Where was the money payed to?"]}<br>Description: ${transaction["Purchase Description"]} </div>`).join(''); confirmation.classList.add('show');} function closeConfirmation(){ document.querySelector('.submit-confirmation').classList.remove('show');} async function confirmSubmit(){ closeConfirmation(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} async function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); TOKEN_MANAGEMENT.clearStoredToken(); return;} try{ TOKEN_MANAGEMENT.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} async function submitData(token){ showLoading(); try{ if (!transactions || transactions.length===0){ throw new Error('No transactions to submit');} // Submit each transaction for (const transaction of transactions){ if (!validateExpenseData(transaction)){ throw new Error('Invalid expense data');} // Learn from the transaction before submitting AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]});} await AI_SYSTEM.savePatterns(); showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length >1 ? 's' : ''}`); clearForm();} catch (error){ console.error('Submit Error:', error); showError( "Submission Failed", "Failed to submit transactions.", error.message );} finally{ hideLoading();}} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter();} function displayEditableFields(transaction){ if (!transaction){ document.getElementById("editableContainer").innerHTML=""; return;} const container=document.getElementById("editableContainer"); container.innerHTML=""; // Essential fields shown by default const essentialFields=[ { field: "Date of Transaction", fullWidth: false}, { field: "How much money? (Tsh)", fullWidth: false}, { field: "What's the Purchase Category", fullWidth: true}, { field: "Where was the money payed to?", fullWidth: true} ]; // Hidden fields in collapsible section const collapsibleFields=[ { field: "Where did the money come from?", fullWidth: false}, { field: "Purchase Description", fullWidth: true} ]; // Display essential fields essentialFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); container.appendChild(fieldDiv);}); // Add confidence and feedback section const confidenceSection=document.createElement("div"); confidenceSection.className="confidence-section"; confidenceSection.style.cssText=` background: var(--bg-input); border-radius: 8px; padding: 12px; margin: 12px 0; `; // Calculate comprehensive confidence score const confidenceScore=calculateConfidenceScore(transaction); // Add confidence display const confidenceDisplay=document.createElement("div"); confidenceDisplay.className="confidence-display"; confidenceDisplay.style.cssText=` display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; `; const confidenceLabel=document.createElement("span"); confidenceLabel.textContent="AI Confidence:"; confidenceLabel.style.color="var(--text-muted)"; const confidenceValue=document.createElement("span"); confidenceValue.textContent=`${confidenceScore}%`; confidenceValue.style.color=getConfidenceColor(confidenceScore); confidenceValue.style.fontWeight="bold"; confidenceDisplay.appendChild(confidenceLabel); confidenceDisplay.appendChild(confidenceValue); // Add feedback section right below confidence const feedbackDiv=document.createElement("div"); feedbackDiv.className="feedback-section"; feedbackDiv.style.cssText=` display: flex; align-items: center; gap: 10px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--bg-card); `; const feedbackText=document.createElement("span"); feedbackText.textContent="Was this prediction accurate?"; feedbackText.style.cssText=` color: var(--text-muted); font-size: 0.9em; `; const thumbsUp=document.createElement("button"); thumbsUp.innerHTML="👍"; thumbsUp.className="feedback-button"; thumbsUp.title="Yes, this prediction is accurate"; const thumbsDown=document.createElement("button"); thumbsDown.innerHTML="👎"; thumbsDown.className="feedback-button"; thumbsDown.title="No, this prediction needs correction"; thumbsUp.onclick=()=>handleFeedback(transaction, true); thumbsDown.onclick=()=>handleFeedback(transaction, false); feedbackDiv.appendChild(feedbackText); feedbackDiv.appendChild(thumbsUp); feedbackDiv.appendChild(thumbsDown); confidenceSection.appendChild(confidenceDisplay); confidenceSection.appendChild(feedbackDiv); container.appendChild(confidenceSection); // Add collapsible section for additional details const collapsibleTrigger=document.createElement("button"); collapsibleTrigger.className="collapsible-trigger"; collapsibleTrigger.textContent="Show More Details"; container.appendChild(collapsibleTrigger); const collapsibleContent=document.createElement("div"); collapsibleContent.className="collapsible-content"; collapsibleFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); collapsibleContent.appendChild(fieldDiv);}); container.appendChild(collapsibleContent); collapsibleTrigger.onclick=function(){ this.classList.toggle('expanded'); collapsibleContent.classList.toggle('show');};} function calculateConfidenceScore(transaction){ let baseConfidence=0; const description=transaction["Purchase Description"].toLowerCase(); // Check training data matches const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const historicalMatch=trainingData[description]; if (historicalMatch){ // Direct match in training data baseConfidence=90; // Adjust based on frequency baseConfidence +=Math.min(historicalMatch.frequency * 2, 5);} else{ // Calculate based on pattern matching const analysis=analyzeTextContext(description); baseConfidence=parseInt(analysis.confidence); // Check for partial matches in training data const words=description.split(/\s+/); let partialMatches=0; Object.keys(trainingData).forEach(key=>{ const keyWords=key.split(/\s+/); const commonWords=words.filter(word=>keyWords.includes(word)); if (commonWords.length >1){ partialMatches++;}}); // Adjust confidence based on partial matches if (partialMatches >0){ baseConfidence +=Math.min(partialMatches * 3, 10);}} // Adjust based on specific indicators if (description.includes('maid') && description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} if (description.includes('irene') && !description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} // Cap the confidence return Math.min(Math.round(baseConfidence), 95);} function getConfidenceColor(score){ if (score >=90) return '#4CAF50'; if (score >=75) return '#8BC34A'; if (score >=60) return '#FFC107'; return '#FF5722';} function handleFeedback(transaction, isPositive){ if (isPositive){ // Store as positive example in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); showSuccess("Thanks for the feedback! This will help improve future predictions.");} else{ // Show feedback form for correction showFeedbackForm(transaction);}} function showFeedbackForm(transaction){ const modal=document.createElement("div"); modal.className="edit-modal show"; modal.innerHTML=` <h3>What was incorrect?</h3><div class="feedback-form"><div class="feedback-options"><label><input type="checkbox" value="category">Category (${transaction["What's the Purchase Category"]}) </label><label><input type="checkbox" value="paidTo">Paid To (${transaction["Where was the money payed to?"]}) </label></div><div class="correction-fields" style="display: none;"><h4>Please provide the correct values:</h4><div id="correctionInputs"></div></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeFeedbackForm()">Cancel</button><button onclick="submitFeedback()">Submit</button></div>`; // Add styles const style=document.createElement("style"); style.textContent=` .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} `; document.head.appendChild(style); // Show modal document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); // Add event listeners const checkboxes=modal.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox=>{ checkbox.addEventListener('change', ()=>{ const correctionFields=modal.querySelector('.correction-fields'); const correctionInputs=modal.querySelector('#correctionInputs'); if ([...checkboxes].some(cb=>cb.checked)){ correctionFields.style.display='block'; correctionInputs.innerHTML=''; if (checkbox.value==='category' && checkbox.checked){ addCategorySelect(correctionInputs);} if (checkbox.value==='paidTo' && checkbox.checked){ addPaidToSelect(correctionInputs);}} else{ correctionFields.style.display='none';}});});} function addCategorySelect(container){ const select=document.createElement('select'); select.id='correctionCategory'; select.innerHTML=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}">${cat}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.style.marginBottom='10px'; wrapper.innerHTML='<label>Correct Category:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function addPaidToSelect(container){ const paidToOptions=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ]; const select=document.createElement('select'); select.id='correctionPaidTo'; select.innerHTML=paidToOptions.map(opt=>`<option value="${opt}">${opt}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.innerHTML='<label>Correct Paid To:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function closeFeedbackForm(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} function submitFeedback(){ const transaction=transactions[currentTransactionIndex]; const categorySelect=document.getElementById('correctionCategory'); const paidToSelect=document.getElementById('correctionPaidTo'); if (categorySelect){ transaction["What's the Purchase Category"]=categorySelect.value;} if (paidToSelect){ transaction["Where was the money payed to?"]=paidToSelect.value;} // Store correction in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); // Update display displayEditableFields(transaction); closeFeedbackForm(); showSuccess("Thank you for your feedback! This will help improve future predictions.");} function showLoading(){ utils.showElement('.loading-overlay');} function hideLoading(){ utils.hideElement('.loading-overlay');} function showError(title, message, details=''){ ErrorHandler.show(title, message, details);} function closeError(){ ErrorHandler.close();} function showSuccess(message){ SuccessHandler.show(message);} function updateUI(selector, content){ const element=utils.getElement(selector); if (element){ if (typeof content==='string'){ element.innerHTML=content;} else if (content instanceof Node){ element.innerHTML=''; element.appendChild(content);}}} const EventHandlers={ async handleSubmit(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();}, async handleSave(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge();} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}}, handleEdit(field, value){ ModalManager.showEditModal(field, value);}, handleSaveEdit(){ try{ const modal=utils.getElement(UI.selectors.editModal); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} ModalManager.closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}}}; async function initializeApp(){ try{ // Initialize managers and handlers first window.ModalManager=ModalManager; window.EventHandlers=EventHandlers; // Then set up event listeners setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus();} // Remove redundant submit confirmation section const submitConfirmation=utils.getElement('.submit-confirmation'); if (submitConfirmation){ submitConfirmation.remove();}} catch (error){ console.error('Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} if (document.readyState==='loading'){ document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);} else{ initializeApp();} // Make functions available globally Object.assign(window,{ closeError, closeEditModal, saveEdit, showEditModal, processInput, authorize, confirmSubmit, navigateTransaction, closeConfirmation}); class SpeechRecognitionManager{ constructor(){ this.recognition=null; this.isListening=false;} initialize(){ if ('webkitSpeechRecognition' in window){ this.recognition=new webkitSpeechRecognition(); this.recognition.continuous=false; this.recognition.interimResults=false; this.recognition.lang='en-US'; this.recognition.onresult=(event)=>{ const text=event.results[0][0].transcript; document.getElementById('inputText').value=text; processInput();}; this.recognition.onend=()=>{ this.isListening=false; this.updateButtonState();}; this.recognition.onerror=(event)=>{ console.error('Speech recognition error:', event.error); this.isListening=false; this.updateButtonState(); if (event.error==='not-allowed'){ showError( "Microphone Access Denied", "Please allow microphone access to use voice input." );}}; // Add voice input button this.addVoiceButton();}} addVoiceButton(){ const inputSection=document.querySelector('.input-section'); const existingButton=inputSection.querySelector('.voice-input-button'); if (existingButton){ existingButton.remove();} const voiceButton=document.createElement('button'); voiceButton.className='voice-input-button'; voiceButton.innerHTML='🎤'; voiceButton.onclick=()=>this.toggleRecognition(); inputSection.appendChild(voiceButton);} toggleRecognition(){ if (!this.recognition) return; if (this.isListening){ this.recognition.stop();} else{ try{ this.recognition.start(); this.isListening=true; this.updateButtonState();} catch (error){ console.error('Speech recognition error:', error); this.isListening=false; this.updateButtonState();}}} updateButtonState(){ const button=document.querySelector('.voice-input-button'); if (button){ button.style.background=this.isListening ? '#ff4444' : 'var(--primary-color)'; button.innerHTML=this.isListening ? '⏹' : '🎤';}}} function processInput(){ const inputText=document.getElementById("inputText").value; if (inputText.trim()===""){ document.getElementById("editableContainer").innerHTML=""; transactions=[]; updateTransactionCounter(); return;} const transactionTexts=inputText .split(/&&|(?:Also|also|ALSO)/) .map(text=>text.trim()) .filter(text=>text.length >0); transactions=transactionTexts.map(text=>{ const analysis=analyzeTextContext(text); return{ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text, "Where was the money payed to?": analysis.paidTo, "Confidance level": `${analysis.confidence}%`, editedFields: new Set()};}); currentTransactionIndex=0; updateTransactionCounter(); displayEditableFields(transactions[currentTransactionIndex]);} function saveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; // Validate input based on field type if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; // Mark transaction as edited if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); // Store training data for future predictions storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); // Refresh display displayEditableFields(transactions[currentTransactionIndex]); // Show success indicator showSuccess("Field updated successfully");} closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}} function updateTransactionCounter(){ const indicator=document.querySelector('.transaction-indicator'); const prevBtn=document.getElementById('prevTransaction'); const nextBtn=document.getElementById('nextTransaction'); if (transactions.length >0){ indicator.textContent=`${currentTransactionIndex + 1} of ${transactions.length}`; prevBtn.disabled=currentTransactionIndex===0; nextBtn.disabled=currentTransactionIndex===transactions.length - 1;} else{ indicator.textContent='No Transactions'; prevBtn.disabled=true; nextBtn.disabled=true;}} function navigateTransaction(direction){ const newIndex=currentTransactionIndex + direction; if (newIndex >=0 && newIndex < transactions.length){ currentTransactionIndex=newIndex; displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();}} function storeEditTrainingData(field, oldValue, newValue, transaction){ try{ const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const key=transaction["Purchase Description"].toLowerCase(); if (!trainingData[key]){ trainingData[key]={ corrections:{}, frequency: 0};} if (!trainingData[key].corrections[field]){ trainingData[key].corrections[field]=[];} trainingData[key].corrections[field].push({ from: oldValue, to: newValue, timestamp: new Date().toISOString()}); trainingData[key].frequency++; localStorage.setItem('editTrainingData', JSON.stringify(trainingData));} catch (e){ console.error('Error storing training data:', e);}} async function authorize(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();} function showConfirmation(){ const confirmation=document.querySelector('.submit-confirmation'); const transactionList=confirmation.querySelector('.transaction-list'); transactionList.innerHTML=transactions.map((transaction, index)=>` <div class="transaction-item"><strong>Transaction ${index + 1}:</strong><br>Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>Category: ${transaction["What's the Purchase Category"]}<br>Paid To: ${transaction["Where was the money payed to?"]}<br>Description: ${transaction["Purchase Description"]} </div>`).join(''); confirmation.classList.add('show');} function closeConfirmation(){ document.querySelector('.submit-confirmation').classList.remove('show');} async function confirmSubmit(){ closeConfirmation(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} async function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); TOKEN_MANAGEMENT.clearStoredToken(); return;} try{ TOKEN_MANAGEMENT.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} async function submitData(token){ showLoading(); try{ if (!transactions || transactions.length===0){ throw new Error('No transactions to submit');} // Submit each transaction for (const transaction of transactions){ if (!validateExpenseData(transaction)){ throw new Error('Invalid expense data');} // Learn from the transaction before submitting AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]});} await AI_SYSTEM.savePatterns(); showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length >1 ? 's' : ''}`); clearForm();} catch (error){ console.error('Submit Error:', error); showError( "Submission Failed", "Failed to submit transactions.", error.message );} finally{ hideLoading();}} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter();} function displayEditableFields(transaction){ if (!transaction){ document.getElementById("editableContainer").innerHTML=""; return;} const container=document.getElementById("editableContainer"); container.innerHTML=""; // Essential fields shown by default const essentialFields=[ { field: "Date of Transaction", fullWidth: false}, { field: "How much money? (Tsh)", fullWidth: false}, { field: "What's the Purchase Category", fullWidth: true}, { field: "Where was the money payed to?", fullWidth: true} ]; // Hidden fields in collapsible section const collapsibleFields=[ { field: "Where did the money come from?", fullWidth: false}, { field: "Purchase Description", fullWidth: true} ]; // Display essential fields essentialFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); container.appendChild(fieldDiv);}); // Add confidence and feedback section const confidenceSection=document.createElement("div"); confidenceSection.className="confidence-section"; confidenceSection.style.cssText=` background: var(--bg-input); border-radius: 8px; padding: 12px; margin: 12px 0; `; // Calculate comprehensive confidence score const confidenceScore=calculateConfidenceScore(transaction); // Add confidence display const confidenceDisplay=document.createElement("div"); confidenceDisplay.className="confidence-display"; confidenceDisplay.style.cssText=` display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; `; const confidenceLabel=document.createElement("span"); confidenceLabel.textContent="AI Confidence:"; confidenceLabel.style.color="var(--text-muted)"; const confidenceValue=document.createElement("span"); confidenceValue.textContent=`${confidenceScore}%`; confidenceValue.style.color=getConfidenceColor(confidenceScore); confidenceValue.style.fontWeight="bold"; confidenceDisplay.appendChild(confidenceLabel); confidenceDisplay.appendChild(confidenceValue); // Add feedback section right below confidence const feedbackDiv=document.createElement("div"); feedbackDiv.className="feedback-section"; feedbackDiv.style.cssText=` display: flex; align-items: center; gap: 10px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--bg-card); `; const feedbackText=document.createElement("span"); feedbackText.textContent="Was this prediction accurate?"; feedbackText.style.cssText=` color: var(--text-muted); font-size: 0.9em; `; const thumbsUp=document.createElement("button"); thumbsUp.innerHTML="👍"; thumbsUp.className="feedback-button"; thumbsUp.title="Yes, this prediction is accurate"; const thumbsDown=document.createElement("button"); thumbsDown.innerHTML="👎"; thumbsDown.className="feedback-button"; thumbsDown.title="No, this prediction needs correction"; thumbsUp.onclick=()=>handleFeedback(transaction, true); thumbsDown.onclick=()=>handleFeedback(transaction, false); feedbackDiv.appendChild(feedbackText); feedbackDiv.appendChild(thumbsUp); feedbackDiv.appendChild(thumbsDown); confidenceSection.appendChild(confidenceDisplay); confidenceSection.appendChild(feedbackDiv); container.appendChild(confidenceSection); // Add collapsible section for additional details const collapsibleTrigger=document.createElement("button"); collapsibleTrigger.className="collapsible-trigger"; collapsibleTrigger.textContent="Show More Details"; container.appendChild(collapsibleTrigger); const collapsibleContent=document.createElement("div"); collapsibleContent.className="collapsible-content"; collapsibleFields.forEach(({ field, fullWidth})=>{ const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>showEditModal(field, transaction[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=transaction[field] || ''; if (transaction.editedFields?.has(field)){ fieldDiv.classList.add('edited'); const indicator=document.createElement("span"); indicator.className="edited-indicator"; indicator.textContent="✓"; fieldDiv.appendChild(indicator);} fieldDiv.appendChild(label); fieldDiv.appendChild(value); collapsibleContent.appendChild(fieldDiv);}); container.appendChild(collapsibleContent); collapsibleTrigger.onclick=function(){ this.classList.toggle('expanded'); collapsibleContent.classList.toggle('show');};} function calculateConfidenceScore(transaction){ let baseConfidence=0; const description=transaction["Purchase Description"].toLowerCase(); // Check training data matches const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const historicalMatch=trainingData[description]; if (historicalMatch){ // Direct match in training data baseConfidence=90; // Adjust based on frequency baseConfidence +=Math.min(historicalMatch.frequency * 2, 5);} else{ // Calculate based on pattern matching const analysis=analyzeTextContext(description); baseConfidence=parseInt(analysis.confidence); // Check for partial matches in training data const words=description.split(/\s+/); let partialMatches=0; Object.keys(trainingData).forEach(key=>{ const keyWords=key.split(/\s+/); const commonWords=words.filter(word=>keyWords.includes(word)); if (commonWords.length >1){ partialMatches++;}}); // Adjust confidence based on partial matches if (partialMatches >0){ baseConfidence +=Math.min(partialMatches * 3, 10);}} // Adjust based on specific indicators if (description.includes('maid') && description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} if (description.includes('irene') && !description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} // Cap the confidence return Math.min(Math.round(baseConfidence), 95);} function getConfidenceColor(score){ if (score >=90) return '#4CAF50'; if (score >=75) return '#8BC34A'; if (score >=60) return '#FFC107'; return '#FF5722';} function handleFeedback(transaction, isPositive){ if (isPositive){ // Store as positive example in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); showSuccess("Thanks for the feedback! This will help improve future predictions.");} else{ // Show feedback form for correction showFeedbackForm(transaction);}} function showFeedbackForm(transaction){ const modal=document.createElement("div"); modal.className="edit-modal show"; modal.innerHTML=` <h3>What was incorrect?</h3><div class="feedback-form"><div class="feedback-options"><label><input type="checkbox" value="category">Category (${transaction["What's the Purchase Category"]}) </label><label><input type="checkbox" value="paidTo">Paid To (${transaction["Where was the money payed to?"]}) </label></div><div class="correction-fields" style="display: none;"><h4>Please provide the correct values:</h4><div id="correctionInputs"></div></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeFeedbackForm()">Cancel</button><button onclick="submitFeedback()">Submit</button></div>`; // Add styles const style=document.createElement("style"); style.textContent=` .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} `; document.head.appendChild(style); // Show modal document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); // Add event listeners const checkboxes=modal.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox=>{ checkbox.addEventListener('change', ()=>{ const correctionFields=modal.querySelector('.correction-fields'); const correctionInputs=modal.querySelector('#correctionInputs'); if ([...checkboxes].some(cb=>cb.checked)){ correctionFields.style.display='block'; correctionInputs.innerHTML=''; if (checkbox.value==='category' && checkbox.checked){ addCategorySelect(correctionInputs);} if (checkbox.value==='paidTo' && checkbox.checked){ addPaidToSelect(correctionInputs);}} else{ correctionFields.style.display='none';}});});} function addCategorySelect(container){ const select=document.createElement('select'); select.id='correctionCategory'; select.innerHTML=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}">${cat}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.style.marginBottom='10px'; wrapper.innerHTML='<label>Correct Category:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function addPaidToSelect(container){ const paidToOptions=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ]; const select=document.createElement('select'); select.id='correctionPaidTo'; select.innerHTML=paidToOptions.map(opt=>`<option value="${opt}">${opt}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.innerHTML='<label>Correct Paid To:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function closeFeedbackForm(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} function submitFeedback(){ const transaction=transactions[currentTransactionIndex]; const categorySelect=document.getElementById('correctionCategory'); const paidToSelect=document.getElementById('correctionPaidTo'); if (categorySelect){ transaction["What's the Purchase Category"]=categorySelect.value;} if (paidToSelect){ transaction["Where was the money payed to?"]=paidToSelect.value;} // Store correction in training data AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); // Update display displayEditableFields(transaction); closeFeedbackForm(); showSuccess("Thank you for your feedback! This will help improve future predictions.");} function showLoading(){ utils.showElement('.loading-overlay');} function hideLoading(){ utils.hideElement('.loading-overlay');} function showError(title, message, details=''){ ErrorHandler.show(title, message, details);} function closeError(){ ErrorHandler.close();} function showSuccess(message){ SuccessHandler.show(message);} function updateUI(selector, content){ const element=utils.getElement(selector); if (element){ if (typeof content==='string'){ element.innerHTML=content;} else if (content instanceof Node){ element.innerHTML=''; element.appendChild(content);}}} </script><script src="https://apis.google.com/js/api.js" defer></script><script src="https://accounts.google.com/gsi/client" defer></script></body></html>