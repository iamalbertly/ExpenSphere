<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://apis.google.com https://accounts.google.com https://sheets.googleapis.com https://*.googleapis.com https://raw.githubusercontent.com; connect-src 'self' ws://127.0.0.1:* wss://127.0.0.1:* ws://localhost:* wss://localhost:* http://127.0.0.1:* http://localhost:* https://sheets.googleapis.com https://accounts.google.com https://apis.googleapis.com https://*.googleapis.com https://raw.githubusercontent.com https://*.githubusercontent.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; frame-src https://accounts.google.com"><title>Expense Tracker v0.0.23</title><style>:root{ --primary-color: #f5a623; --bg-dark: #1e1e2e; --bg-card: #28293d; --bg-input: #33344b; --text-light: #f5f5f5; --text-muted: #8e8ea0; --spacing-unit: clamp(8px, 2vw, 20px);} body{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: var(--bg-dark); color: var(--text-light); margin: 0; padding: 0; min-height: 100vh; display: flex; flex-direction: column;} .container{ margin: var(--spacing-unit) auto; width: min(95%, 600px); background-color: var(--bg-card); padding: var(--spacing-unit); border-radius: 10px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); flex: 1; display: flex; flex-direction: column; gap: var(--spacing-unit);} h1{ text-align: center; color: var(--primary-color); margin: 0 0 20px 0; padding: 20px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.1); position: sticky; top: 0; background: var(--bg-card); z-index: 10;} .version{ font-size: 0.6em; opacity: 0.8;} .results-section{ order: -1; display: flex; flex-direction: column; gap: var(--spacing-unit); min-height: 200px; max-height: 60vh; overflow-y: auto;} .transaction-navigation{ display: grid; grid-template-columns: auto 1fr auto; gap: 10px; align-items: center; justify-content: center; margin-bottom: 5px;} .nav-button{ background: var(--bg-input); border: none; color: var(--text-light); padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 14px; width: auto; margin: 0;} .transaction-indicator{ text-align: center; color: var(--primary-color); font-size: 14px;} .editable-container{ display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; padding: 12px; background: var(--bg-input); border-radius: 8px; margin-bottom: 8px; max-height: calc(100vh - 250px); overflow-y: auto;} .editable-field{ background: var(--bg-card); padding: 12px; border-radius: 6px; cursor: pointer; transition: transform 0.2s ease, background-color 0.2s ease;} .editable-field.full-width{ grid-column: 1 / -1;} .editable-label{ font-size: 12px; color: var(--text-muted); margin-bottom: 4px; font-weight: 500;} .editable-value{ font-size: 14px; line-height: 1.4; word-break: break-word; color: var(--text-light);} .input-section{ position: sticky; bottom: 0; background: var(--bg-card); padding: var(--spacing-unit); z-index: 10; display: grid; grid-template-columns: 1fr auto; gap: 8px; box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);} .action-buttons{ display: flex; gap: 8px; align-items: flex-end;} .submit-button, .save-button{ height: 40px; padding: 0 16px; border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; transition: transform 0.2s, background-color 0.2s; white-space: nowrap; display: flex; align-items: center; gap: 4px;} .submit-button{ background: var(--primary-color); color: var(--bg-dark);} .save-button{ background: var(--bg-input); color: var(--text-light);} .submit-button:hover, .save-button:hover{ transform: translateY(-1px);} .submit-button:hover{ background: #d48821;} .save-button:hover{ background: #444561;} @media screen and (max-width: 768px){ .input-section{ grid-template-columns: 1fr; gap: 12px; padding: 12px;} .action-buttons{ display: grid; grid-template-columns: 1fr 1fr; gap: 8px;} .submit-button, .save-button{ width: 100%; justify-content: center;}} .pending-badge{ position: absolute; top: -8px; right: -8px; background: var(--primary-color); color: var(--bg-dark); border-radius: 12px; padding: 2px 6px; font-size: 12px; font-weight: bold;} .loading-overlay{ position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(30, 30, 46, 0.9); backdrop-filter: blur(4px); display: none; justify-content: center; align-items: center; z-index: 2000;} .loading-spinner{ width: 40px; height: 40px; border: 3px solid var(--bg-input); border-top: 3px solid var(--primary-color); border-radius: 50%; animation: spin 0.8s cubic-bezier(0.4, 0, 0.2, 1) infinite;} @keyframes spin{ 0%{ transform: rotate(0deg);} 100%{ transform: rotate(360deg);}} .error-notification{ display: none; position: fixed; top: 0; left: 0; right: 0; background: linear-gradient(to right, #ff4444, #ff6b6b); color: white; padding: 15px; z-index: 1001; animation: slideDown 0.5s ease-out; box-shadow: 0 4px 15px rgba(255, 68, 68, 0.3); transform: translateY(-100%); transition: transform 0.3s ease;} .error-notification.show{ display: flex; justify-content: space-between; align-items: flex-start; transform: translateY(0);} .error-content{ flex-grow: 1; margin-right: 20px;} .error-title{ font-weight: bold; margin-bottom: 5px; font-size: 16px;} .error-message{ font-size: 14px; line-height: 1.4;} .error-close{ background: none; border: none; color: white; font-size: 24px; cursor: pointer; padding: 0 5px; opacity: 0.8; transition: opacity 0.2s;} .error-close:hover{ opacity: 1;} @media screen and (max-width: 768px){ .container{ padding: var(--spacing-unit); gap: var(--spacing-unit); height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));} .input-section{ position: sticky; bottom: env(safe-area-inset-bottom); margin-bottom: -var(--spacing-unit); padding: var(--spacing-unit); background: var(--bg-card); border-top: 1px solid rgba(255, 255, 255, 0.1); box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);} .results-section{ flex: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; margin: 0 -var(--spacing-unit); padding: 0 var(--spacing-unit);} .error-notification{ padding-top: calc(env(safe-area-inset-top) + 15px);}} .success-notification{ background: linear-gradient(to right, #4CAF50, #45a049); box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3); border-radius: 8px;} .edit-overlay{ position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.7); backdrop-filter: blur(4px); z-index: 1002; display: none; opacity: 0; transition: opacity 0.3s ease;} .edit-overlay.show{ display: flex; justify-content: center; align-items: center; opacity: 1;} .edit-modal{ background: var(--bg-card); border-radius: 12px; padding: 20px; width: 90%; max-width: 400px; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4); transform: translateY(-20px); opacity: 0; transition: transform 0.3s ease, opacity 0.3s ease; display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1003;} .edit-modal.show{ display: block; transform: translate(-50%, -50%); opacity: 1;} .edit-modal h3{ margin: 0 0 15px 0; color: var(--text-light);} .edit-modal-content{ margin-bottom: 20px;} .edit-modal-content input, .edit-modal-content select{ width: 100%; padding: 10px; border: 1px solid var(--bg-input); border-radius: 6px; background: var(--bg-input); color: var(--text-light); font-size: 16px;} .edit-modal-buttons{ display: flex; gap: 10px;} .edit-modal-buttons button{ flex: 1; padding: 10px; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 500; transition: background-color 0.2s;} .edit-modal-buttons button:not(.cancel){ background: var(--primary-color); color: var(--bg-dark);} .edit-modal-buttons button.cancel{ background: var(--bg-input); color: var(--text-light);} .compact-field{ cursor: pointer; position: relative;} .compact-field:hover::after{ content: '✎'; position: absolute; right: 5px; top: 50%; transform: translateY(-50%); color: #f5a623; font-size: 14px;} .compact-field.edited::before{ content: '✓'; position: absolute; left: -15px; top: 50%; transform: translateY(-50%); color: #4CAF50; font-size: 12px;} .edited-indicator{ position: absolute; right: -25px; top: 50%; transform: translateY(-50%); color: #4CAF50; font-size: 12px; font-weight: bold; opacity: 0; transition: opacity 0.3s;} .edited .edited-indicator{ opacity: 1;} .compact-field{ position: relative; padding: 8px; border-radius: 6px; transition: background-color 0.2s;} .compact-field:hover{ background-color: #3f4060;} .compact-field.edited{ padding-left: 25px;} .compact-field.edited::before{ left: 5px;} @media screen and (max-width: 768px){ .edit-modal{ width: 95%; max-width: none; margin: 10px;} .edit-modal .editable-input, .edit-modal .editable-select{ font-size: 16px; padding: 12px;} .edit-modal-buttons button{ padding: 12px; font-size: 16px;}} @media (hover: none){ .transaction-navigation::after{ content: 'Swipe to navigate'; position: absolute; bottom: -20px; left: 50%; transform: translateX(-50%); font-size: 12px; color: #8e8ea0; opacity: 0.7;}} .title-section{ position: sticky; top: 0; background: var(--bg-card); padding: var(--spacing-unit) 0; margin: calc(var(--spacing-unit) * -1) calc(var(--spacing-unit) * -1) 0; border-bottom: 1px solid rgba(255, 255, 255, 0.1); z-index: 10;} .collapsible-trigger{ background: none; border: none; color: var(--primary-color); cursor: pointer; padding: 8px; width: 100%; text-align: left; font-size: 14px; display: flex; align-items: center; gap: 8px; margin-top: 8px;} .collapsible-trigger::before{ content: '+'; font-size: 18px; font-weight: bold;} .collapsible-trigger.expanded::before{ content: '-';} .collapsible-content{ display: none; padding-top: 8px;} .collapsible-content.show{ display: block;} .confidence-display{ color: var(--text-muted); font-size: 12px; text-align: right; padding: 4px 8px; background: var(--bg-input); border-radius: 4px; margin-top: 4px;} .feedback-section{ display: flex; align-items: center; gap: 10px; padding: 10px; background: var(--bg-input); border-radius: 8px; margin-bottom: 12px;} .feedback-button{ background: none; border: none; font-size: 20px; cursor: pointer; opacity: 0.7; transition: opacity 0.2s;} .feedback-button:hover{ opacity: 1;} .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} .submit-options{ display: flex; flex-direction: column; gap: 12px; margin: 15px 0;} .submit-option{ display: flex; flex-direction: column; align-items: flex-start; padding: 12px; background: var(--bg-input); border: none; border-radius: 8px; color: var(--text-light); cursor: pointer; transition: background 0.2s, transform 0.2s; width: 100%; text-align: left;} .submit-option:hover{ background: var(--primary-color); color: var(--bg-dark); transform: translateY(-1px);} .submit-option small{ color: var(--text-muted); font-size: 0.8em; margin-top: 4px;} .submit-option:hover small{ color: var(--bg-dark);} .pending-transactions{ margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--bg-input);} .pending-transactions h4{ color: var(--text-muted); font-size: 0.9em; margin: 0 0 8px 0;} .view-pending{ width: 100%; padding: 10px; background: var(--bg-input); border: none; border-radius: 8px; color: var(--text-light); cursor: pointer; transition: background 0.2s;} .view-pending:hover{ background: var(--primary-color); color: var(--bg-dark);} .pending-list{ display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px; max-height: 60vh; overflow-y: auto; padding: 4px; margin: 15px 0;} .pending-item{ background: var(--bg-input); border-radius: 8px; padding: 12px; display: flex; flex-direction: column; gap: 8px;} .pending-info{ margin-bottom: 8px;} .pending-details{ display: flex; flex-wrap: wrap; gap: 8px; margin-top: 4px; font-size: 0.9em; color: var(--text-muted);} .pending-actions{ display: flex; gap: 8px;} .pending-actions button{ padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em; transition: transform 0.2s, opacity 0.2s;} .pending-actions button:hover{ transform: translateY(-1px); opacity: 0.9;} .submit-one{ background: var(--primary-color); color: var(--bg-dark);} .remove-one{ background: var(--bg-card); color: var(--text-light);} .submit-all{ background: var(--primary-color); color: var(--bg-dark); padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; transition: transform 0.2s, opacity 0.2s;} .submit-all:hover{ transform: translateY(-1px); opacity: 0.9;} @media screen and (max-width: 768px){ .pending-list{ max-height: 70vh;} .pending-actions{ flex-direction: column;} .pending-actions button{ width: 100%; padding: 8px;}} .input-section textarea{ width: 100%; padding: 12px; background: var(--bg-input); color: var(--text-light); border: none; border-radius: 8px; resize: vertical; min-height: 60px; font-family: inherit; font-size: 14px; line-height: 1.4;} .input-section textarea:focus{ outline: 1px solid var(--primary-color); box-shadow: 0 0 0 2px rgba(245, 166, 35, 0.2);} .input-section textarea::placeholder{ color: var(--text-muted);} </style></head><body><div class="loading-overlay"><div class="loading-spinner"></div></div><div class="error-notification"><div class="error-content"><div class="error-title"></div><div class="error-message"></div></div><button class="error-close" onclick="closeError()">×</button></div><div class="container"><h1 style="margin-bottom: 20px;">ExpenSphere <span class="version">v0.0.29</span></h1><div class="results-section"><div class="transaction-navigation"><button class="nav-button" id="prevTransaction" disabled onclick="navigateTransaction(-1)">← Previous</button><span class="transaction-indicator">1 of 1</span><button class="nav-button" id="nextTransaction" disabled onclick="navigateTransaction(1)">Next →</button></div><div class="editable-container" id="editableContainer"></div></div><div class="input-section"><textarea id="inputText" placeholder="Type your expense description and press Enter... (Use && or 'Also' for multiple transactions)" rows="3" style="width: 100%; padding: 10px; background: var(--bg-input); color: var(--text-light); border: none; border-radius: 8px; resize: vertical;"></textarea><div class="action-buttons"><button class="submit-button" onclick="EventHandlers.handleSubmit()">Submit Online</button><button class="save-button" onclick="EventHandlers.handleSave()">Save for Later</button></div></div></div><div class="edit-overlay"></div><div class="edit-modal"><h3>Edit Field</h3><div class="edit-modal-content"></div><div class="edit-modal-buttons"><button class="cancel" onclick="window.closeEditModal()">Cancel</button><button onclick="window.saveEdit()">Save</button></div></div><div class="submit-confirmation"><h3>Confirm Transactions</h3><div class="transaction-list"></div><div class="confirmation-buttons"><button class="cancel" onclick="closeConfirmation()">Cancel</button><button onclick="submitOnline()">Submit Online</button><button onclick="saveForLater()">Save for Later</button></div></div><script type="module">import config from './config.js'; window.CLIENT_ID=config.clientId; </script><script>window.closeEditModal=function (){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.classList.remove('show'); if (overlay) overlay.classList.remove('show'); window.currentEditField=null;}; window.closeError=function (){ document.querySelector('.error-notification')?.classList.remove('show');}; window.saveEdit=function (){ if (window.EventHandlers){ window.EventHandlers.handleSaveEdit();}}; window.showEditModal=function (field, value){ if (window.ModalManager){ window.ModalManager.showEditModal(field, value);}}; function processInput(){ console.log('🔄 processInput called'); const inputText=document.getElementById("inputText").value; console.log('📝 Input text:', inputText); try{ if (!inputText.trim()){ console.log('⚠️ Input is empty, clearing display'); document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter(); return;} const transactionTexts=inputText.split(/\s*(?:&&|Also)\s*/i); console.log('📑 Split into transactions:', transactionTexts); transactions=[]; currentTransactionIndex=0; transactionTexts.forEach((text, index)=>{ if (!text.trim()) return; console.log(`\n🔍 Processing transaction ${index + 1}:`, text.trim()); const analysis=analyzeTextContext(text.trim()); console.log('🤖 AI Analysis result:', analysis); let paidTo=determinePaidTo(text.trim(), analysis.category); console.log('👤 Determined Paid To:', paidTo); const transaction={ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text.trim(), "Where was the money payed to?": paidTo, "Confidence level": `${analysis.confidence}%`}; console.log('📊 Created transaction:', transaction); transactions.push(transaction);}); console.log(`\n✅ Total transactions processed: ${transactions.length}`); if (transactions.length >0){ console.log('🎯 Displaying first transaction:', transactions[currentTransactionIndex]); displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();} else{ console.log('⚠️ No transactions to display');}} catch (error){ console.error('❌ Process Input Error:', error); document.getElementById("editableContainer").innerHTML=`<div style="color: var(--text-muted); padding: 20px; text-align: center;">Error processing input: ${error.message} </div>`;}} window.processInput=processInput; function setupEventListeners(){ console.log('🎯 Setting up event listeners'); const inputTextArea=document.querySelector('#inputText'); if (!inputTextArea){ console.error('❌ Input textarea not found'); return;} console.log('✅ Found input textarea:', inputTextArea); let debounceTimeout=null; inputTextArea.addEventListener('input', (event)=>{ console.log('📝 Input event triggered:', event.target.value); if (debounceTimeout){ clearTimeout(debounceTimeout);} debounceTimeout=setTimeout(()=>{ console.log('⏱️ Debounce timeout triggered, calling processInput'); processInput();}, 100);}); inputTextArea.addEventListener('keydown', event=>{ console.log('⌨️ Keydown event:', event.key); if (event.key==='Enter' && !event.shiftKey){ event.preventDefault(); if (debounceTimeout){ clearTimeout(debounceTimeout);} processInput(); if (transactions.length >0){ saveForLater();}}}); document.querySelector('.container').addEventListener('click', event=>{ console.log('🖱️ Container clicked'); const isInteractive=event.target.closest('input, select, button, .editable-field, .compact-field, .edit-modal'); if (!isInteractive){ inputTextArea.focus();}}); document.querySelector('.error-close')?.addEventListener('click', closeError); document.querySelector('.edit-overlay')?.addEventListener('click', ModalManager.closeModal.bind(ModalManager)); console.log('✅ All event listeners set up successfully');} window.generatedData=null; window.tokenClient=null; window.transactions=[]; window.currentTransactionIndex=0; window.currentEditField=null; const ENV={ isProd: window.location.hostname !=='localhost', get apiBaseUrl(){ return this.isProd ? 'https://sheets.googleapis.com/v4/' : 'http://localhost:3000/api/';}}; const VERSION={ major: 0, minor: 0, patch: 25, buildDate: '2024-03-19', toString(){ return `${this.major}.${this.minor}.${this.patch}`;}}; const SCOPES="https://www.googleapis.com/auth/spreadsheets"; const SPREADSHEET_ID="__SPREADSHEET_ID__"; const FETCH_TIMEOUT=30000; const EVENTS={ INPUT: 'input', KEYDOWN: 'keydown', LOAD: 'load', DOMCONTENTLOADED: 'DOMContentLoaded'}; const STORAGE_KEYS={ PENDING_TRANSACTIONS: 'expenseSphere_pendingTransactions', TRAINING_DATA: 'editTrainingData', AI_PATTERNS: 'aiPatterns', HISTORICAL_TRANSACTIONS: 'historicalTransactions'}; const UI={ selectors:{ inputText: '#inputText', editableContainer: '#editableContainer', editModal: '.edit-modal', editOverlay: '.edit-overlay', saveButton: '.save-button', submitButton: '.submit-button', transactionIndicator: '.transaction-indicator', prevButton: '#prevTransaction', nextButton: '#nextTransaction'}, classes:{ show: 'show', edited: 'edited', expanded: 'expanded'}}; const TOKEN_MANAGEMENT={ async isTokenValid(token){ if (!token) return false; try{ const response=await fetchWithTimeout( `${ENV.apiBaseUrl}spreadsheets/${SPREADSHEET_ID}/values/ExpenseResults!A1`, { headers:{ Authorization: `Bearer ${token}`},} ); return response.ok;} catch{ return false;}}, storeToken(token){ try{ localStorage.setItem('expenseTrackerToken', token); localStorage.setItem('tokenTimestamp', Date.now().toString());} catch (e){ console.error('Error storing token:', e);}}, getStoredToken(){ try{ const token=localStorage.getItem('expenseTrackerToken'); const timestamp=parseInt(localStorage.getItem('tokenTimestamp'), 10); if (token && timestamp && (Date.now() - timestamp < 3600000)){ return token;}} catch (e){ console.error('Error getting token:', e);} return null;}, clearStoredToken(){ try{ localStorage.removeItem('expenseTrackerToken'); localStorage.removeItem('tokenTimestamp');} catch (e){ console.error('Error clearing token:', e);}}}; const utils={ async fetchWithTimeout(url, options={}){ const controller=new AbortController(); const timeoutId=setTimeout(()=>controller.abort(), FETCH_TIMEOUT); try{ const response=await fetch(url,{ ...options, signal: controller.signal}); clearTimeout(timeoutId); return response;} catch (error){ clearTimeout(timeoutId); throw error.name==='AbortError' ? new Error('Request timed out') : error;}}, getElement(selector){ return document.querySelector(selector);}, createElement(tag, className, innerHTML=''){ const element=document.createElement(tag); if (className) element.className=className; if (innerHTML) element.innerHTML=innerHTML; return element;}, showElement(element){ if (typeof element==='string'){ element=this.getElement(element);} element?.classList.add(UI.classes.show);}, hideElement(element){ if (typeof element==='string'){ element=this.getElement(element);} element?.classList.remove(UI.classes.show);}}; const ErrorHandler={ show(title, message, details=''){ const notification=utils.getElement('.error-notification'); if (!notification) return; const titleElement=notification.querySelector('.error-title'); const messageElement=notification.querySelector('.error-message'); if (titleElement && messageElement){ titleElement.textContent=title; messageElement.innerHTML=` <p>${message}</p>${details ? `<p><strong>Details:</strong>${details}</p>` : ''} `; utils.showElement(notification); setTimeout(()=>utils.hideElement(notification), 5000);}}, close(){ utils.hideElement('.error-notification');}}; const SuccessHandler={ show(message){ const existingNotification=utils.getElement('.success-notification'); if (existingNotification){ existingNotification.remove();} const notification=utils.createElement('div', 'success-notification show'); notification.textContent=message; document.body.appendChild(notification); setTimeout(()=>notification.remove(), 3000);}}; const PURCHASE_CATEGORIES=[ "Groceries & Household", "Gift to Family & Friends", "Petrol & Transport", "Medical & Medicine", "Utilities & Bills", "Eating Out & Entertainment" ]; const OfflineStorage={ savePendingTransaction(transaction){ try{ const pending=this.getPendingTransactions(); pending.push({ ...transaction, savedAt: new Date().toISOString(), id: Date.now().toString()}); localStorage.setItem(STORAGE_KEYS.PENDING_TRANSACTIONS, JSON.stringify(pending)); return true;} catch (error){ console.error('Error saving pending transaction:', error); return false;}}, getPendingTransactions(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEYS.PENDING_TRANSACTIONS) || '[]');} catch (error){ console.error('Error getting pending transactions:', error); return [];}}, removePendingTransaction(id){ try{ const pending=this.getPendingTransactions(); const filtered=pending.filter(t=>t.id !==id); localStorage.setItem(STORAGE_KEYS.PENDING_TRANSACTIONS, JSON.stringify(filtered)); return true;} catch (error){ console.error('Error removing pending transaction:', error); return false;}}, clearPendingTransactions(){ try{ localStorage.setItem(STORAGE_KEYS.PENDING_TRANSACTIONS, '[]'); return true;} catch (error){ console.error('Error clearing pending transactions:', error); return false;}}}; function showSubmitOptions(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} const pendingCount=OfflineStorage.getPendingTransactions().length; const modal=document.createElement('div'); modal.className='edit-modal show'; modal.innerHTML=` <h3>Submit Options</h3><div class="submit-options"><button onclick="submitOnline()" class="submit-option"><span>📤 Submit Now</span><small>Submit directly to Google Sheets</small></button><button onclick="saveForLater()" class="submit-option"><span>💾 Save for Later</span><small>Store locally and submit when online</small></button>${pendingCount >0 ? ` <div class="pending-transactions"><h4>Pending Transactions</h4><button onclick="showPendingTransactions()" class="view-pending"><span>📋 View Saved (${pendingCount})</span></button></div>` : ''} </div><div class="edit-modal-buttons"><button class="cancel" onclick="closeSubmitOptions()">Cancel</button></div>`; document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show');} function closeSubmitOptions(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} async function submitOnline(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} try{ showLoading(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ await submitData(transactions); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} catch (error){ console.error('Submit Error:', error); showError("Submit Failed", "Failed to submit transactions. Please try again.");} finally{ hideLoading();}} async function saveForLater(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge();} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}} function updatePendingBadge(){ const pendingCount=OfflineStorage.getPendingTransactions().length; const saveButton=document.querySelector('.save-button'); const existingBadge=saveButton.querySelector('.pending-badge'); if (existingBadge){ existingBadge.remove();} if (pendingCount >0){ const badge=document.createElement('span'); badge.className='pending-badge'; badge.textContent=pendingCount; badge.title=`${pendingCount} transaction${pendingCount >1 ? 's' : ''} saved for later`; saveButton.style.position='relative'; saveButton.appendChild(badge);}} async function initializeApp(){ console.log('🚀 Initializing application'); try{ window.ModalManager=ModalManager; window.EventHandlers=EventHandlers; setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus(); console.log('✅ Input textarea focused');} console.log('✅ Application initialized successfully');} catch (error){ console.error('❌ Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} function setupTouchNavigation(){ const container=document.querySelector('.container'); let touchStartX=0; let touchEndX=0; container.addEventListener('touchstart', e=>{ touchStartX=e.changedTouches[0].screenX;},{ passive: true}); container.addEventListener('touchend', e=>{ touchEndX=e.changedTouches[0].screenX; handleSwipe();},{ passive: true}); function handleSwipe(){ const SWIPE_THRESHOLD=50; const swipeDistance=touchEndX - touchStartX; if (Math.abs(swipeDistance) >SWIPE_THRESHOLD){ if (swipeDistance >0 && currentTransactionIndex >0){ navigateTransaction(-1);} else if (swipeDistance < 0 && currentTransactionIndex < transactions.length - 1){ navigateTransaction(1);}}}} function validateExpenseData(data){ try{ const required=[ "Date of Transaction", "Where did the money come from?", "How much money? (Tsh)", "What's the Purchase Category", "Purchase Description", "Where was the money payed to?" ]; const missingFields=required.filter(field=>{ const value=data[field]; return value===undefined || value===null || value.toString().trim()==='';}); if (missingFields.length >0){ throw new Error(`Missing required fields: ${missingFields.join(', ')}`);} if (isNaN(parseFloat(data["How much money? (Tsh)"]))){ throw new Error('Invalid amount value');} return true;} catch (error){ console.error('Validation error:', error); showError('Validation Error', error.message); return false;}} function storeTrainingPatterns(patterns){ try{ const serializedPatterns=JSON.stringify(patterns, (key, value)=>{ if (value instanceof Set){ return Array.from(value);} return value;}); localStorage.setItem('expensePatterns', serializedPatterns);} catch (e){ console.error('Error storing patterns:', e); showError('Storage Error', 'Failed to store training patterns');}} function loadTrainingPatterns(){ try{ const stored=localStorage.getItem('expensePatterns'); if (!stored) return null; return JSON.parse(stored, (key, value)=>{ if (key==='keywords' && Array.isArray(value)){ return new Set(value);} return value;});} catch (e){ console.error('Error loading patterns:', e); showError('Loading Error', 'Failed to load training patterns'); return null;}} function setupEventListeners(){ console.log('🎯 Setting up event listeners'); const inputTextArea=document.querySelector('#inputText'); if (!inputTextArea){ console.error('❌ Input textarea not found'); return;} console.log('✅ Found input textarea:', inputTextArea); let debounceTimeout=null; inputTextArea.addEventListener('input', (event)=>{ console.log('📝 Input event triggered:', event.target.value); if (debounceTimeout){ clearTimeout(debounceTimeout);} debounceTimeout=setTimeout(()=>{ console.log('⏱️ Debounce timeout triggered, calling processInput'); processInput();}, 100);}); inputTextArea.addEventListener('keydown', event=>{ console.log('⌨️ Keydown event:', event.key); if (event.key==='Enter' && !event.shiftKey){ event.preventDefault(); if (debounceTimeout){ clearTimeout(debounceTimeout);} processInput(); if (transactions.length >0){ saveForLater();}}}); document.querySelector('.container').addEventListener('click', event=>{ console.log('🖱️ Container clicked'); const isInteractive=event.target.closest('input, select, button, .editable-field, .compact-field, .edit-modal'); if (!isInteractive){ inputTextArea.focus();}}); document.querySelector('.error-close')?.addEventListener('click', closeError); document.querySelector('.edit-overlay')?.addEventListener('click', ModalManager.closeModal.bind(ModalManager)); console.log('✅ All event listeners set up successfully');} function processInput(){ console.log('🔄 processInput called'); const inputText=document.getElementById("inputText").value; console.log('📝 Input text:', inputText); try{ if (!inputText.trim()){ console.log('⚠️ Input is empty, clearing display'); document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter(); return;} const transactionTexts=inputText.split(/\s*(?:&&|Also)\s*/i); console.log('📑 Split into transactions:', transactionTexts); transactions=[]; currentTransactionIndex=0; transactionTexts.forEach((text, index)=>{ if (!text.trim()) return; console.log(`\n🔍 Processing transaction ${index + 1}:`, text.trim()); const analysis=analyzeTextContext(text.trim()); console.log('🤖 AI Analysis result:', analysis); let paidTo=determinePaidTo(text.trim(), analysis.category); console.log('👤 Determined Paid To:', paidTo); const transaction={ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": text.trim(), "Where was the money payed to?": paidTo, "Confidence level": `${analysis.confidence}%`}; console.log('📊 Created transaction:', transaction); transactions.push(transaction);}); console.log(`\n✅ Total transactions processed: ${transactions.length}`); if (transactions.length >0){ console.log('🎯 Displaying first transaction:', transactions[currentTransactionIndex]); displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter();} else{ console.log('⚠️ No transactions to display');}} catch (error){ console.error('❌ Process Input Error:', error); document.getElementById("editableContainer").innerHTML=`<div style="color: var(--text-muted); padding: 20px; text-align: center;">Error processing input: ${error.message} </div>`;}} function saveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][currentEditField]; if (currentEditField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][currentEditField]=newValue; if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(currentEditField); storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]); displayEditableFields(transactions[currentTransactionIndex]); showSuccess("Field updated successfully");} closeEditModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}} function updateTransactionCounter(){ console.log('📊 Updating transaction counter'); const indicator=document.querySelector('.transaction-indicator'); const prevBtn=document.getElementById('prevTransaction'); const nextBtn=document.getElementById('nextTransaction'); if (transactions.length >0){ indicator.textContent=`${currentTransactionIndex + 1} of ${transactions.length}`; prevBtn.disabled=currentTransactionIndex===0; nextBtn.disabled=currentTransactionIndex===transactions.length - 1; console.log(`✅ Counter updated: ${currentTransactionIndex + 1} of ${transactions.length}`);} else{ indicator.textContent='No Transactions'; prevBtn.disabled=true; nextBtn.disabled=true; console.log('⚠️ No transactions to display');}} function navigateTransaction(direction){ console.log('🔄 Navigating transaction:', direction); const newIndex=currentTransactionIndex + direction; if (newIndex >=0 && newIndex < transactions.length){ currentTransactionIndex=newIndex; displayEditableFields(transactions[currentTransactionIndex]); updateTransactionCounter(); console.log('✅ Navigated to transaction:', currentTransactionIndex + 1);}} function storeEditTrainingData(field, oldValue, newValue, transaction){ try{ const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const key=transaction["Purchase Description"].toLowerCase(); if (!trainingData[key]){ trainingData[key]={ corrections:{}, frequency: 0};} if (!trainingData[key].corrections[field]){ trainingData[key].corrections[field]=[];} trainingData[key].corrections[field].push({ from: oldValue, to: newValue, timestamp: new Date().toISOString()}); trainingData[key].frequency++; localStorage.setItem('editTrainingData', JSON.stringify(trainingData));} catch (e){ console.error('Error storing training data:', e);}} async function authorize(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before submitting."); return;} showSubmitOptions();} function showConfirmation(){ const confirmation=document.querySelector('.submit-confirmation'); const transactionList=confirmation.querySelector('.transaction-list'); transactionList.innerHTML=transactions.map((transaction, index)=>` <div class="transaction-item"><strong>Transaction ${index + 1}:</strong><br>Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>Category: ${transaction["What's the Purchase Category"]}<br>Paid To: ${transaction["Where was the money payed to?"]}<br>Description: ${transaction["Purchase Description"]} </div>`).join(''); confirmation.classList.add('show');} function closeConfirmation(){ document.querySelector('.submit-confirmation').classList.remove('show');} async function confirmSubmit(){ closeConfirmation(); const storedToken=TOKEN_MANAGEMENT.getStoredToken(); if (storedToken){ const isValid=await TOKEN_MANAGEMENT.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} TOKEN_MANAGEMENT.clearStoredToken();} tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); tokenClient.requestAccessToken();} async function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); TOKEN_MANAGEMENT.clearStoredToken(); return;} try{ TOKEN_MANAGEMENT.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} async function submitData(token){ showLoading(); try{ if (!transactions || transactions.length===0){ throw new Error('No transactions to submit');} for (const transaction of transactions){ if (!validateExpenseData(transaction)){ throw new Error('Invalid expense data');} AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]});} await AI_SYSTEM.savePatterns(); showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length >1 ? 's' : ''}`); clearForm();} catch (error){ console.error('Submit Error:', error); showError( "Submission Failed", "Failed to submit transactions.", error.message );} finally{ hideLoading();}} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; transactions=[]; currentTransactionIndex=0; updateTransactionCounter();} function displayEditableFields(data){ console.log('\n🎨 Displaying fields for data:', data); if (!data){ console.warn('⚠️ No data to display'); return;} try{ const container=document.getElementById("editableContainer"); if (!container){ console.error('❌ Container not found'); return;} container.innerHTML=''; console.log('🧹 Cleared container'); const fields=[ { field: "Date of Transaction", fullWidth: false}, { field: "How much money? (Tsh)", fullWidth: false}, { field: "What's the Purchase Category", fullWidth: true}, { field: "Where was the money payed to?", fullWidth: true}, { field: "Purchase Description", fullWidth: true}, { field: "Confidence level", fullWidth: false} ]; console.log('📋 Creating fields:', fields); fields.forEach(({ field, fullWidth})=>{ console.log(`\n🔧 Creating field: ${field}`); const fieldDiv=document.createElement("div"); fieldDiv.className=`editable-field${fullWidth ? ' full-width' : ''}`; fieldDiv.onclick=()=>ModalManager.showEditModal(field, data[field]); const label=document.createElement("div"); label.className="editable-label"; label.textContent=field; const value=document.createElement("div"); value.className="editable-value"; value.textContent=data[field] || ''; fieldDiv.appendChild(label); fieldDiv.appendChild(value); container.appendChild(fieldDiv); console.log(`✅ Field "${field}" created with value:`, data[field]);}); console.log('✨ Fields displayed successfully');} catch (error){ console.error('❌ Display Fields Error:', error); document.getElementById("editableContainer").innerHTML=`<div style="color: var(--text-muted); padding: 20px; text-align: center;">Error displaying fields: ${error.message} </div>`;}} function calculateConfidenceScore(transaction){ let baseConfidence=0; const description=transaction["Purchase Description"].toLowerCase(); const trainingData=JSON.parse(localStorage.getItem('editTrainingData') || '{}'); const historicalMatch=trainingData[description]; if (historicalMatch){ baseConfidence=90; baseConfidence +=Math.min(historicalMatch.frequency * 2, 5);} else{ const analysis=analyzeTextContext(description); baseConfidence=parseInt(analysis.confidence); const words=description.split(/\s+/); let partialMatches=0; Object.keys(trainingData).forEach(key=>{ const keyWords=key.split(/\s+/); const commonWords=words.filter(word=>keyWords.includes(word)); if (commonWords.length >1){ partialMatches++;}}); if (partialMatches >0){ baseConfidence +=Math.min(partialMatches * 3, 10);}} if (description.includes('maid') && description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} if (description.includes('irene') && !description.includes('home')){ baseConfidence=Math.min(baseConfidence + 10, 95);} return Math.min(Math.round(baseConfidence), 95);} function getConfidenceColor(score){ if (score >=90) return '#4CAF50'; if (score >=75) return '#8BC34A'; if (score >=60) return '#FFC107'; return '#FF5722';} function handleFeedback(transaction, isPositive){ if (isPositive){ AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); showSuccess("Thanks for the feedback! This will help improve future predictions.");} else{ showFeedbackForm(transaction);}} function showFeedbackForm(transaction){ const modal=document.createElement("div"); modal.className="edit-modal show"; modal.innerHTML=` <h3>What was incorrect?</h3><div class="feedback-form"><div class="feedback-options"><label><input type="checkbox" value="category">Category (${transaction["What's the Purchase Category"]}) </label><label><input type="checkbox" value="paidTo">Paid To (${transaction["Where was the money payed to?"]}) </label></div><div class="correction-fields" style="display: none;"><h4>Please provide the correct values:</h4><div id="correctionInputs"></div></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeFeedbackForm()">Cancel</button><button onclick="submitFeedback()">Submit</button></div>`; const style=document.createElement("style"); style.textContent=` .feedback-options{ display: flex; flex-direction: column; gap: 10px; margin: 15px 0;} .feedback-options label{ display: flex; align-items: center; gap: 8px; color: var(--text-light);} .correction-fields{ margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--bg-input);} `; document.head.appendChild(style); document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); const checkboxes=modal.querySelectorAll('input[type="checkbox"]'); checkboxes.forEach(checkbox=>{ checkbox.addEventListener('change', ()=>{ const correctionFields=modal.querySelector('.correction-fields'); const correctionInputs=modal.querySelector('#correctionInputs'); if ([...checkboxes].some(cb=>cb.checked)){ correctionFields.style.display='block'; correctionInputs.innerHTML=''; if (checkbox.value==='category' && checkbox.checked){ addCategorySelect(correctionInputs);} if (checkbox.value==='paidTo' && checkbox.checked){ addPaidToSelect(correctionInputs);}} else{ correctionFields.style.display='none';}});});} function addCategorySelect(container){ const select=document.createElement('select'); select.id='correctionCategory'; select.innerHTML=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}">${cat}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.style.marginBottom='10px'; wrapper.innerHTML='<label>Correct Category:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function addPaidToSelect(container){ const paidToOptions=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ]; const select=document.createElement('select'); select.id='correctionPaidTo'; select.innerHTML=paidToOptions.map(opt=>`<option value="${opt}">${opt}</option>` ).join(''); const wrapper=document.createElement('div'); wrapper.innerHTML='<label>Correct Paid To:</label>'; wrapper.appendChild(select); container.appendChild(wrapper);} function closeFeedbackForm(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} function submitFeedback(){ const transaction=transactions[currentTransactionIndex]; const categorySelect=document.getElementById('correctionCategory'); const paidToSelect=document.getElementById('correctionPaidTo'); if (categorySelect){ transaction["What's the Purchase Category"]=categorySelect.value;} if (paidToSelect){ transaction["Where was the money payed to?"]=paidToSelect.value;} AI_SYSTEM.learnFromHistoricalData({ category: transaction["What's the Purchase Category"], description: transaction["Purchase Description"], paidTo: transaction["Where was the money payed to?"]}); displayEditableFields(transaction); closeFeedbackForm(); showSuccess("Thank you for your feedback! This will help improve future predictions.");} function showLoading(){ utils.showElement('.loading-overlay');} function hideLoading(){ utils.hideElement('.loading-overlay');} function showError(title, message, details=''){ ErrorHandler.show(title, message, details);} function closeError(){ ErrorHandler.close();} function showSuccess(message){ SuccessHandler.show(message);} function updateUI(selector, content){ const element=utils.getElement(selector); if (element){ if (typeof content==='string'){ element.innerHTML=content;} else if (content instanceof Node){ element.innerHTML=''; element.appendChild(content);}}} const ModalManager={ currentField: null, showEditModal(field, value){ this.currentField=field; const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); const content=modal.querySelector('.edit-modal-content'); content.innerHTML=this.createModalContent(field, value); modal.classList.add('show'); overlay.classList.add('show'); const input=content.querySelector('input, select'); if (input){ input.focus(); if (input.select) input.select();}}, createModalContent(field, value){ if (field==="What's the Purchase Category"){ return this.createCategorySelect(value);} else if (field==="Where was the money payed to?"){ return this.createPaidToSelect(value);} else if (field==="How much money? (Tsh)"){ return this.createAmountInput(value);} else if (field==="Date of Transaction"){ return this.createDateInput(value);} else{ return this.createTextInput(field, value);}}, createCategorySelect(value){ const options=PURCHASE_CATEGORIES.map(cat=>`<option value="${cat}"${cat===value ? ' selected' : ''}>${cat}</option>` ).join(''); return `<select class="editable-select">${options}</select>`;}, createPaidToSelect(value){ const options=[ "Gave to Irene", "Gave to Maid (nyumbani)", "Spent on BMW", "Spent on Raum", "Spent on Guta", "Luku", "Gave to Parents - Tina", "ALRADA - Expenses", "Gave to Benadeta", "Aaliyah School Fee", "(OTHER) Food, Transport, Groceries, etc." ].map(opt=>`<option value="${opt}"${opt===value ? ' selected' : ''}>${opt}</option>` ).join(''); return `<select class="editable-select">${options}</select>`;}, createAmountInput(value){ return `<input type="number" class="editable-input" value="${value}" min="0" step="1000">`;}, createDateInput(value){ return `<input type="date" class="editable-input" value="${value}">`;}, createTextInput(field, value){ return `<input type="text" class="editable-input" value="${value}">`;}, closeModal(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.classList.remove('show'); if (overlay) overlay.classList.remove('show'); this.currentField=null;}}; const EventHandlers={ handleSubmit(){ authorize();}, handleSave(){ if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} saveForLater();}, handleSaveEdit(){ try{ const modal=document.querySelector('.edit-modal'); const input=modal.querySelector('input, select'); const newValue=input.value.trim(); if (!newValue){ showError("Invalid Input", "Please enter a valid value."); return;} if (transactions[currentTransactionIndex]){ const oldValue=transactions[currentTransactionIndex][ModalManager.currentField]; if (ModalManager.currentField==='How much money? (Tsh)' && isNaN(newValue)){ showError("Invalid Amount", "Please enter a valid number."); return;} transactions[currentTransactionIndex][ModalManager.currentField]=newValue; if (!transactions[currentTransactionIndex].editedFields){ transactions[currentTransactionIndex].editedFields=new Set();} transactions[currentTransactionIndex].editedFields.add(ModalManager.currentField); storeEditTrainingData(ModalManager.currentField, oldValue, newValue, transactions[currentTransactionIndex]); displayEditableFields(transactions[currentTransactionIndex]); showSuccess("Field updated successfully");} ModalManager.closeModal();} catch (error){ console.error('Error saving edit:', error); showError("Save Error", "Failed to save changes. Please try again.");}}}; async function initializeApp(){ console.log('🚀 Initializing application'); try{ window.ModalManager=ModalManager; window.EventHandlers=EventHandlers; setupEventListeners(); setupTouchNavigation(); await AI_SYSTEM.initialize(); updatePendingBadge(); const inputTextArea=utils.getElement(UI.selectors.inputText); if (inputTextArea){ inputTextArea.focus(); console.log('✅ Input textarea focused');} console.log('✅ Application initialized successfully');} catch (error){ console.error('❌ Failed to initialize app:', error); showError( 'Initialization Error', 'Failed to initialize the application.', error.message );}} if (document.readyState==='loading'){ console.log('📋 Document still loading, waiting for DOMContentLoaded'); document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);} else{ console.log('📋 Document already loaded, initializing immediately'); initializeApp();} function showPendingTransactions(){ const pending=OfflineStorage.getPendingTransactions(); if (pending.length===0){ showError("No Pending Transactions", "There are no transactions saved for later submission."); return;} const modal=document.createElement('div'); modal.className='edit-modal show'; modal.style.maxWidth='800px'; modal.innerHTML=` <h3>Pending Transactions (${pending.length})</h3><div class="pending-list">${pending.map((t, i)=>` <div class="pending-item"><div class="pending-info"><div class="pending-header"><strong>${t["How much money? (Tsh)"].toLocaleString()} Tsh</strong><span class="pending-date">${new Date(t.savedAt).toLocaleDateString()}</span></div><div class="pending-category">${t["What's the Purchase Category"]}</div><div class="pending-paid-to">${t["Where was the money payed to?"]}</div><div class="pending-description">${t["Purchase Description"]}</div></div><div class="pending-actions"><button onclick="submitPendingTransaction('${t.id}')" class="submit-one"><span class="button-icon">📤</span>Submit </button><button onclick="editPendingTransaction('${t.id}')" class="edit-one"><span class="button-icon">✏️</span>Edit </button><button onclick="removePendingTransaction('${t.id}')" class="remove-one"><span class="button-icon">🗑️</span>Remove </button></div></div>`).join('')} </div><div class="pending-summary"><div class="total-amount">Total: ${pending.reduce((sum, t)=>sum + parseInt(t["How much money? (Tsh)"]), 0).toLocaleString()} Tsh </div><button onclick="submitAllPending()" class="submit-all"><span class="button-icon">📤</span>Submit All (${pending.length}) </button></div><div class="edit-modal-buttons"><button class="cancel" onclick="closePendingTransactions()">Close</button></div>`; const style=document.createElement('style'); style.textContent=` .pending-list{ display: grid; gap: 12px; max-height: 60vh; overflow-y: auto; padding: 4px; margin: 15px 0;} .pending-item{ background: var(--bg-input); border-radius: 8px; padding: 16px;} .pending-header{ display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;} .pending-date{ color: var(--text-muted); font-size: 0.9em;} .pending-category{ color: var(--primary-color); font-weight: 500; margin-bottom: 4px;} .pending-paid-to{ color: var(--text-muted); font-size: 0.9em; margin-bottom: 4px;} .pending-description{ margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255, 255, 255, 0.1);} .pending-actions{ display: flex; gap: 8px; margin-top: 12px;} .pending-actions button{ flex: 1; padding: 8px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9em; display: flex; align-items: center; justify-content: center; gap: 4px; transition: transform 0.2s, opacity 0.2s;} .button-icon{ font-size: 1.1em;} .submit-one{ background: var(--primary-color); color: var(--bg-dark);} .edit-one{ background: var(--bg-card); color: var(--text-light);} .remove-one{ background: #ff4444; color: white;} .pending-summary{ display: flex; justify-content: space-between; align-items: center; margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(255, 255, 255, 0.1);} .total-amount{ font-size: 1.1em; font-weight: 500; color: var(--primary-color);} .submit-all{ background: var(--primary-color); color: var(--bg-dark); padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; display: flex; align-items: center; gap: 6px;} @media screen and (max-width: 768px){ .pending-actions{ flex-direction: column;} .pending-summary{ flex-direction: column; gap: 12px; text-align: center;} .submit-all{ width: 100%; justify-content: center;}} `; document.head.appendChild(style); document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show');} function editPendingTransaction(id){ const pending=OfflineStorage.getPendingTransactions(); const transaction=pending.find(t=>t.id===id); if (!transaction) return; transactions=[transaction]; currentTransactionIndex=0; displayEditableFields(transaction); updateTransactionCounter(); closePendingTransactions(); showSuccess('Transaction loaded for editing');} function closePendingTransactions(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show');} async function submitPendingTransaction(id){ try{ showLoading(); const pending=OfflineStorage.getPendingTransactions(); const transaction=pending.find(t=>t.id===id); if (!transaction){ throw new Error('Transaction not found');} const success=await submitData([transaction]); if (success){ OfflineStorage.removePendingTransaction(id); updatePendingBadge(); showSuccess('Transaction submitted successfully'); closePendingTransactions(); showPendingTransactions();}} catch (error){ console.error('Submit pending transaction error:', error); showError('Submit Failed', 'Failed to submit transaction. Please try again.');} finally{ hideLoading();}} async function submitAllPending(){ try{ console.log('🚀 Submitting all pending transactions'); showLoading(); const pending=OfflineStorage.getPendingTransactions(); if (pending.length===0){ showError('No Pending Transactions', 'There are no transactions to submit.'); return;} const success=await submitData(pending); if (success){ OfflineStorage.clearPendingTransactions(); updatePendingBadge(); showSuccess(`Successfully submitted ${pending.length} transaction(s)`); closePendingTransactions(); console.log(`✅ Successfully submitted ${pending.length} transactions`);}} catch (error){ console.error('❌ Submit all pending error:', error); showError('Submit Failed', 'Failed to submit transactions. Please try again.');} finally{ hideLoading();}} function showTransactionReview(){ console.log('🔍 Showing transaction review'); if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before reviewing."); return;} const modal=document.createElement('div'); modal.className='edit-modal show'; modal.style.maxWidth='800px'; modal.innerHTML=` <h3>Review Transactions (${transactions.length})</h3><div class="pending-list">${transactions.map((t, i)=>` <div class="pending-item ${i===currentTransactionIndex ? 'current' : ''}"><div class="pending-info"><div class="pending-header"><strong>${parseInt(t["How much money? (Tsh)"]).toLocaleString()} Tsh</strong><span class="pending-date">${t["Date of Transaction"]}</span></div><div class="pending-category">${t["What's the Purchase Category"]}</div><div class="pending-paid-to">${t["Where was the money payed to?"]}</div><div class="pending-description">${t["Purchase Description"]}</div><div class="confidence-indicator">Confidence: ${t["Confidence level"]}</div></div><div class="pending-actions"><button onclick="editTransaction(${i})" class="edit-one"><span class="button-icon">✏️</span>Edit </button><button onclick="removeTransaction(${i})" class="remove-one"><span class="button-icon">🗑️</span>Remove </button></div></div>`).join('')} </div><div class="pending-summary"><div class="total-amount">Total: ${transactions.reduce((sum, t)=>sum + parseInt(t["How much money? (Tsh)"]), 0).toLocaleString()} Tsh </div><div class="action-buttons"><button onclick="submitOnline()" class="submit-all"><span class="button-icon">📤</span>Submit All Online </button><button onclick="saveAllForLater()" class="save-all"><span class="button-icon">💾</span>Save All for Later </button></div></div><div class="edit-modal-buttons"><button class="cancel" onclick="closeTransactionReview()">Close</button></div>`; const style=document.createElement('style'); style.textContent=` .pending-item.current{ border: 2px solid var(--primary-color); background: var(--bg-card);} .confidence-indicator{ font-size: 0.8em; color: var(--text-muted); margin-top: 4px;} .action-buttons{ display: flex; gap: 8px;} .save-all{ background: var(--bg-card); color: var(--text-light); padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; display: flex; align-items: center; gap: 6px;} @media screen and (max-width: 768px){ .action-buttons{ flex-direction: column; width: 100%;} .submit-all, .save-all{ width: 100%; justify-content: center;}} `; document.head.appendChild(style); document.body.appendChild(modal); const overlay=document.querySelector('.edit-overlay'); overlay.classList.add('show'); console.log('✅ Transaction review modal displayed');} function closeTransactionReview(){ const modal=document.querySelector('.edit-modal'); const overlay=document.querySelector('.edit-overlay'); if (modal) modal.remove(); if (overlay) overlay.classList.remove('show'); console.log('✅ Transaction review modal closed');} function editTransaction(index){ console.log('✏️ Editing transaction:', index + 1); currentTransactionIndex=index; displayEditableFields(transactions[currentTransactionIndex]); closeTransactionReview(); updateTransactionCounter();} function removeTransaction(index){ console.log('🗑️ Removing transaction:', index + 1); transactions.splice(index, 1); if (currentTransactionIndex >=transactions.length){ currentTransactionIndex=Math.max(0, transactions.length - 1);} if (transactions.length >0){ displayEditableFields(transactions[currentTransactionIndex]);} else{ document.getElementById("editableContainer").innerHTML="";} updateTransactionCounter(); closeTransactionReview(); showTransactionReview(); console.log('✅ Transaction removed, remaining:', transactions.length);} function saveAllForLater(){ console.log('💾 Saving all transactions for later'); if (transactions.length===0){ showError("No Transactions", "Please enter at least one transaction before saving."); return;} let savedCount=0; for (const transaction of transactions){ if (OfflineStorage.savePendingTransaction(transaction)){ savedCount++;}} if (savedCount >0){ showSuccess(`Saved ${savedCount} transaction${savedCount >1 ? 's' : ''} for later submission`); clearForm(); updatePendingBadge(); closeTransactionReview(); console.log(`✅ Saved ${savedCount} transactions for later`);} else{ showError("Save Failed", "Failed to save transactions. Please try again.");}} const AI_SYSTEM={ confidenceThreshold: 0.75, learningRate: 0.1, maxPatterns: 2000, patterns: new Map(), historicalData: new Map(), async initialize(){ try{ const storedPatterns=localStorage.getItem('aiPatterns'); if (storedPatterns){ const parsed=JSON.parse(storedPatterns); this.patterns=new Map(Object.entries(parsed).map(([key, value])=>{ if (value.keywords){ value.keywords=new Set(Array.isArray(value.keywords) ? value.keywords : []);} return [key, value];}));} const storedHistory=localStorage.getItem('historicalTransactions'); if (storedHistory){ this.historicalData=new Map(Object.entries(JSON.parse(storedHistory)));} if (this.patterns.size===0){ this.initializeWithTrainingData();}} catch (error){ console.error('AI System initialization error:', error); this.initializeWithTrainingData();}}, initializeWithTrainingData(){ this.patterns.clear(); this.historicalData.clear(); INITIAL_TRAINING_DATA.forEach(entry=>{ const key=`${entry.category}:${entry.paidTo}`; const words=entry.description.toLowerCase().split(/\s+/); let pattern=this.patterns.get(key) ||{ category: entry.category, paidTo: entry.paidTo, keywords: new Set(), frequency: 0, confidence: 0.8, examples: []}; words.forEach(word=>{ if (word.length >2){ pattern.keywords.add(word);}}); pattern.frequency++; pattern.examples.push(entry.description); if (pattern.examples.length >5){ pattern.examples.shift();} this.patterns.set(key, pattern);}); this.savePatterns(); console.debug('AI System initialized with training data');}, async savePatterns(){ try{ const serializedPatterns={}; for (const [key, value] of this.patterns.entries()){ serializedPatterns[key]={ ...value, keywords: Array.from(value.keywords)};} localStorage.setItem('aiPatterns', JSON.stringify(serializedPatterns)); const serializedHistory={}; for (const [key, value] of this.historicalData.entries()){ serializedHistory[key]=value;} localStorage.setItem('historicalTransactions', JSON.stringify(serializedHistory));} catch (error){ console.error('Error saving patterns:', error);}}, learnFromHistoricalData(entry){ const key=`${entry.category}:${entry.paidTo}`; const words=entry.description.toLowerCase().split(/\s+/); let pattern=this.patterns.get(key) ||{ category: entry.category, paidTo: entry.paidTo, keywords: new Set(), frequency: 0, confidence: 0.7, examples: []}; words.forEach(word=>{ if (word.length >2){ pattern.keywords.add(word);}}); pattern.frequency++; pattern.examples.push(entry.description); if (pattern.examples.length >5){ pattern.examples.shift();} pattern.confidence=Math.min(0.95, pattern.confidence + (this.learningRate * (1 - pattern.confidence))); this.patterns.set(key, pattern); const historyKey=entry.description.toLowerCase(); const existingHistory=this.historicalData.get(historyKey) ||{ category: entry.category, paidTo: entry.paidTo, timestamp: Date.now(), frequency: 0}; existingHistory.frequency++; this.historicalData.set(historyKey, existingHistory);}}; function analyzeTextContext(text){ console.log('\n🔍 Starting text analysis for:', text); const lowerText=text.toLowerCase(); const words=lowerText.split(/\s+/); console.log('📝 Words identified:', words); const amount=extractAmount(lowerText); console.log('💰 Extracted amount:', amount); const scores={ "Groceries & Household": 0, "Gift to Family & Friends": 0, "Petrol & Transport": 0, "Medical & Medicine": 0, "Utilities & Bills": 0, "Eating Out & Entertainment": 0}; words.forEach(word=>{ console.log(`\n🔤 Processing word: ${word}`); if (['home', 'maid', 'nyumbani', 'groceries', 'food', 'milk', 'rice'].includes(word)){ scores["Groceries & Household"] +=1; console.log('🏠 Matched Groceries & Household');} if (['gave', 'irene', 'gift', 'send', 'support'].includes(word)){ scores["Gift to Family & Friends"] +=1; console.log('🎁 Matched Gift to Family & Friends');} if (['petrol', 'fuel', 'transport', 'fare', 'taxi'].includes(word)){ scores["Petrol & Transport"] +=1; console.log('🚗 Matched Petrol & Transport');}}); console.log('\n📊 Category scores:', scores); let bestCategory="(OTHER) Food, Transport, Groceries, etc."; let highestScore=0; Object.entries(scores).forEach(([category, score])=>{ if (score >highestScore){ highestScore=score; bestCategory=category;}}); console.log('🏆 Best category:', bestCategory, 'with score:', highestScore); const confidence=Math.min(Math.round((highestScore / words.length) * 100) + 50); console.log('📈 Calculated confidence:', confidence + '%'); const result={ category: bestCategory, confidence: confidence, amount: amount, paidTo: determinePaidTo(text, bestCategory)}; console.log('✅ Analysis complete:', result); return result;} function determinePaidTo(text, category){ const lowerText=text.toLowerCase(); if (lowerText.includes('irene')) return "Gave to Irene"; if (lowerText.includes('maid') || (lowerText.includes('home') && !lowerText.includes('irene'))){ return "Gave to Maid (nyumbani)";} const defaults={ "Groceries & Household": "Gave to Maid (nyumbani)", "Gift to Family & Friends": "Gave to Irene", "Petrol & Transport": "Spent on Raum"}; return defaults[category] || "(OTHER) Food, Transport, Groceries, etc.";} function extractAmount(text){ const patterns=[ /(\d+)\s*k\b/i, /(\d+)\s*thousand\b/i, /(\d+),(\d{3})/, /(\d+)\s*tsh/i, /(\d+)/ ]; for (const pattern of patterns){ const match=text.match(pattern); if (match){ let amount=parseInt(match[1]); if (pattern.toString().includes('k') || pattern.toString().includes('thousand')){ amount *=1000;} return amount;}} return 0;} </script><script src="https://apis.google.com/js/api.js" defer></script><script src="https://accounts.google.com/gsi/client" defer></script></body></html>