<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Expense Tracker v0.0.8</title><style>body{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #1e1e2e; color: #f5f5f5; margin: 0; padding: 0;} .container{ margin: 20px auto; width: 90%; max-width: 600px; background-color: #28293d; padding: 20px; border-radius: 10px; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);} h1{ text-align: center; margin-bottom: 20px; margin-top: 0; color: #f5a623;} textarea{ width: 100%; height: 120px; background-color: #33344b; color: #f5f5f5; border: none; padding: 5px; border-radius: 8px; font-size: 16px; resize: none;} textarea:focus{ outline: none; border: 2px solid #f5a623;} button{ width: 100%; padding: 15px; background-color: #f5a623; color: #1e1e2f; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; margin-top: 10px;} button:hover{ background-color: #d48821;} .editable-container{ display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin: 15px 0;} .editable-field{ display: flex; flex-direction: column; margin-bottom: 0;} .editable-field.full-width{ grid-column: 1 / -1;} .editable-label{ font-size: 14px; margin-bottom: 5px; color: #8e8ea0;} .editable-input, .editable-select{ padding: 8px 12px; border-radius: 8px; border: none; background-color: #33344b; color: #f5f5f5; font-size: 14px; height: 36px;} .editable-input[type="text"]{ height: 36px;} .confidence-score{ grid-column: 1 / -1; text-align: right; color: #8e8ea0; font-size: 14px; margin-top: 10px;} .loading-overlay{ display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 1000; justify-content: center; align-items: center;} .loading-spinner{ width: 50px; height: 50px; border: 5px solid #f5f5f5; border-top: 5px solid #f5a623; border-radius: 50%; animation: spin 1s linear infinite;} @keyframes spin{ 0%{ transform: rotate(0deg);} 100%{ transform: rotate(360deg);} } .error-notification{ display: none; position: fixed; top: 0; left: 0; right: 0; background-color: #ff4444; color: white; padding: 15px; z-index: 1001; animation: slideDown 0.5s ease-out;} .error-notification.show{ display: flex; justify-content: space-between; align-items: flex-start;} .error-content{ flex-grow: 1; margin-right: 20px;} .error-title{ font-weight: bold; margin-bottom: 5px;} .error-message{ font-size: 14px;} .error-close{ background: none; border: none; color: white; font-size: 20px; cursor: pointer; padding: 0 5px;} @keyframes slideDown{ from{ transform: translateY(-100%);} to{ transform: translateY(0);} } .version{ font-size: 14px; color: #f5a623; margin-left: 10px; opacity: 0.8;} @media screen and (max-width: 768px){ body{ background-color: #28293d;} .container{ margin: 0; width: 90%; max-width: 90%; min-height: 100vh; border-radius: 0; box-shadow: none; padding: 15px;} .input-section{ padding: 15px;} .input-section textarea{ height: 60px;} .results-section{ padding: 0;} .editable-container{ grid-template-columns: 1fr;}} .success-notification{ display: none; position: fixed; top: 20px; right: 20px; background-color: #4CAF50; color: white; padding: 15px; border-radius: 4px; z-index: 1001; animation: slideIn 0.5s ease-out;} .success-notification.show{ display: block;} @keyframes slideIn{ from{ transform: translateX(100%);} to{ transform: translateX(0);}} </style></head><body><div class="loading-overlay"><div class="loading-spinner"></div></div><div class="error-notification"><div class="error-content"><div class="error-title">Error Occurred</div><div class="error-message"></div></div><button class="error-close" onclick="closeError()">Ã—</button></div><div class="container"><h1>Expense Tracker <span class="version">v0.0.15</span></h1><div class="results-section"><div class="editable-container" id="editableContainer"></div></div><div class="input-section"><textarea id="inputText" placeholder="Type your expense description and press Enter..."></textarea><button onclick="authorize()">Submit</button></div></div><script type="module">import config from './config.js'; // Set the client ID securely window.CLIENT_ID=config.clientId; </script><script>const SCOPES="https://www.googleapis.com/auth/spreadsheets"; const SPREADSHEET_ID="__SPREADSHEET_ID__"; let generatedData=null; let tokenClient=null; const VERSION={ major: 0, minor: 0, patch: 15, buildDate: '2024-03-19', toString(){ return `${this.major}.${this.minor}.${this.patch}`;}, fromString(versionStr){ try{ const [major, minor, patch]=versionStr.split('.').map(num=>parseInt(num, 10)); if (Number.isInteger(major) && Number.isInteger(minor) && Number.isInteger(patch)){ this.major=major; this.minor=minor; this.patch=patch; return true;}} catch (e){ console.error('Error parsing version:', e);} return false;}}; const trainingData=[ { category: "Petrol & Transport", keywords: ["petrol", "raum", "bmw", "fuel", "gas", "diesel", "transport", "fare", "taxi", "uber", "bolt", "baught petrol", "put petrol", "filled", "mafuta", "put fuel", "transport to", "nauli"]}, { category: "Car Maintenance & Fee's", keywords: ["repair", "maintenance", "oil", "service", "garage", "mechanic", "spare", "parts", "car wash", "insurance", "fundi", "fixed", "tire", "puncture", "parking", "brakes", "coil"]}, { category: "Gift to Family & Friends", keywords: ["gave", "gift", "send", "irene", "family", "friend", "support", "help", "sent to", "mchango", "changia", "asked for", "faith", "tina", "benadeta", "wine", "bear", "konyag"]}, { category: "Groceries", keywords: ["grocery", "shopping", "supermarket", "market", "food", "household", "milk", "water", "uhai", "mkaa", "rice", "mchele", "maziwa", "breakfast", "eggs", "sugar", "mboga", "gulio", "dogfood", "sabuni", "maid", "house", "domestic", "worker"]}, { category: "Eating Out", keywords: ["food", "restaurant", "lunch", "dinner", "eat", "meal", "snack", "cafe", "bought food", "food at", "food while", "food from", "pizza", "kfc", "chips mayai", "mishkaki", "fast food", "mtori", "breakfast"]}, { category: "Utilities", keywords: ["luku", "electricity", "water bill", "internet", "wifi", "gas", "trash", "takataka", "security", "netflix", "gass", "dawasa", "bill", "payment", "utility", "baught luku", "put luku", "added luku"]}, { category: "Aaliyah School Fee", keywords: ["school", "fee", "aaliyah", "education", "tuition", "uniform", "books", "graduation", "karate"]} ]; const paidToOptions=[ "Spent on BMW", "Spent on Raum", "Gave to Maid (nyumbani)", "Gave to Irene", "Aaliyah School Fee", "ALRADA - Expenses", "Gave to Parents - Tina", "Spent on Guta", "Luku", "Msiba", "Medical Expenses", "Eating Out", "Groceries", "Petrol & Transport", "Car Maintenance & Fee's", "Celebration", "Gift to Family & Friends", "Utilities", "Aaliyah Investment", "Home Investment", "Rent", "Phone Maintenance", "Funeral", "(OTHER) Food, Transport, Groceries, etc." ]; window.generatedData=null; window.tokenClient=null; const EVENTS={ INPUT: 'input', KEYDOWN: 'keydown', LOAD: 'load', DOMCONTENTLOADED: 'DOMContentLoaded'}; // Add this function before setupEventListeners function processInput(){ const inputText=document.getElementById("inputText").value; if (inputText.trim()===""){ document.getElementById("editableContainer").innerHTML=""; window.generatedData=null; return;} const analysis=analyzeTextContext(inputText); // Determine paid to based on category and context let paidTo=determinePaidTo(inputText, analysis.category); window.generatedData={ "Date of Transaction": new Date().toISOString().split("T")[0], "Where did the money come from?": "ALBERT", "How much money? (Tsh)": analysis.amount.toString(), "What's the Purchase Category": analysis.category, "Purchase Description": inputText, "Where was the money payed to?": paidTo, "Confidance level": `${analysis.confidence}%`}; displayEditableFields(window.generatedData); // Log evidence for debugging console.debug("Analysis Evidence:", analysis.evidence);} // Add this function for displaying editable fields function displayEditableFields(data){ const container=document.getElementById("editableContainer"); container.innerHTML=``; const dateField=document.createElement("div"); dateField.className="editable-field"; dateField.innerHTML=` <label class="editable-label">Date</label><input type="date" class="editable-input" value="${data["Date of Transaction"]}" onchange="updateField('Date of Transaction', this.value)">`; container.appendChild(dateField); const amountField=document.createElement("div"); amountField.className="editable-field"; amountField.innerHTML=` <label class="editable-label">Amount (Tsh)</label><input type="number" class="editable-input" value="${data["How much money? (Tsh)"]}" onchange="updateField('How much money? (Tsh)', this.value)">`; container.appendChild(amountField); const categoryField=document.createElement("div"); categoryField.className="editable-field"; const categoryOptions=paidToOptions .filter(option=>!option.toLowerCase().startsWith('spent') && !option.toLowerCase().startsWith('gave')) .map(option=>`<option value="${option}" ${option===data["What's the Purchase Category"] ? "selected" : ""}>${option}</option>`) .join(""); categoryField.innerHTML=` <label class="editable-label">Category</label><select class="editable-select" onchange="updateField('What\'s the Purchase Category', this.value)">${categoryOptions} </select>`; container.appendChild(categoryField); const paidToField=document.createElement("div"); paidToField.className="editable-field"; const paidToOptionsHtml=paidToOptions .map(option=>`<option value="${option}" ${option===data["Where was the money payed to?"] ? "selected" : ""}>${option}</option>`) .join(""); paidToField.innerHTML=` <label class="editable-label">Paid To</label><select class="editable-select" onchange="updateField('Where was the money payed to?', this.value)">${paidToOptionsHtml} </select>`; container.appendChild(paidToField); const descriptionField=document.createElement("div"); descriptionField.className="editable-field full-width"; descriptionField.innerHTML=` <label class="editable-label">Description</label><input type="text" class="editable-input" value="${data["Purchase Description"]}" onchange="updateField('Purchase Description', this.value)">`; container.appendChild(descriptionField); const confidenceField=document.createElement("div"); confidenceField.className="confidence-score"; confidenceField.innerHTML=`Confidence Score: ${data["Confidance level"]}`; container.appendChild(confidenceField);} // Add this function to update fields window.updateField=function(field, value){ if (window.generatedData){ window.generatedData[field]=value;}} // Move closeError function definition to the top with other function definitions function closeError(){ document.querySelector('.error-notification').classList.remove('show');} function setupEventListeners(){ const inputTextArea=document.getElementById('inputText'); // Process input when text changes (debounced) let debounceTimeout; inputTextArea.addEventListener('input', function(){ clearTimeout(debounceTimeout); debounceTimeout=setTimeout(processInput, 300); // Wait 300ms after typing stops}); // Process input when Enter is pressed inputTextArea.addEventListener(EVENTS.KEYDOWN, function(event){ if (event.key==='Enter' && !event.shiftKey){ event.preventDefault(); clearTimeout(debounceTimeout); processInput();}}); // Process input when text is pasted inputTextArea.addEventListener('paste', function(){ setTimeout(processInput, 0);}); // Close error notification when clicking outside document.addEventListener('click', function(event){ const errorNotification=document.querySelector('.error-notification'); if (errorNotification && errorNotification.classList.contains('show') && !errorNotification.contains(event.target)){ closeError();}});} (function initApp(){ if (document.readyState==='loading'){ document.addEventListener(EVENTS.DOMCONTENTLOADED, setupApp);} else{ setupApp();}})(); function setupApp(){ try{ const savedVersion=localStorage.getItem('expenseTrackerVersion'); if (savedVersion){ VERSION.fromString(savedVersion);} updateVersionDisplay(); setupEventListeners();} catch (e){ console.error('Error in setupApp:', e); // Fallback to default version VERSION.major=0; VERSION.minor=0; VERSION.patch=15; updateVersionDisplay();}} function calculateMatchScore(input, keywords){ if (!input || !keywords || !Array.isArray(keywords)){ return 0;} let score=0; keywords.forEach(keyword=>{ if (input.includes(keyword.toLowerCase())){ score +=1;}}); return keywords.length >0 ? score / keywords.length : 0;} // Add these helper functions before processInput function extractAmount(text){ // Match patterns like "50k", "50,000", "50000", "50 thousand" const patterns=[ /(\d+)k/i, // matches "50k" /(\d+)[,\s]?000/, // matches "50,000" or "50000" /(\d+)\s*thousand/i, // matches "50 thousand" /(\d+)/ // matches any number ]; for (let pattern of patterns){ const match=text.match(pattern); if (match){ let amount=parseInt(match[1]); if (pattern.toString().includes('k') || pattern.toString().includes('thousand')){ amount *=1000;} return amount;}} return 0;} function findBestMatch(text, options, threshold=0.3){ let bestMatch=null; let bestScore=threshold; options.forEach(option=>{ const words=option.toLowerCase().split(/\s+/); let score=0; words.forEach(word=>{ if (text.includes(word)){ score +=1 / words.length;}}); if (score >bestScore){ bestScore=score; bestMatch=option;}}); return bestMatch;} // Add these functions to handle training data async function fetchTrainingData(token){ try{ const response=await fetchWithTimeout( `${ENV.apiBaseUrl}spreadsheets/${SPREADSHEET_ID}/values/ExpenseResults!A:G`, { headers:{ Authorization: `Bearer ${token}`,},} ); if (!response.ok){ throw new Error('Failed to fetch training data');} const data=await response.json(); if (!data.values || data.values.length < 2){ return [];} // Skip header row and process the rest return data.values.slice(1).map(row=>({ description: row[4]?.toLowerCase() || '', amount: row[2] || '', category: row[3] || '', paidTo: row[5] || ''}));} catch (error){ console.error('Error fetching training data:', error); return [];}} function processTrainingData(data){ const patterns={}; data.forEach(entry=>{ if (!entry.description || !entry.category) return; const key=`${entry.category}|${entry.paidTo}`; if (!patterns[key]){ patterns[key]={ category: entry.category, paidTo: entry.paidTo, keywords: new Set(), frequency: 0, amounts: []};} // Extract meaningful words from description const words=entry.description .toLowerCase() .split(/\s+/) .filter(word=>word.length >3); // Ignore small words words.forEach(word=>patterns[key].keywords.add(word)); patterns[key].frequency++; // Store amount if it's a number const amount=parseFloat(entry.amount.replace(/[^0-9.]/g, '')); if (!isNaN(amount)){ patterns[key].amounts.push(amount);}}); // Convert Sets to Arrays and calculate average amounts Object.values(patterns).forEach(pattern=>{ pattern.keywords=Array.from(pattern.keywords); pattern.avgAmount=pattern.amounts.length >0 ? pattern.amounts.reduce((a, b)=>a + b) / pattern.amounts.length : 0;}); return patterns;} // Store training data in localStorage function storeTrainingPatterns(patterns){ localStorage.setItem('expensePatterns', JSON.stringify(patterns));} // Load training data from localStorage function loadTrainingPatterns(){ const stored=localStorage.getItem('expensePatterns'); return stored ? JSON.parse(stored) : null;} // Add this contextual analysis system const CONTEXT_WEIGHTS={ PRIMARY_ACTION: 0.35, // Main action words (gave, bought, paid) RECIPIENT: 0.30, // Who received the money PURPOSE: 0.25, // What it was for AMOUNT: 0.10 // Whether amount makes sense for category}; const CATEGORY_PATTERNS={ "Gift to Family & Friends":{ actions: ["gave", "sent", "transfer", "help"], recipients: ["irene", "family", "friend", "parent", "tina"], contexts: ["support", "help"], typicalAmounts: [50000, 100000, 200000], negativeContexts: ["food", "grocery", "shopping", "market"]}, "Groceries":{ actions: ["bought", "purchased", "shopping", "buy"], contexts: ["food", "grocery", "groceries", "market", "household", "home", "kitchen"], typicalAmounts: [20000, 50000, 100000, 150000], boostContexts: ["food", "grocery", "shopping"]}, "Petrol & Transport":{ actions: ["fuel", "petrol", "filled"], recipients: ["bmw", "raum"], contexts: ["car", "vehicle", "transport"], typicalAmounts: [30000, 50000, 70000]} // Add more category patterns...}; // Add utility-specific patterns const UTILITY_PATTERNS={ luku: ["luku", "electricity", "power"], water: ["water bill", "dawasa", "water payment"], internet: ["wifi", "internet", "netflix"], security: ["security", "ulinzi", "guard"], gas: ["gas", "gass", "gas cylinder"]}; // First pass: Check exact phrases const exactPhrases={ "Eating Out": ["bought food", "food at", "food while", "food from", "pizza hut", "kfc", "chips mayai"], "Groceries": ["gave to maid", "left money home", "gave money to maid", "for home", "nyumbani"], "Gift to Family & Friends": ["gave to irene", "sent to irene", "gave irene", "irene asked"], "Utilities": ["baught luku", "paid luku", "added luku", "put luku", "paid bill", "water bill", "security payment"]}; function analyzeTextContext(text){ const lowerText=text.toLowerCase(); let bestCategory=null; let highestConfidence=0; let evidence=[]; // Load historical patterns if available const historicalPatterns=loadTrainingPatterns() ||{}; // First pass: Check utility-specific patterns for (const [utilityType, patterns] of Object.entries(UTILITY_PATTERNS)){ if (patterns.some(pattern=>lowerText.includes(pattern))){ bestCategory="Utilities"; highestConfidence=0.95; evidence.push(`Utility match: ${utilityType}`); break;}} // Second pass: Check exact phrases if no utility match if (!bestCategory){ for (const [category, phrases] of Object.entries(exactPhrases)){ for (const phrase of phrases){ if (lowerText.includes(phrase)){ bestCategory=category; highestConfidence=0.95; evidence.push(`Exact phrase match: "${phrase}"`); break;}} if (bestCategory) break;}} if (!bestCategory){ // Third pass: Check categories with context trainingData.forEach(category=>{ let confidence=0; let categoryEvidence=[]; // Check keywords with word boundary const keywordMatches=category.keywords.filter(keyword=>{ const pattern=new RegExp(`\\b${keyword}\\b`, 'i'); return pattern.test(lowerText);}); if (keywordMatches.length >0){ const keywordScore=keywordMatches.length / category.keywords.length; confidence +=keywordScore * CONTEXT_WEIGHTS.PRIMARY_ACTION; categoryEvidence.push(`Matched keywords: ${keywordMatches.join(", ")}`);} // Check recipient context const recipients=["irene", "maid", "nyumbani", "essau", "tina", "tinah", "benadeta"]; const recipientMatches=recipients.filter(r=>lowerText.includes(r)); if (recipientMatches.length >0){ confidence +=CONTEXT_WEIGHTS.RECIPIENT; categoryEvidence.push(`Recipient match: ${recipientMatches.join(", ")}`);} // Context-specific boosts if (category.category==="Utilities" && (lowerText.includes("bill") || lowerText.includes("payment") || lowerText.includes("paid") || lowerText.includes("baught"))){ confidence +=0.3; categoryEvidence.push("Payment context boost");} // Apply historical pattern boost const historicalKey=`${category.category}|${determinePaidTo(lowerText, category.category)}`; if (historicalPatterns[historicalKey]){ const pattern=historicalPatterns[historicalKey]; confidence +=(pattern.frequency / 100) * 0.2; // Boost based on frequency categoryEvidence.push(`Historical frequency boost: ${pattern.frequency}%`);} if (confidence >highestConfidence){ highestConfidence=confidence; bestCategory=category.category; evidence=categoryEvidence;}});} // Normalize confidence to percentage const confidencePercentage=Math.min(Math.round(highestConfidence * 100), 100); return{ category: bestCategory || "(OTHER) Food, Transport, Groceries, etc.", confidence: confidencePercentage, amount: extractAmount(text), evidence: evidence};} // Helper function to find closest typical amount function findClosestAmount(amount, typicalAmounts){ return typicalAmounts.reduce((prev, curr)=>{ return Math.abs(curr - amount) < Math.abs(prev - amount) ? curr : prev;});} // Add this function before processInput function determinePaidTo(text, category){ text=text.toLowerCase(); // Direct recipient matches if (text.includes('irene')){ return "Gave to Irene";} else if (text.includes('maid') || text.includes('nyumbani') || text.includes('essau')){ return "Gave to Maid (nyumbani)";} else if (text.includes('bmw')){ return "Spent on BMW";} else if (text.includes('raum')){ return "Spent on Raum";} else if (text.includes('guta')){ return "Spent on Guta";} else if (text.includes('luku')){ return "Luku";} else if (text.includes('tina') || text.includes('tinah')){ return "Gave to Parents - Tina";} else if (text.includes('alrada')){ return "ALRADA - Expenses";} else if (text.includes('benadeta') || text.includes('benadetha')){ return "Gave to Benadeta";} // Category-based defaults const categoryDefaults={ "Gift to Family & Friends": "Gave to Irene", "Petrol & Transport": "Spent on Raum", "Car Maintenance & Fee's": "Spent on Raum", "Groceries": "Gave to Maid (nyumbani)", "Eating Out": "(OTHER) Food, Transport, Groceries, etc.", "Utilities": "(OTHER) Food, Transport, Groceries, etc.", "Aaliyah School Fee": "Aaliyah School Fee"}; return categoryDefaults[category] || "(OTHER) Food, Transport, Groceries, etc.";} // Add these token management functions before the authorize function but after FUNCTIONS declaration const TOKEN_MANAGEMENT={ isTokenValid(token){ if (!token) return false; return fetchWithTimeout( `${ENV.apiBaseUrl}spreadsheets/${SPREADSHEET_ID}/values/ExpenseResults!A1`, { headers:{ Authorization: `Bearer ${token}`,},} ) .then(response=>response.ok) .catch(()=>false);}, storeToken(token){ try{ localStorage.setItem('expenseTrackerToken', token); localStorage.setItem('tokenTimestamp', new Date().getTime());} catch (e){ console.error('Error storing token:', e);}}, getStoredToken(){ try{ const token=localStorage.getItem('expenseTrackerToken'); const timestamp=localStorage.getItem('tokenTimestamp'); // Check if token is expired (1 hour) if (token && timestamp){ const now=new Date().getTime(); const hourInMs=60 * 60 * 1000; if (now - parseInt(timestamp) < hourInMs){ return token;}} return null;} catch (e){ console.error('Error getting stored token:', e); return null;}}, clearStoredToken(){ try{ localStorage.removeItem('expenseTrackerToken'); localStorage.removeItem('tokenTimestamp');} catch (e){ console.error('Error clearing token:', e);}}}; // Update the FUNCTIONS object to include token management const APP_FUNCTIONS={ processInput, authorize, updateField, closeError, showError, hideLoading, showLoading, updateVersion, submitData, handleAuthResponse, displayEditableFields, isTokenValid: TOKEN_MANAGEMENT.isTokenValid, storeToken: TOKEN_MANAGEMENT.storeToken, getStoredToken: TOKEN_MANAGEMENT.getStoredToken, clearStoredToken: TOKEN_MANAGEMENT.clearStoredToken}; // Update references in authorize function to use APP_FUNCTIONS async function authorize(){ const storedToken=APP_FUNCTIONS.getStoredToken(); if (storedToken){ const isValid=await APP_FUNCTIONS.isTokenValid(storedToken); if (isValid){ submitData(storedToken); return;} APP_FUNCTIONS.clearStoredToken();} window.tokenClient=google.accounts.oauth2.initTokenClient({ client_id: window.CLIENT_ID, scope: SCOPES, callback: handleAuthResponse}); window.tokenClient.requestAccessToken();} // Update handleAuthResponse to use APP_FUNCTIONS function handleAuthResponse(response){ if (response.error){ console.error('Auth Error:', response.error); showError( "Authentication Failed", "Failed to authenticate with Google. Please try again.", response.error ); APP_FUNCTIONS.clearStoredToken(); return;} try{ APP_FUNCTIONS.storeToken(response.access_token); submitData(response.access_token);} catch (error){ console.error('Auth Handler Error:', error); showError( "Authentication Error", "An error occurred while processing authentication.", error.message );}} function showLoading(){ document.querySelector('.loading-overlay').style.display='flex';} function hideLoading(){ document.querySelector('.loading-overlay').style.display='none';} function showError(title, message, details){ const notification=document.querySelector('.error-notification'); notification.querySelector('.error-title').textContent=title; notification.querySelector('.error-message').innerHTML=` <p>${message}</p>${details ? `<p><strong>Details:</strong>${details}</p>` : ''} ${message.includes('Authentication') ? '<p><strong>Solution:</strong>Please try submitting again to re-authenticate.</p>' : ''} ${message.includes('permission') ? '<p><strong>Solution:</strong>Please ensure you have edit access to the spreadsheet.</p>' : ''} `; notification.classList.add('show');} function updateVersion(type='patch'){ try{ switch(type){ case 'major': VERSION.major=Number(VERSION.major) + 1; VERSION.minor=0; VERSION.patch=0; break; case 'minor': VERSION.minor=Number(VERSION.minor) + 1; VERSION.patch=0; break; case 'patch': VERSION.patch=Number(VERSION.patch) + 1; break;} updateVersionDisplay(); localStorage.setItem('expenseTrackerVersion', VERSION.toString());} catch (e){ console.error('Error updating version:', e);}} function updateVersionDisplay(){ try{ const versionString=`v${VERSION.toString()}`; document.title=`Expense Tracker ${versionString}`; const versionElements=document.querySelectorAll('.version'); versionElements.forEach(el=>{ el.textContent=versionString;});} catch (e){ console.error('Error updating version display:', e);}} const FETCH_TIMEOUT=30000; // 30 seconds async function fetchWithTimeout(url, options){ const controller=new AbortController(); const timeoutId=setTimeout(()=>controller.abort(), FETCH_TIMEOUT); try{ const response=await fetch(url,{ ...options, signal: controller.signal}); clearTimeout(timeoutId); return response;} catch (error){ clearTimeout(timeoutId); if (error.name==='AbortError'){ throw new Error('Request timed out');} throw error;}} const ENV={ isProd: window.location.hostname !=='localhost', get apiBaseUrl(){ return this.isProd ? 'https://sheets.googleapis.com/v4/' : 'http://localhost:3000/api/';}}; async function submitData(token){ showLoading(); try{ if (!window.generatedData || !validateExpenseData(window.generatedData)){ throw new Error('Invalid expense data');} // Prepare the data const submissionData={ description: window.generatedData["Purchase Description"], category: window.generatedData["What's the Purchase Category"], paidTo: window.generatedData["Where was the money payed to?"], amount: window.generatedData["How much money? (Tsh)"]}; // Update training patterns const patterns=loadTrainingPatterns() ||{}; const key=`${submissionData.category}|${submissionData.paidTo}`; if (!patterns[key]){ patterns[key]={ category: submissionData.category, paidTo: submissionData.paidTo, keywords: new Set(), frequency: 0, amounts: []};} // Extract and add keywords const words=submissionData.description .toLowerCase() .split(/\s+/) .filter(word=>word.length >3); words.forEach(word=>patterns[key].keywords.add(word)); patterns[key].frequency++; patterns[key].amounts.push(parseFloat(submissionData.amount)); // Store updated patterns storeTrainingPatterns(patterns); // Continue with the submission... // [Rest of the existing submitData code]} catch (error){ handleSubmitError(error);}} function validateExpenseData(data){ const required=[ "Date of Transaction", "Where did the money come from?", "How much money? (Tsh)", "What's the Purchase Category", "Purchase Description" ]; return required.every(field=>{ const value=data[field]; return value !==undefined && value !==null && value !=='';});} function showSuccess(message){ const notification=document.createElement('div'); notification.className='success-notification show'; notification.innerHTML=` <div class="success-content"><div class="success-message">${message}</div></div>`; document.body.appendChild(notification); setTimeout(()=>{ notification.remove();}, 3000);} function clearForm(){ document.getElementById("inputText").value=""; document.getElementById("editableContainer").innerHTML=""; window.generatedData=null;} function handleSubmitError(error){ hideLoading(); console.error('Submit Error:', error); let errorTitle="Submission Failed"; let errorMessage="An error occurred while submitting your data."; let errorDetails=error.message; if (error.message.includes("timeout")){ errorTitle="Request Timeout"; errorMessage="The request took too long to complete. Please try again.";} else if (error.message.includes("Invalid expense data")){ errorTitle="Validation Error"; errorMessage="Please fill in all required fields.";} showError(errorTitle, errorMessage, errorDetails);} ;(function(window, document, undefined){ 'use strict'; // Export necessary functions to global scope Object.assign(window,{ authorize: APP_FUNCTIONS.authorize, closeError: APP_FUNCTIONS.closeError, updateField: APP_FUNCTIONS.updateField, processInput: APP_FUNCTIONS.processInput, // Add any other functions that need to be globally available showError: APP_FUNCTIONS.showError, hideLoading: APP_FUNCTIONS.hideLoading, showLoading: APP_FUNCTIONS.showLoading, updateVersion: APP_FUNCTIONS.updateVersion, submitData: APP_FUNCTIONS.submitData});})(window, document); </script><script src="https://apis.google.com/js/api.js" defer></script><script src="https://accounts.google.com/gsi/client" defer></script></body></html>