<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://apis.google.com https://accounts.google.com https://sheets.googleapis.com https://*.googleapis.com https://raw.githubusercontent.com; connect-src 'self' http://127.0.0.1:* http://localhost:* https://sheets.googleapis.com https://accounts.google.com https://apis.googleapis.com https://*.googleapis.com https://raw.githubusercontent.com https://*.githubusercontent.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; frame-src https://accounts.google.com">
    <title>Expense Tracker v0.0.20</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e2e;
            color: #f5f5f5;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container {
            margin: 20px auto;
            width: 90%;
            max-width: 600px;
            background-color: #28293d;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            flex: 1;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
            margin-top: 0;
            color: #f5a623;
        }
        textarea {
            width: 100%;
            height: 120px;
            background-color: #33344b;
            color: #f5f5f5;
            border: none;
            padding: 5px;
            border-radius: 8px;
            font-size: 16px;
            resize: none;
        }
        textarea:focus {
            outline: none;
            border: 2px solid #f5a623;
        }
        button {
            width: 100%;
            padding: 15px;
            background-color: #f5a623;
            color: #1e1e2f;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background-color: #d48821;
        }
        .editable-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 15px 0;
            position: relative;
        }
        .editable-field {
            display: flex;
            flex-direction: column;
            margin-bottom: 0;
            position: relative;
            cursor: pointer;
        }
        .editable-field:hover::after {
            content: '✎';
            position: absolute;
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            color: #f5a623;
            font-size: 14px;
        }
        .editable-field.full-width {
            grid-column: 1 / -1;
        }
        .editable-label {
            font-size: 14px;
            margin-bottom: 5px;
            color: #8e8ea0;
        }
        .editable-input, .editable-select {
            padding: 8px 12px;
            border-radius: 8px;
            border: none;
            background-color: #33344b;
            color: #f5f5f5;
            font-size: 14px;
            height: 36px;
        }
        .editable-input[type="text"] {
            height: 36px;
        }
        .confidence-score {
            grid-column: 1 / -1;
            text-align: right;
            color: #8e8ea0;
            font-size: 14px;
            margin-top: 10px;
        }

        /* Loading Overlay */
        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        /* Loading Spinner */
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f5f5f5;
            border-top: 5px solid #f5a623;  /* Changed to use same color as other accents */
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }    /* Animation keyframes */
            100% { transform: rotate(360deg); } /* Animation keyframes */
        }

        /* Error Notification */
        .error-notification {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: #ff4444;
            color: white;
            padding: 15px;
            z-index: 1001;
            animation: slideDown 0.5s ease-out;
        }

        .error-notification.show {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .error-content {
            flex-grow: 1;
            margin-right: 20px;
        }

        .error-title {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .error-message {
            font-size: 14px;
        }

        .error-close {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 0 5px;
        }

        @keyframes slideDown {
            from { transform: translateY(-100%); }    /* Slide animation */
            to { transform: translateY(0); }          /* Slide animation */
        }

        .version {
            font-size: 14px;
            color: #f5a623;
            margin-left: 10px;
            opacity: 0.8;
        }

        /* Mobile optimization styles */
        @media screen and (max-width: 768px) {
            body {
                background-color: #28293d;
            }
            .container {
                margin: 0;
                width: 90%;
                max-width: 90%;
                min-height: 100vh;
                border-radius: 0;
                box-shadow: none;
                padding: 15px;
            }
            .input-section {
                padding: 15px;
            }
            .input-section textarea {
                height: 60px;
            }
            .results-section {
                padding: 0;
            }
            .editable-container {
                grid-template-columns: 1fr;
            }
        }

        /* Success Notification */
        .success-notification {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #4CAF50;
            color: white;
            padding: 15px;
            border-radius: 4px;
            z-index: 1001;
            animation: slideIn 0.5s ease-out;
        }

        .success-notification.show {
            display: block;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }


        .submit-confirmation {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #28293d;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            z-index: 1002;
            max-width: 80%;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }

        .submit-confirmation.show {
            display: block;
        }

        .submit-confirmation h3 {
            color: #f5a623;
            margin-top: 0;
        }

        .transaction-list {
            margin: 15px 0;
        }

        .transaction-item {
            padding: 10px;
            background-color: #33344b;
            border-radius: 5px;
            margin-bottom: 8px;
        }

        .confirmation-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .confirmation-buttons button {
            flex: 1;
            margin: 0;
        }

        .confirmation-buttons button.cancel {
            background-color: #666;
        }

        .transaction-navigation {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 10px 0;
        }

        .nav-button {
            background: #33344b;
            border: none;
            color: #f5f5f5;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .nav-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .transaction-indicator {
            color: #f5a623;
            font-size: 14px;
            margin: 0 10px;
        }

        .compact-view {
            display: none;
        }

        @media screen and (max-width: 768px) {
            .editable-container {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .editable-field {
                margin-bottom: 8px;
            }

            .standard-view {
                display: none;
            }

            .compact-view {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
                background: #33344b;
                padding: 10px;
                border-radius: 8px;
                margin-bottom: 10px;
            }

            .compact-field {
                font-size: 14px;
            }

            .compact-label {
                color: #8e8ea0;
                font-size: 12px;
                margin-bottom: 2px;
            }

            .compact-value {
                font-weight: bold;
            }

            .compact-field.full {
                grid-column: 1 / -1;
            }

            .container {
                padding: 10px;
            }

            .input-section textarea {
                height: 80px;
            }

            h1 {
                font-size: 20px;
                margin-bottom: 15px;
            }

        }

        .edited-indicator {
            position: absolute;
            right: -25px;
            top: 50%;
            transform: translateY(-50%);
            color: #4CAF50;
            font-size: 12px;
            font-weight: bold;
        }

        .edit-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #28293d;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            z-index: 1003;
            width: 90%;
            max-width: 400px;
            display: none;
        }
    

        .edit-modal-content {
            margin-bottom: 20px;
        }

        .edit-modal-buttons {
            display: flex;
            gap: 10px;
        }

        .edit-modal-buttons button {
            flex: 1;
            margin: 0;
        }

        .edit-modal-buttons button.cancel {
            background-color: #666;
        }

        .edit-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1002;
            display: none;
        }

        .edit-overlay.show {
            display: block;
        }

        .compact-field {
            cursor: pointer;
            position: relative;
        }

        .compact-field:hover::after {
            content: '✎';
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            color: #f5a623;
            font-size: 14px;
        }

        .compact-field.edited::before {
            content: '✓';
            position: absolute;
            left: -15px;
            top: 50%;
            transform: translateY(-50%);
            color: #4CAF50;
            font-size: 12px;
        }

        .editable-value {
            padding: 8px 12px;
            border-radius: 8px;
            background-color: #33344b;
            color: #f5f5f5;
            font-size: 14px;
            min-height: 36px;
            display: flex;
            align-items: center;
            transition: background-color 0.2s;
        }

        .editable-field:hover .editable-value {
            background-color: #3f4060;
        }

        .edit-modal .editable-input,
        .edit-modal .editable-select {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #33344b;
            background-color: #28293d;
            color: #f5f5f5;
            font-size: 16px;
            transition: border-color 0.2s;
        }

        .edit-modal .editable-input:focus,
        .edit-modal .editable-select:focus {
            outline: none;
            border-color: #f5a623;
        }

        .edit-modal h3 {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .edit-modal h3::before {
            content: '✎';
            color: #f5a623;
            font-size: 20px;
        }

        .edited-indicator {
            position: absolute;
            right: -25px;
            top: 50%;
            transform: translateY(-50%);
            color: #4CAF50;
            font-size: 12px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .edited .edited-indicator {
            opacity: 1;
        }

        .compact-field {
            position: relative;
            padding: 8px;
            border-radius: 6px;
            transition: background-color 0.2s;
        }

        .compact-field:hover {
            background-color: #3f4060;
        }

        .compact-field.edited {
            padding-left: 25px;
        }

        .compact-field.edited::before {
            left: 5px;
        }

        @media screen and (max-width: 768px) {
            .edit-modal {
                width: 95%;
                max-width: none;
                margin: 10px;
            }

            .edit-modal .editable-input,
            .edit-modal .editable-select {
                font-size: 16px; /* Prevent zoom on iOS */
                padding: 12px;
            }

            .edit-modal-buttons button {
                padding: 12px;
                font-size: 16px;
            }
        }

        /* Add swipe hint for mobile */
        @media (hover: none) {
            .transaction-navigation::after {
                content: 'Swipe to navigate';
                position: absolute;
                bottom: -20px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 12px;
                color: #8e8ea0;
                opacity: 0.7;
            }
        }
    </style>
</head>
<body>
    <div class="loading-overlay">
        <div class="loading-spinner"></div>
    </div>
    <div class="error-notification">
        <div class="error-content">
            <div class="error-title">Error Occurred</div>
            <div class="error-message"></div>
        </div>
        <button class="error-close" onclick="closeError()">×</button>
    </div>
    <div class="container">
        <h1>Expense Tracker <span class="version">v0.0.20</span></h1>
        <div class="results-section">
            <div class="transaction-navigation">
                <button class="nav-button" id="prevTransaction" disabled onclick="navigateTransaction(-1)">← Previous</button>
                <span class="transaction-indicator">1 of 1</span>
                <button class="nav-button" id="nextTransaction" disabled onclick="navigateTransaction(1)">Next →</button>
            </div>
            <div class="editable-container" id="editableContainer"></div>
        </div>
        <div class="input-section">
            <textarea id="inputText" placeholder="Type your expense description and press Enter... (Use && or 'Also' for multiple transactions)"></textarea>
            <button onclick="authorize()">Submit</button>
        </div>
    </div>

    <div class="edit-overlay"></div>
    <div class="edit-modal">
        <h3>Edit Field</h3>
        <div class="edit-modal-content"></div>
        <div class="edit-modal-buttons">
            <button class="cancel" onclick="closeEditModal()">Cancel</button>
            <button onclick="saveEdit()">Save</button>
        </div>
    </div>

    <div class="submit-confirmation">
        <h3>Confirm Transactions</h3>
        <div class="transaction-list"></div>
        <div class="confirmation-buttons">
            <button class="cancel" onclick="closeConfirmation()">Cancel</button>
            <button onclick="confirmSubmit()">Confirm</button>
        </div>
    </div>

    <script type="module">
        import config from './config.js';
        window.CLIENT_ID = config.clientId;
    </script>
    <script>
        /** Constants */
        const SCOPES = "https://www.googleapis.com/auth/spreadsheets";
        const SPREADSHEET_ID = "__SPREADSHEET_ID__";
        const FETCH_TIMEOUT = 30000;
        const EVENTS = {
            INPUT: 'input',
            KEYDOWN: 'keydown',
            LOAD: 'load',
            DOMCONTENTLOADED: 'DOMContentLoaded'
        };

        /** Global State */
        let generatedData = null;
        let tokenClient = null;
        let transactions = [];
        let currentTransactionIndex = 0;
        let currentEditField = null;

        /** Environment Configuration */
        const ENV = {
            isProd: window.location.hostname !== 'localhost',
            get apiBaseUrl() {
                return this.isProd ? 
                    'https://sheets.googleapis.com/v4/' : 
                    'http://localhost:3000/api/';
            }
        };

        /** Version Management */
        const VERSION = {
            major: 0,
            minor: 0,
            patch: 20,
            buildDate: '2024-03-19',
            toString() {
                return `${this.major}.${this.minor}.${this.patch}`;
            }
        };

        /** Token Management */
        const TOKEN_MANAGEMENT = {
            async isTokenValid(token) {
                if (!token) return false;
                try {
                    const response = await fetchWithTimeout(
                        `${ENV.apiBaseUrl}spreadsheets/${SPREADSHEET_ID}/values/ExpenseResults!A1`,
                        {
                            headers: { Authorization: `Bearer ${token}` },
                        }
                    );
                    return response.ok;
                } catch {
                    return false;
                }
            },

            storeToken(token) {
                try {
                    localStorage.setItem('expenseTrackerToken', token);
                    localStorage.setItem('tokenTimestamp', Date.now().toString());
                } catch (e) {
                    console.error('Error storing token:', e);
                }
            },

            getStoredToken() {
                try {
                    const token = localStorage.getItem('expenseTrackerToken');
                    const timestamp = parseInt(localStorage.getItem('tokenTimestamp'), 10);
                    if (token && timestamp && (Date.now() - timestamp < 3600000)) {
                        return token;
                    }
                } catch (e) {
                    console.error('Error getting token:', e);
                }
                return null;
            },

            clearStoredToken() {
                try {
                    localStorage.removeItem('expenseTrackerToken');
                    localStorage.removeItem('tokenTimestamp');
                } catch (e) {
                    console.error('Error clearing token:', e);
                }
            }
        };

        /** Utility Functions */
        async function fetchWithTimeout(url, options = {}) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT);
            
            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    throw new Error('Request timed out');
                }
                throw error;
            }
        }

        /** UI Functions */
        function showError(title, message, details = '') {
            const notification = document.querySelector('.error-notification');
            if (!notification) return;

            notification.querySelector('.error-title').textContent = title;
            notification.querySelector('.error-message').innerHTML = `
                <p>${message}</p>
                ${details ? `<p><strong>Details:</strong> ${details}</p>` : ''}
            `;
            notification.classList.add('show');
        }

        function closeError() {
            document.querySelector('.error-notification')?.classList.remove('show');
        }

        function showSuccess(message) {
            const existingNotification = document.querySelector('.success-notification');
            if (existingNotification) {
                existingNotification.remove();
            }

            const notification = document.createElement('div');
            notification.className = 'success-notification show';
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 3000);
        }

        function showLoading() {
            document.querySelector('.loading-overlay').style.display = 'flex';
        }

        function hideLoading() {
            document.querySelector('.loading-overlay').style.display = 'none';
        }

        /** Modal Functions */
        function showEditModal(field, value, type) {
            const modal = document.querySelector('.edit-modal');
            const overlay = document.querySelector('.edit-overlay');
            const content = modal.querySelector('.edit-modal-content');
            
            currentEditField = field;
            
            let inputHtml = '';
            switch(type) {
                case 'date':
                    inputHtml = `<input type="date" class="editable-input" value="${value}">`;
                    break;
                case 'number':
                    inputHtml = `<input type="number" class="editable-input" value="${value}" min="0" step="1000">`;
                    break;
                case 'category':
                    const categoryOptions = paidToOptions
                        .filter(option => !option.toLowerCase().startsWith('spent') && !option.toLowerCase().startsWith('gave'))
                        .map(option => `<option value="${option}" ${option === value ? "selected" : ""}>${option}</option>`)
                        .join("");
                    inputHtml = `<select class="editable-select">${categoryOptions}</select>`;
                    break;
                case 'paidTo':
                    const paidToOptionsHtml = paidToOptions
                        .map(option => `<option value="${option}" ${option === value ? "selected" : ""}>${option}</option>`)
                        .join("");
                    inputHtml = `<select class="editable-select">${paidToOptionsHtml}</select>`;
                    break;
                default:
                    inputHtml = `<input type="text" class="editable-input" value="${value}">`;
            }
            
            content.innerHTML = inputHtml;
            modal.classList.add('show');
            overlay.classList.add('show');
            
            const input = content.querySelector('input, select');
            input.focus();

            // Add keyboard event listeners
            input.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveEdit();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    closeEditModal();
                }
            });
        }

        function closeEditModal() {
            const modal = document.querySelector('.edit-modal');
            const overlay = document.querySelector('.edit-overlay');
            modal.classList.remove('show');
            overlay.classList.remove('show');
            currentEditField = null;
        }

        function saveEdit() {
            try {
                const modal = document.querySelector('.edit-modal');
                const input = modal.querySelector('input, select');
                const newValue = input.value.trim();
                
                if (!newValue) {
                    showError("Invalid Input", "Please enter a valid value.");
                    return;
                }
                
                if (transactions[currentTransactionIndex]) {
                    const oldValue = transactions[currentTransactionIndex][currentEditField];
                    
                    // Validate input based on field type
                    if (currentEditField === 'How much money? (Tsh)' && isNaN(newValue)) {
                        showError("Invalid Amount", "Please enter a valid number.");
                        return;
                    }
                    
                    transactions[currentTransactionIndex][currentEditField] = newValue;
                    
                    // Mark transaction as edited
                    if (!transactions[currentTransactionIndex].editedFields) {
                        transactions[currentTransactionIndex].editedFields = new Set();
                    }
                    transactions[currentTransactionIndex].editedFields.add(currentEditField);
                    
                    // Store training data for future predictions
                    storeEditTrainingData(currentEditField, oldValue, newValue, transactions[currentTransactionIndex]);
                    
                    // Refresh display
                    displayEditableFields(transactions[currentTransactionIndex]);
                    
                    // Show success indicator
                    showSuccess("Field updated successfully");
                }
                
                closeEditModal();
            } catch (error) {
                console.error('Error saving edit:', error);
                showError("Save Error", "Failed to save changes. Please try again.");
            }
        }

        /** Initialize Application */
        async function initializeApp() {
            try {
                setupEventListeners();
                const inputTextArea = document.getElementById('inputText');
                if (inputTextArea) {
                    inputTextArea.focus();
                }
            } catch (error) {
                console.error('Failed to initialize app:', error);
                showError(
                    'Initialization Error',
                    'Failed to initialize the application.',
                    error.message
                );
            }
        }

        /** Event Listeners */
        function setupEventListeners() {
            const inputTextArea = document.getElementById('inputText');
            if (!inputTextArea) return;

            // Cleanup existing listeners
            const newTextArea = inputTextArea.cloneNode(true);
            inputTextArea.parentNode.replaceChild(newTextArea, inputTextArea);
            
            let debounceTimeout;
            newTextArea.addEventListener('input', function() {
                clearTimeout(debounceTimeout);
                debounceTimeout = setTimeout(processInput, 300);
            });

            newTextArea.addEventListener('keydown', function(event) {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    clearTimeout(debounceTimeout);
                    processInput();
                }
            });

            newTextArea.addEventListener('paste', function() {
                setTimeout(processInput, 0);
            });

            // Improved container click handling
            document.querySelector('.container').addEventListener('click', function(event) {
                const isInteractive = event.target.closest('input, select, button, .editable-field, .compact-field, .edit-modal, .submit-confirmation');
                if (!isInteractive) {
                    newTextArea.focus();
                }
            });

            // Add error notification close handler
            document.querySelector('.error-close')?.addEventListener('click', closeError);

            // Add overlay click handlers
            document.querySelector('.edit-overlay')?.addEventListener('click', closeEditModal);
        }

 // Training data and analysis functions
 const trainingData = [
            { 
                category: "Petrol & Transport", 
                keywords: ["petrol", "raum", "bmw", "fuel", "gas", "diesel", "transport", "fare", "taxi", "uber", "bolt", "baught petrol", "put petrol", "filled", "mafuta", "put fuel", "transport to", "nauli"]
            },
            { 
                category: "Car Maintenance & Fee's", 
                keywords: ["repair", "maintenance", "oil", "service", "garage", "mechanic", "spare", "parts", "car wash", "insurance", "fundi", "fixed", "tire", "puncture", "parking", "brakes", "coil"]
            },
            {
                category: "Gift to Family & Friends",
                keywords: ["gave", "gift", "send", "irene", "family", "friend", "support", "help", "sent to", "mchango", "changia", "asked for", "faith", "tina", "benadeta", "wine", "bear", "konyag"]
            },
            {
                category: "Groceries",
                keywords: ["grocery", "shopping", "supermarket", "market", "food", "household", "milk", "water", "uhai", "mkaa", "rice", "mchele", "maziwa", "breakfast", "eggs", "sugar", "mboga", "gulio", "dogfood", "sabuni", "maid", "house", "domestic", "worker"]
            },
            {
                category: "Eating Out",
                keywords: ["food", "restaurant", "lunch", "dinner", "eat", "meal", "snack", "cafe", "bought food", "food at", "food while", "food from", "pizza", "kfc", "chips mayai", "mishkaki", "fast food", "mtori", "breakfast"]
            },
            {
                category: "Utilities",
                keywords: ["luku", "electricity", "water bill", "internet", "wifi", "gas", "trash", "takataka", "security", "netflix", "gass", "dawasa", "bill", "payment", "utility", "baught luku", "put luku", "added luku"]
            },
            {
                category: "Aaliyah School Fee",
                keywords: ["school", "fee", "aaliyah", "education", "tuition", "uniform", "books", "graduation", "karate"]
            }
        ];

        // Add utility-specific patterns
        const UTILITY_PATTERNS = {
            luku: ["luku", "electricity", "power"],
            water: ["water bill", "dawasa", "water payment"],
            internet: ["wifi", "internet", "netflix"],
            security: ["security", "ulinzi", "guard"],
            gas: ["gas", "gass", "gas cylinder"]
        };

        // First pass: Check exact phrases
        const exactPhrases = {
            "Eating Out": ["bought food", "food at", "food while", "food from", "pizza hut", "kfc", "chips mayai"],
            "Groceries": ["gave to maid", "left money home", "gave money to maid", "for home", "nyumbani"],
            "Gift to Family & Friends": ["gave to irene", "sent to irene", "gave irene", "irene asked"],
            "Utilities": ["baught luku", "paid luku", "added luku", "put luku", "paid bill", "water bill", "security payment"]
        };

        // Context weights
        const CONTEXT_WEIGHTS = {
            PRIMARY_ACTION: 0.35,
            RECIPIENT: 0.30,
            PURPOSE: 0.25,
            AMOUNT: 0.10
        };

        // Update fetch handling
        async function fetchWithTimeout(url, options = {}) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT);
            
            try {
                const response = await fetch(url, {
                    ...fetchConfig,
                    ...options,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    throw new Error('Request timed out');
                }
                console.error('Fetch error:', error);
                throw error;
            }
        }

        // Add the analyzeTextContext function
        function analyzeTextContext(text) {
            const lowerText = text.toLowerCase();
            let bestCategory = null;
            let highestConfidence = 0;
            let evidence = [];
            
            // First pass: Check utility-specific patterns
            for (const [utilityType, patterns] of Object.entries(UTILITY_PATTERNS)) {
                if (patterns.some(pattern => lowerText.includes(pattern))) {
                    bestCategory = "Utilities";
                    highestConfidence = 0.95;
                    evidence.push(`Utility match: ${utilityType}`);
                    break;
                }
            }

            // Second pass: Check exact phrases if no utility match
            if (!bestCategory) {
                for (const [category, phrases] of Object.entries(exactPhrases)) {
                    for (const phrase of phrases) {
                        if (lowerText.includes(phrase)) {
                            bestCategory = category;
                            highestConfidence = 0.95;
                            evidence.push(`Exact phrase match: "${phrase}"`);
                            break;
                        }
                    }
                    if (bestCategory) break;
                }
            }

            // Third pass: Check categories with context
            if (!bestCategory) {
                trainingData.forEach(category => {
                    let confidence = 0;
                    let categoryEvidence = [];

                    // Check keywords with word boundary
                    const keywordMatches = category.keywords.filter(keyword => {
                        const pattern = new RegExp(`\\b${keyword}\\b`, 'i');
                        return pattern.test(lowerText);
                    });
                    
                    if (keywordMatches.length > 0) {
                        const keywordScore = keywordMatches.length / category.keywords.length;
                        confidence += keywordScore * CONTEXT_WEIGHTS.PRIMARY_ACTION;
                        categoryEvidence.push(`Matched keywords: ${keywordMatches.join(", ")}`);
                    }

                    // Context-specific boosts
                    if (category.category === "Utilities" && 
                        (lowerText.includes("bill") || lowerText.includes("payment") || 
                         lowerText.includes("paid") || lowerText.includes("baught"))) {
                        confidence += 0.3;
                        categoryEvidence.push("Payment context boost");
                    }

                    if (confidence > highestConfidence) {
                        highestConfidence = confidence;
                        bestCategory = category.category;
                        evidence = categoryEvidence;
                    }
                });
            }

            // Normalize confidence to percentage
            const confidencePercentage = Math.min(Math.round(highestConfidence * 100), 100);

            return {
                category: bestCategory || "(OTHER) Food, Transport, Groceries, etc.",
                confidence: confidencePercentage,
                amount: extractAmount(text),
                evidence: evidence
            };
        }

        // Add helper functions
        function extractAmount(text) {
            const patterns = [
                /(\d+)k/i,
                /(\d+)[,\s]?000/,
                /(\d+)\s*thousand/i,
                /(\d+)/
            ];

            for (let pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    let amount = parseInt(match[1]);
                    if (pattern.toString().includes('k') || pattern.toString().includes('thousand')) {
                        amount *= 1000;
                    }
                    return amount;
                }
            }
            return 0;
        }

        // Add UI helper functions
        function showLoading() {
            document.querySelector('.loading-overlay').style.display = 'flex';
        }

        function hideLoading() {
            document.querySelector('.loading-overlay').style.display = 'none';
        }

        function showError(title, message, details) {
            const notification = document.querySelector('.error-notification');
            notification.querySelector('.error-title').textContent = title;
            notification.querySelector('.error-message').innerHTML = `
                <p>${message}</p>
                ${details ? `<p><strong>Details:</strong> ${details}</p>` : ''}
                ${message.includes('Authentication') ? '<p><strong>Solution:</strong> Please try submitting again to re-authenticate.</p>' : ''}
                ${message.includes('permission') ? '<p><strong>Solution:</strong> Please ensure you have edit access to the spreadsheet.</p>' : ''}
            `;
            notification.classList.add('show');
        }

        function closeError() {
            document.querySelector('.error-notification').classList.remove('show');
        }

        function showSuccess(message) {
            const notification = document.createElement('div');
            notification.className = 'success-notification show';
            notification.textContent = message;
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 3000);
        }

        // Add the missing processInput function
        function processInput() {
            const inputText = document.getElementById("inputText").value;
            if (inputText.trim() === "") {
                document.getElementById("editableContainer").innerHTML = "";
                window.generatedData = null;
                return;
            }

            const analysis = analyzeTextContext(inputText);
            
            // Determine paid to based on category and context
            let paidTo = determinePaidTo(inputText, analysis.category);

            window.generatedData = {
                "Date of Transaction": new Date().toISOString().split("T")[0],
                "Where did the money come from?": "ALBERT",
                "How much money? (Tsh)": analysis.amount.toString(),
                "What's the Purchase Category": analysis.category,
                "Purchase Description": inputText,
                "Where was the money payed to?": paidTo,
                "Confidance level": `${analysis.confidence}%`
            };

            displayEditableFields(window.generatedData);
            
            // Log evidence for debugging
            console.debug("Analysis Evidence:", analysis.evidence);
        }

        // Add the missing determinePaidTo function
        function determinePaidTo(text, category) {
            text = text.toLowerCase();
            
            // Direct recipient matches
            if (text.includes('irene')) {
                return "Gave to Irene";
            } else if (text.includes('maid') || text.includes('nyumbani') || text.includes('essau')) {
                return "Gave to Maid (nyumbani)";
            } else if (text.includes('bmw')) {
                return "Spent on BMW";
            } else if (text.includes('raum')) {
                return "Spent on Raum";
            } else if (text.includes('guta')) {
                return "Spent on Guta";
            } else if (text.includes('luku')) {
                return "Luku";
            } else if (text.includes('tina') || text.includes('tinah')) {
                return "Gave to Parents - Tina";
            } else if (text.includes('alrada')) {
                return "ALRADA - Expenses";
            } else if (text.includes('benadeta') || text.includes('benadetha')) {
                return "Gave to Benadeta";
            }

            // Category-based defaults
            const categoryDefaults = {
                "Gift to Family & Friends": "Gave to Irene",
                "Petrol & Transport": "Spent on Raum",
                "Car Maintenance & Fee's": "Spent on Raum",
                "Groceries": "Gave to Maid (nyumbani)",
                "Eating Out": "(OTHER) Food, Transport, Groceries, etc.",
                "Utilities": "(OTHER) Food, Transport, Groceries, etc.",
                "Aaliyah School Fee": "Aaliyah School Fee"
            };

            return categoryDefaults[category] || "(OTHER) Food, Transport, Groceries, etc.";
        }

        // Add the missing displayEditableFields function
        function displayEditableFields(data) {
            const container = document.getElementById("editableContainer");
            container.innerHTML = ``;

            /* Date Field */
            const dateField = document.createElement("div");
            dateField.className = "editable-field";
            dateField.innerHTML = `
                <label class="editable-label">Date</label>
                <input type="date" class="editable-input" value="${data["Date of Transaction"]}" onchange="updateField('Date of Transaction', this.value)">
            `;
            container.appendChild(dateField);

            /* Amount Field */
            const amountField = document.createElement("div");
            amountField.className = "editable-field";
            amountField.innerHTML = `
                <label class="editable-label">Amount (Tsh)</label>
                <input type="number" class="editable-input" value="${data["How much money? (Tsh)"]}" onchange="updateField('How much money? (Tsh)', this.value)">
            `;
            container.appendChild(amountField);

            /* Category Field */
            const categoryField = document.createElement("div");
            categoryField.className = "editable-field";
            const categoryOptions = trainingData
                .map(cat => `<option value="${cat.category}" ${cat.category === data["What's the Purchase Category"] ? "selected" : ""}>${cat.category}</option>`)
                .join("");
            categoryField.innerHTML = `
                <label class="editable-label">Category</label>
                <select class="editable-select" onchange="updateField('What\'s the Purchase Category', this.value)">
                    ${categoryOptions}
                    <option value="(OTHER) Food, Transport, Groceries, etc.">(OTHER) Food, Transport, Groceries, etc.</option>
                </select>
            `;
            container.appendChild(categoryField);

            /* Paid To Field */
            const paidToField = document.createElement("div");
            paidToField.className = "editable-field";
            const paidToOptions = [
                "Spent on BMW",
                "Spent on Raum",
                "Gave to Maid (nyumbani)",
                "Gave to Irene",
                "Aaliyah School Fee",
                "ALRADA - Expenses",
                "Gave to Parents - Tina",
                "Spent on Guta",
                "Luku",
                "(OTHER) Food, Transport, Groceries, etc."
            ].map(option => `<option value="${option}" ${option === data["Where was the money payed to?"] ? "selected" : ""}>${option}</option>`).join("");
            paidToField.innerHTML = `
                <label class="editable-label">Paid To</label>
                <select class="editable-select" onchange="updateField('Where was the money payed to?', this.value)">
                    ${paidToOptions}
                </select>
            `;
            container.appendChild(paidToField);

            /* Description Field */
            const descriptionField = document.createElement("div");
            descriptionField.className = "editable-field full-width";
            descriptionField.innerHTML = `
                <label class="editable-label">Description</label>
                <input type="text" class="editable-input" value="${data["Purchase Description"]}" onchange="updateField('Purchase Description', this.value)">
            `;
            container.appendChild(descriptionField);

            /* Confidence Score */
            const confidenceField = document.createElement("div");
            confidenceField.className = "confidence-score";
            confidenceField.innerHTML = `Confidence Score: ${data["Confidance level"]}`;
            container.appendChild(confidenceField);
        }




        /** Core Functions */
        function processInput() {
            const inputText = document.getElementById("inputText").value;
            if (inputText.trim() === "") {
                document.getElementById("editableContainer").innerHTML = "";
                transactions = [];
                updateTransactionCounter();
                return;
            }

            const transactionTexts = inputText
                .split(/&&|(?:Also|also|ALSO)/)
                .map(text => text.trim())
                .filter(text => text.length > 0);

            transactions = transactionTexts.map(text => {
                let analysis = analyzeTextContext(text);
               // analysis = applyHistoricalTraining(text, analysis);
                const paidTo = determinePaidTo(text, analysis.category);

                return {
                    "Date of Transaction": new Date().toISOString().split("T")[0],
                    "Where did the money come from?": "ALBERT",
                    "How much money? (Tsh)": analysis.amount.toString(),
                    "What's the Purchase Category": analysis.category,
                    "Purchase Description": text,
                    "Where was the money payed to?": paidTo,
                    "Confidance level": `${analysis.confidence}%`,
                    editedFields: new Set()
                };
            });

            currentTransactionIndex = 0;
            updateTransactionCounter();
            displayEditableFields(transactions[0]);
        }

        function updateTransactionCounter() {
            const indicator = document.querySelector('.transaction-indicator');
            const prevBtn = document.getElementById('prevTransaction');
            const nextBtn = document.getElementById('nextTransaction');
            
            if (transactions.length > 0) {
                indicator.textContent = `${currentTransactionIndex + 1} of ${transactions.length}`;
                prevBtn.disabled = currentTransactionIndex === 0;
                nextBtn.disabled = currentTransactionIndex === transactions.length - 1;
            } else {
                indicator.textContent = 'No Transactions';
                prevBtn.disabled = true;
                nextBtn.disabled = true;
            }
        }

        function navigateTransaction(direction) {
            const newIndex = currentTransactionIndex + direction;
            if (newIndex >= 0 && newIndex < transactions.length) {
                currentTransactionIndex = newIndex;
                displayEditableFields(transactions[currentTransactionIndex]);
                updateTransactionCounter();
            }
        }

        function displayEditableFields(data) {
            const container = document.getElementById("editableContainer");
            
            // Standard view (desktop)
            const standardView = document.createElement("div");
            standardView.className = "standard-view";

            /* Date Field */
            const dateField = document.createElement("div");
            dateField.className = "editable-field";
            dateField.setAttribute('data-field', 'Date of Transaction');
            dateField.setAttribute('data-edit-type', 'date');
            dateField.innerHTML = `
                <label class="editable-label">Date</label>
                <div class="editable-value">${data["Date of Transaction"]}</div>
            `;
            standardView.appendChild(dateField);

            /* Amount Field */
            const amountField = document.createElement("div");
            amountField.className = "editable-field";
            amountField.setAttribute('data-field', 'How much money? (Tsh)');
            amountField.setAttribute('data-edit-type', 'number');
            amountField.innerHTML = `
                <label class="editable-label">Amount (Tsh)</label>
                <div class="editable-value">${data["How much money? (Tsh)"]}</div>
            `;
            standardView.appendChild(amountField);

            /* Category Field */
            const categoryField = document.createElement("div");
            categoryField.className = "editable-field";
            categoryField.setAttribute('data-field', 'What\'s the Purchase Category');
            categoryField.setAttribute('data-edit-type', 'category');
            categoryField.innerHTML = `
                <label class="editable-label">Category</label>
                <div class="editable-value">${data["What's the Purchase Category"]}</div>
            `;
            standardView.appendChild(categoryField);

            /* Paid To Field */
            const paidToField = document.createElement("div");
            paidToField.className = "editable-field";
            paidToField.setAttribute('data-field', 'Where was the money payed to?');
            paidToField.setAttribute('data-edit-type', 'paidTo');
            paidToField.innerHTML = `
                <label class="editable-label">Paid To</label>
                <div class="editable-value">${data["Where was the money payed to?"]}</div>
            `;
            standardView.appendChild(paidToField);

            /* Description Field */
            const descriptionField = document.createElement("div");
            descriptionField.className = "editable-field full-width";
            descriptionField.setAttribute('data-field', 'Purchase Description');
            descriptionField.setAttribute('data-edit-type', 'text');
            descriptionField.innerHTML = `
                <label class="editable-label">Description</label>
                <div class="editable-value">${data["Purchase Description"]}</div>
            `;
            standardView.appendChild(descriptionField);

            // Compact view (mobile)
            const compactView = document.createElement("div");
            compactView.className = "compact-view";

            /* Amount and Date (side by side) */
            const amountCompact = document.createElement("div");
            amountCompact.className = "compact-field";
            amountCompact.setAttribute('data-field', 'How much money? (Tsh)');
            amountCompact.setAttribute('data-edit-type', 'number');
            amountCompact.innerHTML = `
                <div class="compact-label">Amount</div>
                <div class="compact-value">${data["How much money? (Tsh)"]} Tsh</div>
            `;
            compactView.appendChild(amountCompact);

            const dateCompact = document.createElement("div");
            dateCompact.className = "compact-field";
            dateCompact.setAttribute('data-field', 'Date of Transaction');
            dateCompact.setAttribute('data-edit-type', 'date');
            dateCompact.innerHTML = `
                <div class="compact-label">Date</div>
                <div class="compact-value">${data["Date of Transaction"]}</div>
            `;
            compactView.appendChild(dateCompact);

            /* Category and Paid To */
            const categoryCompact = document.createElement("div");
            categoryCompact.className = "compact-field";
            categoryCompact.setAttribute('data-field', 'What\'s the Purchase Category');
            categoryCompact.setAttribute('data-edit-type', 'category');
            categoryCompact.innerHTML = `
                <div class="compact-label">Category</div>
                <div class="compact-value">${data["What's the Purchase Category"]}</div>
            `;
            compactView.appendChild(categoryCompact);

            const paidToCompact = document.createElement("div");
            paidToCompact.className = "compact-field";
            paidToCompact.setAttribute('data-field', 'Where was the money payed to?');
            paidToCompact.setAttribute('data-edit-type', 'paidTo');
            paidToCompact.innerHTML = `
                <div class="compact-label">Paid To</div>
                <div class="compact-value">${data["Where was the money payed to?"]}</div>
            `;
            compactView.appendChild(paidToCompact);

            /* Description (full width) */
            const descriptionCompact = document.createElement("div");
            descriptionCompact.className = "compact-field full";
            descriptionCompact.setAttribute('data-field', 'Purchase Description');
            descriptionCompact.setAttribute('data-edit-type', 'text');
            descriptionCompact.innerHTML = `
                <div class="compact-label">Description</div>
                <div class="compact-value">${data["Purchase Description"]}</div>
            `;
            compactView.appendChild(descriptionCompact);

            // Clear and append both views
            container.innerHTML = '';
            container.appendChild(standardView);
            container.appendChild(compactView);

            // Add click handlers for editing
            const fields = container.querySelectorAll('.editable-field, .compact-field');
            fields.forEach(field => {
                field.addEventListener('click', function(e) {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
                    
                    const fieldType = this.getAttribute('data-field');
                    const currentValue = data[fieldType];
                    const editType = this.getAttribute('data-edit-type');
                    showEditModal(fieldType, currentValue, editType);
                });

                if (data.editedFields?.has(field.getAttribute('data-field'))) {
                    field.classList.add('edited');
                    const indicator = document.createElement('span');
                    indicator.className = 'edited-indicator';
                    indicator.textContent = '✓';
                    field.appendChild(indicator);
                }
            });
        }

        /** Authorization Functions */
        async function authorize() {
            if (transactions.length === 0) {
                showError("No Transactions", "Please enter at least one transaction before submitting.");
                return;
            }

            showConfirmation();
        }

        function showConfirmation() {
            const confirmation = document.querySelector('.submit-confirmation');
            const transactionList = confirmation.querySelector('.transaction-list');
            
            transactionList.innerHTML = transactions.map((transaction, index) => `
                <div class="transaction-item">
                    <strong>Transaction ${index + 1}:</strong><br>
                    Amount: ${transaction["How much money? (Tsh)"]} Tsh<br>
                    Category: ${transaction["What's the Purchase Category"]}<br>
                    Paid To: ${transaction["Where was the money payed to?"]}<br>
                    Description: ${transaction["Purchase Description"]}
                </div>
            `).join('');

            confirmation.classList.add('show');
        }

        function closeConfirmation() {
            document.querySelector('.submit-confirmation').classList.remove('show');
        }

        async function confirmSubmit() {
            closeConfirmation();
            const storedToken = TOKEN_MANAGEMENT.getStoredToken();
            
            if (storedToken) {
                const isValid = await TOKEN_MANAGEMENT.isTokenValid(storedToken);
                if (isValid) {
                    submitData(storedToken);
                    return;
                }
                TOKEN_MANAGEMENT.clearStoredToken();
            }

            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: window.CLIENT_ID,
                scope: SCOPES,
                callback: handleAuthResponse
            });
            
            tokenClient.requestAccessToken();
        }

        async function handleAuthResponse(response) {
            if (response.error) {
                console.error('Auth Error:', response.error);
                showError(
                    "Authentication Failed", 
                    "Failed to authenticate with Google. Please try again.",
                    response.error
                );
                TOKEN_MANAGEMENT.clearStoredToken();
                return;
            }

            try {
                TOKEN_MANAGEMENT.storeToken(response.access_token);
                submitData(response.access_token);
            } catch (error) {
                console.error('Auth Handler Error:', error);
                showError(
                    "Authentication Error",
                    "An error occurred while processing authentication.",
                    error.message
                );
            }
        }

        async function submitData(token) {
            showLoading();
            try {
                if (!transactions || transactions.length === 0) {
                    throw new Error('No transactions to submit');
                }

                // Submit each transaction
                for (const transaction of transactions) {
                    if (!validateExpenseData(transaction)) {
                        throw new Error('Invalid expense data');
                    }

                    // Update training patterns for each transaction
                    const patterns = loadTrainingPatterns() || {};
                    const key = `${transaction["What's the Purchase Category"]}|${transaction["Where was the money payed to?"]}`;
                    
                    if (!patterns[key]) {
                        patterns[key] = {
                            category: transaction["What's the Purchase Category"],
                            paidTo: transaction["Where was the money payed to?"],
                            keywords: new Set(),
                            frequency: 0,
                            amounts: []
                        };
                    }

                    const words = transaction["Purchase Description"]
                        .toLowerCase()
                        .split(/\s+/)
                        .filter(word => word.length > 3);
                    
                    words.forEach(word => patterns[key].keywords.add(word));
                    patterns[key].frequency++;
                    patterns[key].amounts.push(parseFloat(transaction["How much money? (Tsh)"]));

                    storeTrainingPatterns(patterns);
                }

                showSuccess(`Successfully submitted ${transactions.length} transaction${transactions.length > 1 ? 's' : ''}`);
                clearForm();
                
            } catch (error) {
                console.error('Submit Error:', error);
                showError(
                    "Submission Failed",
                    "Failed to submit transactions.",
                    error.message
                );
            } finally {
                hideLoading();
            }
        }

        function validateExpenseData(data) {
            const required = [
                "Date of Transaction",
                "Where did the money come from?",
                "How much money? (Tsh)",
                "What's the Purchase Category",
                "Purchase Description",
                "Where was the money payed to?"
            ];
            
            return required.every(field => {
                const value = data[field];
                return value !== undefined && value !== null && value !== '';
            });
        }

        function clearForm() {
            document.getElementById("inputText").value = "";
            document.getElementById("editableContainer").innerHTML = "";
            transactions = [];
            currentTransactionIndex = 0;
            updateTransactionCounter();
        }

        /** Training Data Functions */
        function storeTrainingPatterns(patterns) {
            try {
                localStorage.setItem('expensePatterns', JSON.stringify(patterns));
            } catch (e) {
                console.error('Error storing patterns:', e);
            }
        }

        function loadTrainingPatterns() {
            try {
                const stored = localStorage.getItem('expensePatterns');
                return stored ? JSON.parse(stored) : null;
            } catch (e) {
                console.error('Error loading patterns:', e);
                return null;
            }
        }

        function storeEditTrainingData(field, oldValue, newValue, transaction) {
            try {
                const trainingData = JSON.parse(localStorage.getItem('editTrainingData') || '{}');
                const key = transaction["Purchase Description"].toLowerCase();
                
                if (!trainingData[key]) {
                    trainingData[key] = {
                        corrections: {},
                        frequency: 0
                    };
                }
                
                if (!trainingData[key].corrections[field]) {
                    trainingData[key].corrections[field] = [];
                }
                
                trainingData[key].corrections[field].push({
                    from: oldValue,
                    to: newValue,
                    timestamp: new Date().toISOString()
                });
                
                trainingData[key].frequency++;
                
                localStorage.setItem('editTrainingData', JSON.stringify(trainingData));
            } catch (e) {
                console.error('Error storing training data:', e);
            }
        }

        /** Initialize on load */
        if (document.readyState === 'loading') {
            document.addEventListener(EVENTS.DOMCONTENTLOADED, initializeApp);
        } else {
            initializeApp();
        }

        // Make functions available globally
        Object.assign(window, {
            closeError,
            closeEditModal,
            saveEdit,
            showEditModal,
            processInput,
            authorize,
            confirmSubmit,
            navigateTransaction,
            closeConfirmation
        });
    </script>
    <script src="https://apis.google.com/js/api.js" defer></script>
    <script src="https://accounts.google.com/gsi/client" defer></script>
</body>
</html>

